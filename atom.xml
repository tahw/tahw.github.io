<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>李俊龙&#39;s Blog</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-07-06T15:00:15.407Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>jianghe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>AQS</title>
    <link href="http://example.com/2021/05/26/AQS/"/>
    <id>http://example.com/2021/05/26/AQS/</id>
    <published>2021-05-26T11:30:00.000Z</published>
    <updated>2021-07-06T15:00:15.407Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;AQS是什么呢？<code>AbstractQueuedSynchronizer</code>简称AQS。java并发变成核心在于java.concurrent.util包而juc当中的大多数同步器实现都是围绕着共同的基础行为，比如等待队列、条件队列、独占获取、共享获取等。而这个行为都是都是aqs去做的。下面是aqs的官方介绍。</p><pre>Provides a framework for implementing blocking locks and related synchronizers (semaphores, events, etc) that rely on <b><font color='red'>first-in-first-out (FIFO) wait queues.</font></b> This class is designed to be a useful basis for most kinds of synchronizers that rely on <b><font color='red'>a single atomic int value to represent state.</font></b></pre><h1 id="AQS依赖"><a href="#AQS依赖" class="headerlink" title="AQS依赖"></a>AQS依赖</h1><p><img src="/images/pasted-48.png" alt="AQS依赖图"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;根据上面类图，我们可以看见<code>ReentrantLock</code>、<code>Semaphore</code>、<code>ReentrantReadWriteLock</code>都是使用的AQS</p><h2 id="AQS特性"><a href="#AQS特性" class="headerlink" title="AQS特性"></a>AQS特性</h2><ul><li>阻塞等待队列</li><li>共享/独占</li><li>公平/非公平</li><li>可重入</li><li>允许中断</li></ul><p>除了lock外，在juc下面实现如latch、Barrier、BlockingQueue等都是基于AQS来实现的</p><ul><li>一般都是定义一个内部的Sync类，然后再去实现AbstractQueuedSynchronizer</li><li>将同步器所有调用都映射到Sync对应的方法</li><li>采用的模板模式-子类根据需要来实现具体的业务</li></ul><p>AQS volatile int state(32位)</p><ul><li>state表示资源的可用状态</li></ul><p>AQS 两种资源共享方式</p><ul><li>EXCLUSIVE，只有一个线程能执行，如ReentrantLock</li><li>SHARED，多个线程可以同时执行，如Semaphore、CountDownLatch</li></ul><p>AQS 两种队列</p><ul><li>CLH 同步等待队列</li><li>Condition 条件等待队列</li></ul><p>AQS 方法</p><ul><li>不同的自定义同步器争用共享资源的方式不同。自定义同步器只需要实现共享资源state的获取与释放方式即可。至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队），AQS已经在顶层实现好了</li><li>在AQS上，只有下面这几个方法是需要实现的</li><li>boolean isHeldExclusively()<ul><li>该线程是否正在独占资源。只有用到Condition才需要去实现</li></ul></li><li>boolean tryAcquire(int arg)<ul><li>独占模式。尝试获取资源，成功true，失败false</li></ul></li><li>boolean tryRelease(int arg)<ul><li>独占模式。尝试释放资源，成功true，失败false</li></ul></li><li>int tryAcquireShared(int arg)<ul><li>共享模式。尝试获取资源，负数表示失败，0表示成功但是没有剩余资源可用，正数表示成功而且有资源可用</li></ul></li><li>boolean tryReleaseShared(int arg)<ul><li>共享模式。尝试释放资源，如果释放后允许唤醒后续等待节点返回true，否则返回false</li></ul></li></ul><h2 id="AQS源码解析"><a href="#AQS源码解析" class="headerlink" title="AQS源码解析"></a>AQS源码解析</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;在真正看代码的时候，我们先知道怎么去使用，在这里通过<code>ReentrantLock</code>来深入说明aqs</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ReentrantLock reentrantLock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">false</span>);</span><br><span class="line"><span class="comment">// false 非公平锁、默认</span></span><br><span class="line"><span class="comment">// true 公平锁</span></span><br><span class="line">reentrantLock.lock(); <span class="comment">//加锁</span></span><br><span class="line">reentrantLock.unlock(); <span class="comment">//解锁</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;ReentrantLock是采用aqs框架实现的，是jdk并发访问的特性，它的功能类似于synchronized互斥锁，可以保证线程安全。它还支持手动加锁与解锁，支持加锁的公平性。</p><h3 id="ReentrantLock猜想"><a href="#ReentrantLock猜想" class="headerlink" title="ReentrantLock猜想"></a>ReentrantLock猜想</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;如果想实现一个ReentrantLock，你会如何实现呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">reentrantLock.lock(); 这个是加锁？那么加锁会干嘛？</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line"><span class="comment">// 1. 获取锁，获取成功后</span></span><br><span class="line"><span class="comment">// 执行业务逻辑</span></span><br><span class="line"><span class="comment">// 2. 获取锁失败</span></span><br><span class="line"><span class="comment">// 2.1 Thread.yield 让出cpu使用权，但是这里有个问题，一直让出会消耗cpu性能</span></span><br><span class="line"><span class="comment">// 2.2 Thread.sleep 休眠一下，但是有个问题，不知道休眠多久，有的业务代码时间长，有的业务代码时间短</span></span><br><span class="line"><span class="comment">// 2.3 阻塞一下，等到当前获取锁的线程释放了，那就让他不阻塞不就行了，LockSupport。</span></span><br><span class="line"><span class="comment">// 2.4 这里还要实现一个公平的特性，一想到公平性，那就是得排队，先进先出——队列，那在这里阻塞的时候需要放到队列queue里排队</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reentrantLock.unlock(); <span class="comment">//解锁</span></span><br><span class="line"><span class="comment">// 1. 在queue里取出元素，然后拿出来</span></span><br><span class="line"><span class="comment">// 2. 取出后在解锁的时候就让之前阻塞的线程唤醒了</span></span><br><span class="line">    </span><br><span class="line">结论</span><br><span class="line"><span class="number">1.</span> 获取锁，这里肯定是单线程了，可以使用<span class="keyword">synchronized</span>，这个有点太重，这里可以使用cas的方式，是一个原子操作，一次只能让一个线程成功，cas是依赖汇编指令：cmpxchg()</span><br><span class="line"><span class="number">2.</span> 队列queue</span><br><span class="line"><span class="number">3.</span> LockSupport(park 阻塞 和 unpark 非阻塞)</span><br><span class="line"><span class="number">4.</span> 自旋</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>那经过自己的思考和结论，AQS就是这样实现的。</p><h3 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h3><p><img src="/images/pasted-49.png" alt="AQS结构图"></p><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><h4 id="CLH同步等待队列"><a href="#CLH同步等待队列" class="headerlink" title="CLH同步等待队列"></a>CLH同步等待队列</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;AQS当中的同步队列也称CLH队列，CLH是Craig、Landin、Hagersten三人发明的基于双向链表数据结构的队列，是FIFO先进先出的等待队列，Java中的CLH队列是原CLH队列的一个变种，线程由原自旋机制改成阻塞机制</p><p><img src="/images/pasted-50.png" alt="CLH"></p><h4 id="Condition条件等待队列"><a href="#Condition条件等待队列" class="headerlink" title="Condition条件等待队列"></a>Condition条件等待队列</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;Condition是一个多线程间协调通信的工具类，使得某个或者某些线程一起等待某个条件，只有该条件具备时，这些等待的线程才被唤醒，从而重新争夺锁<br><img src="/images/pasted-51.png" alt="condition"></p><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p><code>ReentrantLock</code>代码，这里采用公平锁来介绍</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">5179523762034025860L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Performs &#123;<span class="doctag">@link</span> Lock#lock&#125;. The main reason for subclassing</span></span><br><span class="line"><span class="comment">         * is to allow fast path for nonfair version.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Performs non-fair tryLock.  tryAcquire is implemented in</span></span><br><span class="line"><span class="comment">         * subclasses, but both need nonfair try for trylock method.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 1. 非公平获取锁，只要判断资源状态state=0，如果这个时候有线程可以直接获取锁，这里就是非公平的概念（刚进来的线程和head后的第一个线程来争抢）</span></span><br><span class="line"><span class="comment">         * 2. 其他和公平是一样的</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                    setExclusiveOwnerThread(current);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">                <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">                <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">                setState(nextc);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * 释放锁</span></span><br><span class="line"><span class="comment">        **/</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">            <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">            <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                free = <span class="keyword">true</span>;</span><br><span class="line">                setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            setState(c);</span><br><span class="line">            <span class="keyword">return</span> free;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// While we must in general read state before owner,</span></span><br><span class="line">            <span class="comment">// we don&#x27;t need to do so to check if current thread is owner</span></span><br><span class="line">            <span class="keyword">return</span> getExclusiveOwnerThread() == Thread.currentThread();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">final</span> ConditionObject <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ConditionObject();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Methods relayed from outer class</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">final</span> Thread <span class="title">getOwner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getState() == <span class="number">0</span> ? <span class="keyword">null</span> : getExclusiveOwnerThread();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getHoldCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> isHeldExclusively() ? getState() : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getState() != <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Reconstitutes the instance from a stream (that is, deserializes it).</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">            s.defaultReadObject();</span><br><span class="line">            setState(<span class="number">0</span>); <span class="comment">// reset to unlocked state</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 非公平锁</span></span><br><span class="line"><span class="comment">     * Sync object for non-fair locks</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">7316153563782823691L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Performs lock.  Try immediate barge, backing up to normal</span></span><br><span class="line"><span class="comment">         * acquire on failure.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                acquire(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 公平锁</span></span><br><span class="line"><span class="comment">     * Sync object for fair locks</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">3000897897090466540L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 调用AQS方法</span></span><br><span class="line">            acquire(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Fair version of tryAcquire.  Don&#x27;t grant access unless</span></span><br><span class="line"><span class="comment">         * recursive call or no waiters or is first.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 1. 尝试获取锁，判断有没有state资源可以用，如果有的话，还要判断队列里面有没有节点，如果有就去获取锁</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                    compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                    setExclusiveOwnerThread(current);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">                <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">                <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">                setState(nextc);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>AbstractQueuedSynchronizer</code>代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br><span class="line">841</span><br><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br><span class="line">848</span><br><span class="line">849</span><br><span class="line">850</span><br><span class="line">851</span><br><span class="line">852</span><br><span class="line">853</span><br><span class="line">854</span><br><span class="line">855</span><br><span class="line">856</span><br><span class="line">857</span><br><span class="line">858</span><br><span class="line">859</span><br><span class="line">860</span><br><span class="line">861</span><br><span class="line">862</span><br><span class="line">863</span><br><span class="line">864</span><br><span class="line">865</span><br><span class="line">866</span><br><span class="line">867</span><br><span class="line">868</span><br><span class="line">869</span><br><span class="line">870</span><br><span class="line">871</span><br><span class="line">872</span><br><span class="line">873</span><br><span class="line">874</span><br><span class="line">875</span><br><span class="line">876</span><br><span class="line">877</span><br><span class="line">878</span><br><span class="line">879</span><br><span class="line">880</span><br><span class="line">881</span><br><span class="line">882</span><br><span class="line">883</span><br><span class="line">884</span><br><span class="line">885</span><br><span class="line">886</span><br><span class="line">887</span><br><span class="line">888</span><br><span class="line">889</span><br><span class="line">890</span><br><span class="line">891</span><br><span class="line">892</span><br><span class="line">893</span><br><span class="line">894</span><br><span class="line">895</span><br><span class="line">896</span><br><span class="line">897</span><br><span class="line">898</span><br><span class="line">899</span><br><span class="line">900</span><br><span class="line">901</span><br><span class="line">902</span><br><span class="line">903</span><br><span class="line">904</span><br><span class="line">905</span><br><span class="line">906</span><br><span class="line">907</span><br><span class="line">908</span><br><span class="line">909</span><br><span class="line">910</span><br><span class="line">911</span><br><span class="line">912</span><br><span class="line">913</span><br><span class="line">914</span><br><span class="line">915</span><br><span class="line">916</span><br><span class="line">917</span><br><span class="line">918</span><br><span class="line">919</span><br><span class="line">920</span><br><span class="line">921</span><br><span class="line">922</span><br><span class="line">923</span><br><span class="line">924</span><br><span class="line">925</span><br><span class="line">926</span><br><span class="line">927</span><br><span class="line">928</span><br><span class="line">929</span><br><span class="line">930</span><br><span class="line">931</span><br><span class="line">932</span><br><span class="line">933</span><br><span class="line">934</span><br><span class="line">935</span><br><span class="line">936</span><br><span class="line">937</span><br><span class="line">938</span><br><span class="line">939</span><br><span class="line">940</span><br><span class="line">941</span><br><span class="line">942</span><br><span class="line">943</span><br><span class="line">944</span><br><span class="line">945</span><br><span class="line">946</span><br><span class="line">947</span><br><span class="line">948</span><br><span class="line">949</span><br><span class="line">950</span><br><span class="line">951</span><br><span class="line">952</span><br><span class="line">953</span><br><span class="line">954</span><br><span class="line">955</span><br><span class="line">956</span><br><span class="line">957</span><br><span class="line">958</span><br><span class="line">959</span><br><span class="line">960</span><br><span class="line">961</span><br><span class="line">962</span><br><span class="line">963</span><br><span class="line">964</span><br><span class="line">965</span><br><span class="line">966</span><br><span class="line">967</span><br><span class="line">968</span><br><span class="line">969</span><br><span class="line">970</span><br><span class="line">971</span><br><span class="line">972</span><br><span class="line">973</span><br><span class="line">974</span><br><span class="line">975</span><br><span class="line">976</span><br><span class="line">977</span><br><span class="line">978</span><br><span class="line">979</span><br><span class="line">980</span><br><span class="line">981</span><br><span class="line">982</span><br><span class="line">983</span><br><span class="line">984</span><br><span class="line">985</span><br><span class="line">986</span><br><span class="line">987</span><br><span class="line">988</span><br><span class="line">989</span><br><span class="line">990</span><br><span class="line">991</span><br><span class="line">992</span><br><span class="line">993</span><br><span class="line">994</span><br><span class="line">995</span><br><span class="line">996</span><br><span class="line">997</span><br><span class="line">998</span><br><span class="line">999</span><br><span class="line">1000</span><br><span class="line">1001</span><br><span class="line">1002</span><br><span class="line">1003</span><br><span class="line">1004</span><br><span class="line">1005</span><br><span class="line">1006</span><br><span class="line">1007</span><br><span class="line">1008</span><br><span class="line">1009</span><br><span class="line">1010</span><br><span class="line">1011</span><br><span class="line">1012</span><br><span class="line">1013</span><br><span class="line">1014</span><br><span class="line">1015</span><br><span class="line">1016</span><br><span class="line">1017</span><br><span class="line">1018</span><br><span class="line">1019</span><br><span class="line">1020</span><br><span class="line">1021</span><br><span class="line">1022</span><br><span class="line">1023</span><br><span class="line">1024</span><br><span class="line">1025</span><br><span class="line">1026</span><br><span class="line">1027</span><br><span class="line">1028</span><br><span class="line">1029</span><br><span class="line">1030</span><br><span class="line">1031</span><br><span class="line">1032</span><br><span class="line">1033</span><br><span class="line">1034</span><br><span class="line">1035</span><br><span class="line">1036</span><br><span class="line">1037</span><br><span class="line">1038</span><br><span class="line">1039</span><br><span class="line">1040</span><br><span class="line">1041</span><br><span class="line">1042</span><br><span class="line">1043</span><br><span class="line">1044</span><br><span class="line">1045</span><br><span class="line">1046</span><br><span class="line">1047</span><br><span class="line">1048</span><br><span class="line">1049</span><br><span class="line">1050</span><br><span class="line">1051</span><br><span class="line">1052</span><br><span class="line">1053</span><br><span class="line">1054</span><br><span class="line">1055</span><br><span class="line">1056</span><br><span class="line">1057</span><br><span class="line">1058</span><br><span class="line">1059</span><br><span class="line">1060</span><br><span class="line">1061</span><br><span class="line">1062</span><br><span class="line">1063</span><br><span class="line">1064</span><br><span class="line">1065</span><br><span class="line">1066</span><br><span class="line">1067</span><br><span class="line">1068</span><br><span class="line">1069</span><br><span class="line">1070</span><br><span class="line">1071</span><br><span class="line">1072</span><br><span class="line">1073</span><br><span class="line">1074</span><br><span class="line">1075</span><br><span class="line">1076</span><br><span class="line">1077</span><br><span class="line">1078</span><br><span class="line">1079</span><br><span class="line">1080</span><br><span class="line">1081</span><br><span class="line">1082</span><br><span class="line">1083</span><br><span class="line">1084</span><br><span class="line">1085</span><br><span class="line">1086</span><br><span class="line">1087</span><br><span class="line">1088</span><br><span class="line">1089</span><br><span class="line">1090</span><br><span class="line">1091</span><br><span class="line">1092</span><br><span class="line">1093</span><br><span class="line">1094</span><br><span class="line">1095</span><br><span class="line">1096</span><br><span class="line">1097</span><br><span class="line">1098</span><br><span class="line">1099</span><br><span class="line">1100</span><br><span class="line">1101</span><br><span class="line">1102</span><br><span class="line">1103</span><br><span class="line">1104</span><br><span class="line">1105</span><br><span class="line">1106</span><br><span class="line">1107</span><br><span class="line">1108</span><br><span class="line">1109</span><br><span class="line">1110</span><br><span class="line">1111</span><br><span class="line">1112</span><br><span class="line">1113</span><br><span class="line">1114</span><br><span class="line">1115</span><br><span class="line">1116</span><br><span class="line">1117</span><br><span class="line">1118</span><br><span class="line">1119</span><br><span class="line">1120</span><br><span class="line">1121</span><br><span class="line">1122</span><br><span class="line">1123</span><br><span class="line">1124</span><br><span class="line">1125</span><br><span class="line">1126</span><br><span class="line">1127</span><br><span class="line">1128</span><br><span class="line">1129</span><br><span class="line">1130</span><br><span class="line">1131</span><br><span class="line">1132</span><br><span class="line">1133</span><br><span class="line">1134</span><br><span class="line">1135</span><br><span class="line">1136</span><br><span class="line">1137</span><br><span class="line">1138</span><br><span class="line">1139</span><br><span class="line">1140</span><br><span class="line">1141</span><br><span class="line">1142</span><br><span class="line">1143</span><br><span class="line">1144</span><br><span class="line">1145</span><br><span class="line">1146</span><br><span class="line">1147</span><br><span class="line">1148</span><br><span class="line">1149</span><br><span class="line">1150</span><br><span class="line">1151</span><br><span class="line">1152</span><br><span class="line">1153</span><br><span class="line">1154</span><br><span class="line">1155</span><br><span class="line">1156</span><br><span class="line">1157</span><br><span class="line">1158</span><br><span class="line">1159</span><br><span class="line">1160</span><br><span class="line">1161</span><br><span class="line">1162</span><br><span class="line">1163</span><br><span class="line">1164</span><br><span class="line">1165</span><br><span class="line">1166</span><br><span class="line">1167</span><br><span class="line">1168</span><br><span class="line">1169</span><br><span class="line">1170</span><br><span class="line">1171</span><br><span class="line">1172</span><br><span class="line">1173</span><br><span class="line">1174</span><br><span class="line">1175</span><br><span class="line">1176</span><br><span class="line">1177</span><br><span class="line">1178</span><br><span class="line">1179</span><br><span class="line">1180</span><br><span class="line">1181</span><br><span class="line">1182</span><br><span class="line">1183</span><br><span class="line">1184</span><br><span class="line">1185</span><br><span class="line">1186</span><br><span class="line">1187</span><br><span class="line">1188</span><br><span class="line">1189</span><br><span class="line">1190</span><br><span class="line">1191</span><br><span class="line">1192</span><br><span class="line">1193</span><br><span class="line">1194</span><br><span class="line">1195</span><br><span class="line">1196</span><br><span class="line">1197</span><br><span class="line">1198</span><br><span class="line">1199</span><br><span class="line">1200</span><br><span class="line">1201</span><br><span class="line">1202</span><br><span class="line">1203</span><br><span class="line">1204</span><br><span class="line">1205</span><br><span class="line">1206</span><br><span class="line">1207</span><br><span class="line">1208</span><br><span class="line">1209</span><br><span class="line">1210</span><br><span class="line">1211</span><br><span class="line">1212</span><br><span class="line">1213</span><br><span class="line">1214</span><br><span class="line">1215</span><br><span class="line">1216</span><br><span class="line">1217</span><br><span class="line">1218</span><br><span class="line">1219</span><br><span class="line">1220</span><br><span class="line">1221</span><br><span class="line">1222</span><br><span class="line">1223</span><br><span class="line">1224</span><br><span class="line">1225</span><br><span class="line">1226</span><br><span class="line">1227</span><br><span class="line">1228</span><br><span class="line">1229</span><br><span class="line">1230</span><br><span class="line">1231</span><br><span class="line">1232</span><br><span class="line">1233</span><br><span class="line">1234</span><br><span class="line">1235</span><br><span class="line">1236</span><br><span class="line">1237</span><br><span class="line">1238</span><br><span class="line">1239</span><br><span class="line">1240</span><br><span class="line">1241</span><br><span class="line">1242</span><br><span class="line">1243</span><br><span class="line">1244</span><br><span class="line">1245</span><br><span class="line">1246</span><br><span class="line">1247</span><br><span class="line">1248</span><br><span class="line">1249</span><br><span class="line">1250</span><br><span class="line">1251</span><br><span class="line">1252</span><br><span class="line">1253</span><br><span class="line">1254</span><br><span class="line">1255</span><br><span class="line">1256</span><br><span class="line">1257</span><br><span class="line">1258</span><br><span class="line">1259</span><br><span class="line">1260</span><br><span class="line">1261</span><br><span class="line">1262</span><br><span class="line">1263</span><br><span class="line">1264</span><br><span class="line">1265</span><br><span class="line">1266</span><br><span class="line">1267</span><br><span class="line">1268</span><br><span class="line">1269</span><br><span class="line">1270</span><br><span class="line">1271</span><br><span class="line">1272</span><br><span class="line">1273</span><br><span class="line">1274</span><br><span class="line">1275</span><br><span class="line">1276</span><br><span class="line">1277</span><br><span class="line">1278</span><br><span class="line">1279</span><br><span class="line">1280</span><br><span class="line">1281</span><br><span class="line">1282</span><br><span class="line">1283</span><br><span class="line">1284</span><br><span class="line">1285</span><br><span class="line">1286</span><br><span class="line">1287</span><br><span class="line">1288</span><br><span class="line">1289</span><br><span class="line">1290</span><br><span class="line">1291</span><br><span class="line">1292</span><br><span class="line">1293</span><br><span class="line">1294</span><br><span class="line">1295</span><br><span class="line">1296</span><br><span class="line">1297</span><br><span class="line">1298</span><br><span class="line">1299</span><br><span class="line">1300</span><br><span class="line">1301</span><br><span class="line">1302</span><br><span class="line">1303</span><br><span class="line">1304</span><br><span class="line">1305</span><br><span class="line">1306</span><br><span class="line">1307</span><br><span class="line">1308</span><br><span class="line">1309</span><br><span class="line">1310</span><br><span class="line">1311</span><br><span class="line">1312</span><br><span class="line">1313</span><br><span class="line">1314</span><br><span class="line">1315</span><br><span class="line">1316</span><br><span class="line">1317</span><br><span class="line">1318</span><br><span class="line">1319</span><br><span class="line">1320</span><br><span class="line">1321</span><br><span class="line">1322</span><br><span class="line">1323</span><br><span class="line">1324</span><br><span class="line">1325</span><br><span class="line">1326</span><br><span class="line">1327</span><br><span class="line">1328</span><br><span class="line">1329</span><br><span class="line">1330</span><br><span class="line">1331</span><br><span class="line">1332</span><br><span class="line">1333</span><br><span class="line">1334</span><br><span class="line">1335</span><br><span class="line">1336</span><br><span class="line">1337</span><br><span class="line">1338</span><br><span class="line">1339</span><br><span class="line">1340</span><br><span class="line">1341</span><br><span class="line">1342</span><br><span class="line">1343</span><br><span class="line">1344</span><br><span class="line">1345</span><br><span class="line">1346</span><br><span class="line">1347</span><br><span class="line">1348</span><br><span class="line">1349</span><br><span class="line">1350</span><br><span class="line">1351</span><br><span class="line">1352</span><br><span class="line">1353</span><br><span class="line">1354</span><br><span class="line">1355</span><br><span class="line">1356</span><br><span class="line">1357</span><br><span class="line">1358</span><br><span class="line">1359</span><br><span class="line">1360</span><br><span class="line">1361</span><br><span class="line">1362</span><br><span class="line">1363</span><br><span class="line">1364</span><br><span class="line">1365</span><br><span class="line">1366</span><br><span class="line">1367</span><br><span class="line">1368</span><br><span class="line">1369</span><br><span class="line">1370</span><br><span class="line">1371</span><br><span class="line">1372</span><br><span class="line">1373</span><br><span class="line">1374</span><br><span class="line">1375</span><br><span class="line">1376</span><br><span class="line">1377</span><br><span class="line">1378</span><br><span class="line">1379</span><br><span class="line">1380</span><br><span class="line">1381</span><br><span class="line">1382</span><br><span class="line">1383</span><br><span class="line">1384</span><br><span class="line">1385</span><br><span class="line">1386</span><br><span class="line">1387</span><br><span class="line">1388</span><br><span class="line">1389</span><br><span class="line">1390</span><br><span class="line">1391</span><br><span class="line">1392</span><br><span class="line">1393</span><br><span class="line">1394</span><br><span class="line">1395</span><br><span class="line">1396</span><br><span class="line">1397</span><br><span class="line">1398</span><br><span class="line">1399</span><br><span class="line">1400</span><br><span class="line">1401</span><br><span class="line">1402</span><br><span class="line">1403</span><br><span class="line">1404</span><br><span class="line">1405</span><br><span class="line">1406</span><br><span class="line">1407</span><br><span class="line">1408</span><br><span class="line">1409</span><br><span class="line">1410</span><br><span class="line">1411</span><br><span class="line">1412</span><br><span class="line">1413</span><br><span class="line">1414</span><br><span class="line">1415</span><br><span class="line">1416</span><br><span class="line">1417</span><br><span class="line">1418</span><br><span class="line">1419</span><br><span class="line">1420</span><br><span class="line">1421</span><br><span class="line">1422</span><br><span class="line">1423</span><br><span class="line">1424</span><br><span class="line">1425</span><br><span class="line">1426</span><br><span class="line">1427</span><br><span class="line">1428</span><br><span class="line">1429</span><br><span class="line">1430</span><br><span class="line">1431</span><br><span class="line">1432</span><br><span class="line">1433</span><br><span class="line">1434</span><br><span class="line">1435</span><br><span class="line">1436</span><br><span class="line">1437</span><br><span class="line">1438</span><br><span class="line">1439</span><br><span class="line">1440</span><br><span class="line">1441</span><br><span class="line">1442</span><br><span class="line">1443</span><br><span class="line">1444</span><br><span class="line">1445</span><br><span class="line">1446</span><br><span class="line">1447</span><br><span class="line">1448</span><br><span class="line">1449</span><br><span class="line">1450</span><br><span class="line">1451</span><br><span class="line">1452</span><br><span class="line">1453</span><br><span class="line">1454</span><br><span class="line">1455</span><br><span class="line">1456</span><br><span class="line">1457</span><br><span class="line">1458</span><br><span class="line">1459</span><br><span class="line">1460</span><br><span class="line">1461</span><br><span class="line">1462</span><br><span class="line">1463</span><br><span class="line">1464</span><br><span class="line">1465</span><br><span class="line">1466</span><br><span class="line">1467</span><br><span class="line">1468</span><br><span class="line">1469</span><br><span class="line">1470</span><br><span class="line">1471</span><br><span class="line">1472</span><br><span class="line">1473</span><br><span class="line">1474</span><br><span class="line">1475</span><br><span class="line">1476</span><br><span class="line">1477</span><br><span class="line">1478</span><br><span class="line">1479</span><br><span class="line">1480</span><br><span class="line">1481</span><br><span class="line">1482</span><br><span class="line">1483</span><br><span class="line">1484</span><br><span class="line">1485</span><br><span class="line">1486</span><br><span class="line">1487</span><br><span class="line">1488</span><br><span class="line">1489</span><br><span class="line">1490</span><br><span class="line">1491</span><br><span class="line">1492</span><br><span class="line">1493</span><br><span class="line">1494</span><br><span class="line">1495</span><br><span class="line">1496</span><br><span class="line">1497</span><br><span class="line">1498</span><br><span class="line">1499</span><br><span class="line">1500</span><br><span class="line">1501</span><br><span class="line">1502</span><br><span class="line">1503</span><br><span class="line">1504</span><br><span class="line">1505</span><br><span class="line">1506</span><br><span class="line">1507</span><br><span class="line">1508</span><br><span class="line">1509</span><br><span class="line">1510</span><br><span class="line">1511</span><br><span class="line">1512</span><br><span class="line">1513</span><br><span class="line">1514</span><br><span class="line">1515</span><br><span class="line">1516</span><br><span class="line">1517</span><br><span class="line">1518</span><br><span class="line">1519</span><br><span class="line">1520</span><br><span class="line">1521</span><br><span class="line">1522</span><br><span class="line">1523</span><br><span class="line">1524</span><br><span class="line">1525</span><br><span class="line">1526</span><br><span class="line">1527</span><br><span class="line">1528</span><br><span class="line">1529</span><br><span class="line">1530</span><br><span class="line">1531</span><br><span class="line">1532</span><br><span class="line">1533</span><br><span class="line">1534</span><br><span class="line">1535</span><br><span class="line">1536</span><br><span class="line">1537</span><br><span class="line">1538</span><br><span class="line">1539</span><br><span class="line">1540</span><br><span class="line">1541</span><br><span class="line">1542</span><br><span class="line">1543</span><br><span class="line">1544</span><br><span class="line">1545</span><br><span class="line">1546</span><br><span class="line">1547</span><br><span class="line">1548</span><br><span class="line">1549</span><br><span class="line">1550</span><br><span class="line">1551</span><br><span class="line">1552</span><br><span class="line">1553</span><br><span class="line">1554</span><br><span class="line">1555</span><br><span class="line">1556</span><br><span class="line">1557</span><br><span class="line">1558</span><br><span class="line">1559</span><br><span class="line">1560</span><br><span class="line">1561</span><br><span class="line">1562</span><br><span class="line">1563</span><br><span class="line">1564</span><br><span class="line">1565</span><br><span class="line">1566</span><br><span class="line">1567</span><br><span class="line">1568</span><br><span class="line">1569</span><br><span class="line">1570</span><br><span class="line">1571</span><br><span class="line">1572</span><br><span class="line">1573</span><br><span class="line">1574</span><br><span class="line">1575</span><br><span class="line">1576</span><br><span class="line">1577</span><br><span class="line">1578</span><br><span class="line">1579</span><br><span class="line">1580</span><br><span class="line">1581</span><br><span class="line">1582</span><br><span class="line">1583</span><br><span class="line">1584</span><br><span class="line">1585</span><br><span class="line">1586</span><br><span class="line">1587</span><br><span class="line">1588</span><br><span class="line">1589</span><br><span class="line">1590</span><br><span class="line">1591</span><br><span class="line">1592</span><br><span class="line">1593</span><br><span class="line">1594</span><br><span class="line">1595</span><br><span class="line">1596</span><br><span class="line">1597</span><br><span class="line">1598</span><br><span class="line">1599</span><br><span class="line">1600</span><br><span class="line">1601</span><br><span class="line">1602</span><br><span class="line">1603</span><br><span class="line">1604</span><br><span class="line">1605</span><br><span class="line">1606</span><br><span class="line">1607</span><br><span class="line">1608</span><br><span class="line">1609</span><br><span class="line">1610</span><br><span class="line">1611</span><br><span class="line">1612</span><br><span class="line">1613</span><br><span class="line">1614</span><br><span class="line">1615</span><br><span class="line">1616</span><br><span class="line">1617</span><br><span class="line">1618</span><br><span class="line">1619</span><br><span class="line">1620</span><br><span class="line">1621</span><br><span class="line">1622</span><br><span class="line">1623</span><br><span class="line">1624</span><br><span class="line">1625</span><br><span class="line">1626</span><br><span class="line">1627</span><br><span class="line">1628</span><br><span class="line">1629</span><br><span class="line">1630</span><br><span class="line">1631</span><br><span class="line">1632</span><br><span class="line">1633</span><br><span class="line">1634</span><br><span class="line">1635</span><br><span class="line">1636</span><br><span class="line">1637</span><br><span class="line">1638</span><br><span class="line">1639</span><br><span class="line">1640</span><br><span class="line">1641</span><br><span class="line">1642</span><br><span class="line">1643</span><br><span class="line">1644</span><br><span class="line">1645</span><br><span class="line">1646</span><br><span class="line">1647</span><br><span class="line">1648</span><br><span class="line">1649</span><br><span class="line">1650</span><br><span class="line">1651</span><br><span class="line">1652</span><br><span class="line">1653</span><br><span class="line">1654</span><br><span class="line">1655</span><br><span class="line">1656</span><br><span class="line">1657</span><br><span class="line">1658</span><br><span class="line">1659</span><br><span class="line">1660</span><br><span class="line">1661</span><br><span class="line">1662</span><br><span class="line">1663</span><br><span class="line">1664</span><br><span class="line">1665</span><br><span class="line">1666</span><br><span class="line">1667</span><br><span class="line">1668</span><br><span class="line">1669</span><br><span class="line">1670</span><br><span class="line">1671</span><br><span class="line">1672</span><br><span class="line">1673</span><br><span class="line">1674</span><br><span class="line">1675</span><br><span class="line">1676</span><br><span class="line">1677</span><br><span class="line">1678</span><br><span class="line">1679</span><br><span class="line">1680</span><br><span class="line">1681</span><br><span class="line">1682</span><br><span class="line">1683</span><br><span class="line">1684</span><br><span class="line">1685</span><br><span class="line">1686</span><br><span class="line">1687</span><br><span class="line">1688</span><br><span class="line">1689</span><br><span class="line">1690</span><br><span class="line">1691</span><br><span class="line">1692</span><br><span class="line">1693</span><br><span class="line">1694</span><br><span class="line">1695</span><br><span class="line">1696</span><br><span class="line">1697</span><br><span class="line">1698</span><br><span class="line">1699</span><br><span class="line">1700</span><br><span class="line">1701</span><br><span class="line">1702</span><br><span class="line">1703</span><br><span class="line">1704</span><br><span class="line">1705</span><br><span class="line">1706</span><br><span class="line">1707</span><br><span class="line">1708</span><br><span class="line">1709</span><br><span class="line">1710</span><br><span class="line">1711</span><br><span class="line">1712</span><br><span class="line">1713</span><br><span class="line">1714</span><br><span class="line">1715</span><br><span class="line">1716</span><br><span class="line">1717</span><br><span class="line">1718</span><br><span class="line">1719</span><br><span class="line">1720</span><br><span class="line">1721</span><br><span class="line">1722</span><br><span class="line">1723</span><br><span class="line">1724</span><br><span class="line">1725</span><br><span class="line">1726</span><br><span class="line">1727</span><br><span class="line">1728</span><br><span class="line">1729</span><br><span class="line">1730</span><br><span class="line">1731</span><br><span class="line">1732</span><br><span class="line">1733</span><br><span class="line">1734</span><br><span class="line">1735</span><br><span class="line">1736</span><br><span class="line">1737</span><br><span class="line">1738</span><br><span class="line">1739</span><br><span class="line">1740</span><br><span class="line">1741</span><br><span class="line">1742</span><br><span class="line">1743</span><br><span class="line">1744</span><br><span class="line">1745</span><br><span class="line">1746</span><br><span class="line">1747</span><br><span class="line">1748</span><br><span class="line">1749</span><br><span class="line">1750</span><br><span class="line">1751</span><br><span class="line">1752</span><br><span class="line">1753</span><br><span class="line">1754</span><br><span class="line">1755</span><br><span class="line">1756</span><br><span class="line">1757</span><br><span class="line">1758</span><br><span class="line">1759</span><br><span class="line">1760</span><br><span class="line">1761</span><br><span class="line">1762</span><br><span class="line">1763</span><br><span class="line">1764</span><br><span class="line">1765</span><br><span class="line">1766</span><br><span class="line">1767</span><br><span class="line">1768</span><br><span class="line">1769</span><br><span class="line">1770</span><br><span class="line">1771</span><br><span class="line">1772</span><br><span class="line">1773</span><br><span class="line">1774</span><br><span class="line">1775</span><br><span class="line">1776</span><br><span class="line">1777</span><br><span class="line">1778</span><br><span class="line">1779</span><br><span class="line">1780</span><br><span class="line">1781</span><br><span class="line">1782</span><br><span class="line">1783</span><br><span class="line">1784</span><br><span class="line">1785</span><br><span class="line">1786</span><br><span class="line">1787</span><br><span class="line">1788</span><br><span class="line">1789</span><br><span class="line">1790</span><br><span class="line">1791</span><br><span class="line">1792</span><br><span class="line">1793</span><br><span class="line">1794</span><br><span class="line">1795</span><br><span class="line">1796</span><br><span class="line">1797</span><br><span class="line">1798</span><br><span class="line">1799</span><br><span class="line">1800</span><br><span class="line">1801</span><br><span class="line">1802</span><br><span class="line">1803</span><br><span class="line">1804</span><br><span class="line">1805</span><br><span class="line">1806</span><br><span class="line">1807</span><br><span class="line">1808</span><br><span class="line">1809</span><br><span class="line">1810</span><br><span class="line">1811</span><br><span class="line">1812</span><br><span class="line">1813</span><br><span class="line">1814</span><br><span class="line">1815</span><br><span class="line">1816</span><br><span class="line">1817</span><br><span class="line">1818</span><br><span class="line">1819</span><br><span class="line">1820</span><br><span class="line">1821</span><br><span class="line">1822</span><br><span class="line">1823</span><br><span class="line">1824</span><br><span class="line">1825</span><br><span class="line">1826</span><br><span class="line">1827</span><br><span class="line">1828</span><br><span class="line">1829</span><br><span class="line">1830</span><br><span class="line">1831</span><br><span class="line">1832</span><br><span class="line">1833</span><br><span class="line">1834</span><br><span class="line">1835</span><br><span class="line">1836</span><br><span class="line">1837</span><br><span class="line">1838</span><br><span class="line">1839</span><br><span class="line">1840</span><br><span class="line">1841</span><br><span class="line">1842</span><br><span class="line">1843</span><br><span class="line">1844</span><br><span class="line">1845</span><br><span class="line">1846</span><br><span class="line">1847</span><br><span class="line">1848</span><br><span class="line">1849</span><br><span class="line">1850</span><br><span class="line">1851</span><br><span class="line">1852</span><br><span class="line">1853</span><br><span class="line">1854</span><br><span class="line">1855</span><br><span class="line">1856</span><br><span class="line">1857</span><br><span class="line">1858</span><br><span class="line">1859</span><br><span class="line">1860</span><br><span class="line">1861</span><br><span class="line">1862</span><br><span class="line">1863</span><br><span class="line">1864</span><br><span class="line">1865</span><br><span class="line">1866</span><br><span class="line">1867</span><br><span class="line">1868</span><br><span class="line">1869</span><br><span class="line">1870</span><br><span class="line">1871</span><br><span class="line">1872</span><br><span class="line">1873</span><br><span class="line">1874</span><br><span class="line">1875</span><br><span class="line">1876</span><br><span class="line">1877</span><br><span class="line">1878</span><br><span class="line">1879</span><br><span class="line">1880</span><br><span class="line">1881</span><br><span class="line">1882</span><br><span class="line">1883</span><br><span class="line">1884</span><br><span class="line">1885</span><br><span class="line">1886</span><br><span class="line">1887</span><br><span class="line">1888</span><br><span class="line">1889</span><br><span class="line">1890</span><br><span class="line">1891</span><br><span class="line">1892</span><br><span class="line">1893</span><br><span class="line">1894</span><br><span class="line">1895</span><br><span class="line">1896</span><br><span class="line">1897</span><br><span class="line">1898</span><br><span class="line">1899</span><br><span class="line">1900</span><br><span class="line">1901</span><br><span class="line">1902</span><br><span class="line">1903</span><br><span class="line">1904</span><br><span class="line">1905</span><br><span class="line">1906</span><br><span class="line">1907</span><br><span class="line">1908</span><br><span class="line">1909</span><br><span class="line">1910</span><br><span class="line">1911</span><br><span class="line">1912</span><br><span class="line">1913</span><br><span class="line">1914</span><br><span class="line">1915</span><br><span class="line">1916</span><br><span class="line">1917</span><br><span class="line">1918</span><br><span class="line">1919</span><br><span class="line">1920</span><br><span class="line">1921</span><br><span class="line">1922</span><br><span class="line">1923</span><br><span class="line">1924</span><br><span class="line">1925</span><br><span class="line">1926</span><br><span class="line">1927</span><br><span class="line">1928</span><br><span class="line">1929</span><br><span class="line">1930</span><br><span class="line">1931</span><br><span class="line">1932</span><br><span class="line">1933</span><br><span class="line">1934</span><br><span class="line">1935</span><br><span class="line">1936</span><br><span class="line">1937</span><br><span class="line">1938</span><br><span class="line">1939</span><br><span class="line">1940</span><br><span class="line">1941</span><br><span class="line">1942</span><br><span class="line">1943</span><br><span class="line">1944</span><br><span class="line">1945</span><br><span class="line">1946</span><br><span class="line">1947</span><br><span class="line">1948</span><br><span class="line">1949</span><br><span class="line">1950</span><br><span class="line">1951</span><br><span class="line">1952</span><br><span class="line">1953</span><br><span class="line">1954</span><br><span class="line">1955</span><br><span class="line">1956</span><br><span class="line">1957</span><br><span class="line">1958</span><br><span class="line">1959</span><br><span class="line">1960</span><br><span class="line">1961</span><br><span class="line">1962</span><br><span class="line">1963</span><br><span class="line">1964</span><br><span class="line">1965</span><br><span class="line">1966</span><br><span class="line">1967</span><br><span class="line">1968</span><br><span class="line">1969</span><br><span class="line">1970</span><br><span class="line">1971</span><br><span class="line">1972</span><br><span class="line">1973</span><br><span class="line">1974</span><br><span class="line">1975</span><br><span class="line">1976</span><br><span class="line">1977</span><br><span class="line">1978</span><br><span class="line">1979</span><br><span class="line">1980</span><br><span class="line">1981</span><br><span class="line">1982</span><br><span class="line">1983</span><br><span class="line">1984</span><br><span class="line">1985</span><br><span class="line">1986</span><br><span class="line">1987</span><br><span class="line">1988</span><br><span class="line">1989</span><br><span class="line">1990</span><br><span class="line">1991</span><br><span class="line">1992</span><br><span class="line">1993</span><br><span class="line">1994</span><br><span class="line">1995</span><br><span class="line">1996</span><br><span class="line">1997</span><br><span class="line">1998</span><br><span class="line">1999</span><br><span class="line">2000</span><br><span class="line">2001</span><br><span class="line">2002</span><br><span class="line">2003</span><br><span class="line">2004</span><br><span class="line">2005</span><br><span class="line">2006</span><br><span class="line">2007</span><br><span class="line">2008</span><br><span class="line">2009</span><br><span class="line">2010</span><br><span class="line">2011</span><br><span class="line">2012</span><br><span class="line">2013</span><br><span class="line">2014</span><br><span class="line">2015</span><br><span class="line">2016</span><br><span class="line">2017</span><br><span class="line">2018</span><br><span class="line">2019</span><br><span class="line">2020</span><br><span class="line">2021</span><br><span class="line">2022</span><br><span class="line">2023</span><br><span class="line">2024</span><br><span class="line">2025</span><br><span class="line">2026</span><br><span class="line">2027</span><br><span class="line">2028</span><br><span class="line">2029</span><br><span class="line">2030</span><br><span class="line">2031</span><br><span class="line">2032</span><br><span class="line">2033</span><br><span class="line">2034</span><br><span class="line">2035</span><br><span class="line">2036</span><br><span class="line">2037</span><br><span class="line">2038</span><br><span class="line">2039</span><br><span class="line">2040</span><br><span class="line">2041</span><br><span class="line">2042</span><br><span class="line">2043</span><br><span class="line">2044</span><br><span class="line">2045</span><br><span class="line">2046</span><br><span class="line">2047</span><br><span class="line">2048</span><br><span class="line">2049</span><br><span class="line">2050</span><br><span class="line">2051</span><br><span class="line">2052</span><br><span class="line">2053</span><br><span class="line">2054</span><br><span class="line">2055</span><br><span class="line">2056</span><br><span class="line">2057</span><br><span class="line">2058</span><br><span class="line">2059</span><br><span class="line">2060</span><br><span class="line">2061</span><br><span class="line">2062</span><br><span class="line">2063</span><br><span class="line">2064</span><br><span class="line">2065</span><br><span class="line">2066</span><br><span class="line">2067</span><br><span class="line">2068</span><br><span class="line">2069</span><br><span class="line">2070</span><br><span class="line">2071</span><br><span class="line">2072</span><br><span class="line">2073</span><br><span class="line">2074</span><br><span class="line">2075</span><br><span class="line">2076</span><br><span class="line">2077</span><br><span class="line">2078</span><br><span class="line">2079</span><br><span class="line">2080</span><br><span class="line">2081</span><br><span class="line">2082</span><br><span class="line">2083</span><br><span class="line">2084</span><br><span class="line">2085</span><br><span class="line">2086</span><br><span class="line">2087</span><br><span class="line">2088</span><br><span class="line">2089</span><br><span class="line">2090</span><br><span class="line">2091</span><br><span class="line">2092</span><br><span class="line">2093</span><br><span class="line">2094</span><br><span class="line">2095</span><br><span class="line">2096</span><br><span class="line">2097</span><br><span class="line">2098</span><br><span class="line">2099</span><br><span class="line">2100</span><br><span class="line">2101</span><br><span class="line">2102</span><br><span class="line">2103</span><br><span class="line">2104</span><br><span class="line">2105</span><br><span class="line">2106</span><br><span class="line">2107</span><br><span class="line">2108</span><br><span class="line">2109</span><br><span class="line">2110</span><br><span class="line">2111</span><br><span class="line">2112</span><br><span class="line">2113</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractQueuedSynchronizer</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractOwnableSynchronizer</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">7373984972572414691L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new &#123;<span class="doctag">@code</span> AbstractQueuedSynchronizer&#125; instance</span></span><br><span class="line"><span class="comment">     * with initial synchronization state of zero.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">AbstractQueuedSynchronizer</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Wait queue node class.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;The wait queue is a variant of a &quot;CLH&quot; (Craig, Landin, and</span></span><br><span class="line"><span class="comment">     * Hagersten) lock queue. CLH locks are normally used for</span></span><br><span class="line"><span class="comment">     * spinlocks.  We instead use them for blocking synchronizers, but</span></span><br><span class="line"><span class="comment">     * use the same basic tactic of holding some of the control</span></span><br><span class="line"><span class="comment">     * information about a thread in the predecessor of its node.  A</span></span><br><span class="line"><span class="comment">     * &quot;status&quot; field in each node keeps track of whether a thread</span></span><br><span class="line"><span class="comment">     * should block.  A node is signalled when its predecessor</span></span><br><span class="line"><span class="comment">     * releases.  Each node of the queue otherwise serves as a</span></span><br><span class="line"><span class="comment">     * specific-notification-style monitor holding a single waiting</span></span><br><span class="line"><span class="comment">     * thread. The status field does NOT control whether threads are</span></span><br><span class="line"><span class="comment">     * granted locks etc though.  A thread may try to acquire if it is</span></span><br><span class="line"><span class="comment">     * first in the queue. But being first does not guarantee success;</span></span><br><span class="line"><span class="comment">     * it only gives the right to contend.  So the currently released</span></span><br><span class="line"><span class="comment">     * contender thread may need to rewait.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;To enqueue into a CLH lock, you atomically splice it in as new</span></span><br><span class="line"><span class="comment">     * tail. To dequeue, you just set the head field.</span></span><br><span class="line"><span class="comment">     * &lt;pre&gt;</span></span><br><span class="line"><span class="comment">     *      +------+  prev +-----+       +-----+</span></span><br><span class="line"><span class="comment">     * head |      | &lt;---- |     | &lt;---- |     |  tail</span></span><br><span class="line"><span class="comment">     *      +------+       +-----+       +-----+</span></span><br><span class="line"><span class="comment">     * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Insertion into a CLH queue requires only a single atomic</span></span><br><span class="line"><span class="comment">     * operation on &quot;tail&quot;, so there is a simple atomic point of</span></span><br><span class="line"><span class="comment">     * demarcation from unqueued to queued. Similarly, dequeuing</span></span><br><span class="line"><span class="comment">     * involves only updating the &quot;head&quot;. However, it takes a bit</span></span><br><span class="line"><span class="comment">     * more work for nodes to determine who their successors are,</span></span><br><span class="line"><span class="comment">     * in part to deal with possible cancellation due to timeouts</span></span><br><span class="line"><span class="comment">     * and interrupts.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;The &quot;prev&quot; links (not used in original CLH locks), are mainly</span></span><br><span class="line"><span class="comment">     * needed to handle cancellation. If a node is cancelled, its</span></span><br><span class="line"><span class="comment">     * successor is (normally) relinked to a non-cancelled</span></span><br><span class="line"><span class="comment">     * predecessor. For explanation of similar mechanics in the case</span></span><br><span class="line"><span class="comment">     * of spin locks, see the papers by Scott and Scherer at</span></span><br><span class="line"><span class="comment">     * http://www.cs.rochester.edu/u/scott/synchronization/</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;We also use &quot;next&quot; links to implement blocking mechanics.</span></span><br><span class="line"><span class="comment">     * The thread id for each node is kept in its own node, so a</span></span><br><span class="line"><span class="comment">     * predecessor signals the next node to wake up by traversing</span></span><br><span class="line"><span class="comment">     * next link to determine which thread it is.  Determination of</span></span><br><span class="line"><span class="comment">     * successor must avoid races with newly queued nodes to set</span></span><br><span class="line"><span class="comment">     * the &quot;next&quot; fields of their predecessors.  This is solved</span></span><br><span class="line"><span class="comment">     * when necessary by checking backwards from the atomically</span></span><br><span class="line"><span class="comment">     * updated &quot;tail&quot; when a node&#x27;s successor appears to be null.</span></span><br><span class="line"><span class="comment">     * (Or, said differently, the next-links are an optimization</span></span><br><span class="line"><span class="comment">     * so that we don&#x27;t usually need a backward scan.)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Cancellation introduces some conservatism to the basic</span></span><br><span class="line"><span class="comment">     * algorithms.  Since we must poll for cancellation of other</span></span><br><span class="line"><span class="comment">     * nodes, we can miss noticing whether a cancelled node is</span></span><br><span class="line"><span class="comment">     * ahead or behind us. This is dealt with by always unparking</span></span><br><span class="line"><span class="comment">     * successors upon cancellation, allowing them to stabilize on</span></span><br><span class="line"><span class="comment">     * a new predecessor, unless we can identify an uncancelled</span></span><br><span class="line"><span class="comment">     * predecessor who will carry this responsibility.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;CLH queues need a dummy header node to get started. But</span></span><br><span class="line"><span class="comment">     * we don&#x27;t create them on construction, because it would be wasted</span></span><br><span class="line"><span class="comment">     * effort if there is never contention. Instead, the node</span></span><br><span class="line"><span class="comment">     * is constructed and head and tail pointers are set upon first</span></span><br><span class="line"><span class="comment">     * contention.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Threads waiting on Conditions use the same nodes, but</span></span><br><span class="line"><span class="comment">     * use an additional link. Conditions only need to link nodes</span></span><br><span class="line"><span class="comment">     * in simple (non-concurrent) linked queues because they are</span></span><br><span class="line"><span class="comment">     * only accessed when exclusively held.  Upon await, a node is</span></span><br><span class="line"><span class="comment">     * inserted into a condition queue.  Upon signal, the node is</span></span><br><span class="line"><span class="comment">     * transferred to the main queue.  A special value of status</span></span><br><span class="line"><span class="comment">     * field is used to mark which queue a node is on.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Thanks go to Dave Dice, Mark Moir, Victor Luchangco, Bill</span></span><br><span class="line"><span class="comment">     * Scherer and Michael Scott, along with members of JSR-166</span></span><br><span class="line"><span class="comment">     * expert group, for helpful ideas, discussions, and critiques</span></span><br><span class="line"><span class="comment">     * on the design of this class.</span></span><br><span class="line"><span class="comment">     * CLH同步等待队列实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="comment">/** Marker to indicate a node is waiting in shared mode </span></span><br><span class="line"><span class="comment">        * 共享模式</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</span><br><span class="line">        <span class="comment">/** Marker to indicate a node is waiting in exclusive mode </span></span><br><span class="line"><span class="comment">        * 排他模式</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** waitStatus value to indicate thread has cancelled </span></span><br><span class="line"><span class="comment">        * 取消状态是&gt;0，其他都是小于0，默认状态是0</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</span><br><span class="line">        <span class="comment">/** waitStatus value to indicate successor&#x27;s thread needs unparking </span></span><br><span class="line"><span class="comment">        * 等待被唤醒</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">/** waitStatus value to indicate thread is waiting on condition </span></span><br><span class="line"><span class="comment">        * 条件等待状态</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * waitStatus value to indicate the next acquireShared should</span></span><br><span class="line"><span class="comment">         * unconditionally propagate</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Status field, taking on only the values:</span></span><br><span class="line"><span class="comment">         *   SIGNAL:     The successor of this node is (or will soon be)</span></span><br><span class="line"><span class="comment">         *               blocked (via park), so the current node must</span></span><br><span class="line"><span class="comment">         *               unpark its successor when it releases or</span></span><br><span class="line"><span class="comment">         *               cancels. To avoid races, acquire methods must</span></span><br><span class="line"><span class="comment">         *               first indicate they need a signal,</span></span><br><span class="line"><span class="comment">         *               then retry the atomic acquire, and then,</span></span><br><span class="line"><span class="comment">         *               on failure, block.</span></span><br><span class="line"><span class="comment">         *   CANCELLED:  This node is cancelled due to timeout or interrupt.</span></span><br><span class="line"><span class="comment">         *               Nodes never leave this state. In particular,</span></span><br><span class="line"><span class="comment">         *               a thread with cancelled node never again blocks.</span></span><br><span class="line"><span class="comment">         *   CONDITION:  This node is currently on a condition queue.</span></span><br><span class="line"><span class="comment">         *               It will not be used as a sync queue node</span></span><br><span class="line"><span class="comment">         *               until transferred, at which time the status</span></span><br><span class="line"><span class="comment">         *               will be set to 0. (Use of this value here has</span></span><br><span class="line"><span class="comment">         *               nothing to do with the other uses of the</span></span><br><span class="line"><span class="comment">         *               field, but simplifies mechanics.)</span></span><br><span class="line"><span class="comment">         *   PROPAGATE:  A releaseShared should be propagated to other</span></span><br><span class="line"><span class="comment">         *               nodes. This is set (for head node only) in</span></span><br><span class="line"><span class="comment">         *               doReleaseShared to ensure propagation</span></span><br><span class="line"><span class="comment">         *               continues, even if other operations have</span></span><br><span class="line"><span class="comment">         *               since intervened.</span></span><br><span class="line"><span class="comment">         *   0:          None of the above</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * The values are arranged numerically to simplify use.</span></span><br><span class="line"><span class="comment">         * Non-negative values mean that a node doesn&#x27;t need to</span></span><br><span class="line"><span class="comment">         * signal. So, most code doesn&#x27;t need to check for particular</span></span><br><span class="line"><span class="comment">         * values, just for sign.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * The field is initialized to 0 for normal sync nodes, and</span></span><br><span class="line"><span class="comment">         * CONDITION for condition nodes.  It is modified using CAS</span></span><br><span class="line"><span class="comment">         * (or when possible, unconditional volatile writes).</span></span><br><span class="line"><span class="comment">         * 节点状态</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Link to predecessor node that current node/thread relies on</span></span><br><span class="line"><span class="comment">         * for checking waitStatus. Assigned during enqueuing, and nulled</span></span><br><span class="line"><span class="comment">         * out (for sake of GC) only upon dequeuing.  Also, upon</span></span><br><span class="line"><span class="comment">         * cancellation of a predecessor, we short-circuit while</span></span><br><span class="line"><span class="comment">         * finding a non-cancelled one, which will always exist</span></span><br><span class="line"><span class="comment">         * because the head node is never cancelled: A node becomes</span></span><br><span class="line"><span class="comment">         * head only as a result of successful acquire. A</span></span><br><span class="line"><span class="comment">         * cancelled thread never succeeds in acquiring, and a thread only</span></span><br><span class="line"><span class="comment">         * cancels itself, not any other node.</span></span><br><span class="line"><span class="comment">         * 前置节点</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">volatile</span> Node prev;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Link to the successor node that the current node/thread</span></span><br><span class="line"><span class="comment">         * unparks upon release. Assigned during enqueuing, adjusted</span></span><br><span class="line"><span class="comment">         * when bypassing cancelled predecessors, and nulled out (for</span></span><br><span class="line"><span class="comment">         * sake of GC) when dequeued.  The enq operation does not</span></span><br><span class="line"><span class="comment">         * assign next field of a predecessor until after attachment,</span></span><br><span class="line"><span class="comment">         * so seeing a null next field does not necessarily mean that</span></span><br><span class="line"><span class="comment">         * node is at end of queue. However, if a next field appears</span></span><br><span class="line"><span class="comment">         * to be null, we can scan prev&#x27;s from the tail to</span></span><br><span class="line"><span class="comment">         * double-check.  The next field of cancelled nodes is set to</span></span><br><span class="line"><span class="comment">         * point to the node itself instead of null, to make life</span></span><br><span class="line"><span class="comment">         * easier for isOnSyncQueue.</span></span><br><span class="line"><span class="comment">         * 后置节点</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">volatile</span> Node next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * The thread that enqueued this node.  Initialized on</span></span><br><span class="line"><span class="comment">         * construction and nulled out after use.</span></span><br><span class="line"><span class="comment">         * 当前节点存储的内容，当前线程，拿出来阻塞&amp;唤醒</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">volatile</span> Thread thread;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Link to next node waiting on condition, or the special</span></span><br><span class="line"><span class="comment">         * value SHARED.  Because condition queues are accessed only</span></span><br><span class="line"><span class="comment">         * when holding in exclusive mode, we just need a simple</span></span><br><span class="line"><span class="comment">         * linked queue to hold nodes while they are waiting on</span></span><br><span class="line"><span class="comment">         * conditions. They are then transferred to the queue to</span></span><br><span class="line"><span class="comment">         * re-acquire. And because conditions can only be exclusive,</span></span><br><span class="line"><span class="comment">         * we save a field by using special value to indicate shared</span></span><br><span class="line"><span class="comment">         * mode.</span></span><br><span class="line"><span class="comment">         * 条件队列下一个节点</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Node nextWaiter;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Returns true if node is waiting in shared mode.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> nextWaiter == SHARED;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Returns previous node, or throws NullPointerException if null.</span></span><br><span class="line"><span class="comment">         * Use when predecessor cannot be null.  The null check could</span></span><br><span class="line"><span class="comment">         * be elided, but is present to help the VM.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> the predecessor of this node</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> Node <span class="title">predecessor</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException </span>&#123;</span><br><span class="line">            Node p = prev;</span><br><span class="line">            <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node() &#123;    <span class="comment">// Used to establish initial head or SHARED marker</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node(Thread thread, Node mode) &#123;     <span class="comment">// Used by addWaiter</span></span><br><span class="line">            <span class="keyword">this</span>.nextWaiter = mode;</span><br><span class="line">            <span class="keyword">this</span>.thread = thread;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node(Thread thread, <span class="keyword">int</span> waitStatus) &#123; <span class="comment">// Used by Condition</span></span><br><span class="line">            <span class="keyword">this</span>.waitStatus = waitStatus;</span><br><span class="line">            <span class="keyword">this</span>.thread = thread;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Head of the wait queue, lazily initialized.  Except for</span></span><br><span class="line"><span class="comment">     * initialization, it is modified only via method setHead.  Note:</span></span><br><span class="line"><span class="comment">     * If head exists, its waitStatus is guaranteed not to be</span></span><br><span class="line"><span class="comment">     * CANCELLED.</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 头节点</span></span><br><span class="line"><span class="comment">     * transient表示反序列化被透明，其他没什么不同</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Tail of the wait queue, lazily initialized.  Modified only via</span></span><br><span class="line"><span class="comment">     * method enq to add new wait node.</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 尾结点</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The synchronization state.</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 这个字段非常重要，就是多个线程来争抢是否有资源可用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the current value of synchronization state.</span></span><br><span class="line"><span class="comment">     * This operation has memory semantics of a &#123;<span class="doctag">@code</span> volatile&#125; read.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> current state value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sets the value of synchronization state.</span></span><br><span class="line"><span class="comment">     * This operation has memory semantics of a &#123;<span class="doctag">@code</span> volatile&#125; write.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> newState the new state value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> newState)</span> </span>&#123;</span><br><span class="line">        state = newState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Atomically sets synchronization state to the given updated</span></span><br><span class="line"><span class="comment">     * value if the current state value equals the expected value.</span></span><br><span class="line"><span class="comment">     * This operation has memory semantics of a &#123;<span class="doctag">@code</span> volatile&#125; read</span></span><br><span class="line"><span class="comment">     * and write.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> expect the expected value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> update the new value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if successful. False return indicates that the actual</span></span><br><span class="line"><span class="comment">     *         value was not equal to the expected value.</span></span><br><span class="line"><span class="comment">     * cas操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// See below for intrinsics setup to support this</span></span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, expect, update);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Queuing utilities</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The number of nanoseconds for which it is faster to spin</span></span><br><span class="line"><span class="comment">     * rather than to use timed park. A rough estimate suffices</span></span><br><span class="line"><span class="comment">     * to improve responsiveness with very short timeouts.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> spinForTimeoutThreshold = <span class="number">1000L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Inserts node into queue, initializing if necessary. See picture above.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node the node to insert</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> node&#x27;s predecessor</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 入队，如果队列为空的话，创建一个空的头节点，然后把节点加入到头的后面，通过cas操作</span></span><br><span class="line"><span class="comment">     * 通过自旋的操作必须入队成功，添加成尾节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            Node t = tail;</span><br><span class="line">            <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                    tail = head;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                node.prev = t;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                    t.next = node;</span><br><span class="line">                    <span class="keyword">return</span> t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates and enqueues node for current thread and given mode.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mode Node.EXCLUSIVE for exclusive, Node.SHARED for shared</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the new node</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 入队，如果队列不为空，直接插入到队列后面</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">        Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">        <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">        Node pred = tail;</span><br><span class="line">        <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">            node.prev = pred;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">                pred.next = node;</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        enq(node);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sets head of queue to be node, thus dequeuing. Called only by</span></span><br><span class="line"><span class="comment">     * acquire methods.  Also nulls out unused fields for sake of GC</span></span><br><span class="line"><span class="comment">     * and to suppress unnecessary signals and traversals.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node the node</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 设置head，这里需要注意下，其中thread为null，prev节点</span></span><br><span class="line"><span class="comment">     * 这里的head节点是实际不存数据的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHead</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        head = node;</span><br><span class="line">        node.thread = <span class="keyword">null</span>;</span><br><span class="line">        node.prev = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Wakes up node&#x27;s successor, if one exists.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node the node</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 这是阻塞队列中唤醒操作，这里操作分为两个步骤</span></span><br><span class="line"><span class="comment">     * 1. 默认进来就是-1，这里可以看下获取锁阶段没拿到锁的时候会将state设置成-1</span></span><br><span class="line"><span class="comment">     * 2. 进来的时候会将当前节点head状态设置成0，可以是尝试去拿锁</span></span><br><span class="line"><span class="comment">     * 3. 然后取当前节点后的第一个节点的线程唤醒，node是head节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * If status is negative (i.e., possibly needing signal) try</span></span><br><span class="line"><span class="comment">         * to clear in anticipation of signalling.  It is OK if this</span></span><br><span class="line"><span class="comment">         * fails or if status is changed by waiting thread.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">        <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">            compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Thread to unpark is held in successor, which is normally</span></span><br><span class="line"><span class="comment">         * just the next node.  But if cancelled or apparently null,</span></span><br><span class="line"><span class="comment">         * traverse backwards from tail to find the actual</span></span><br><span class="line"><span class="comment">         * non-cancelled successor.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Node s = node.next;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            s = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">                <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                    s = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">            LockSupport.unpark(s.thread);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Release action for shared mode -- signals successor and ensures</span></span><br><span class="line"><span class="comment">     * propagation. (Note: For exclusive mode, release just amounts</span></span><br><span class="line"><span class="comment">     * to calling unparkSuccessor of head if it needs signal.)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Ensure that a release propagates, even if there are other</span></span><br><span class="line"><span class="comment">         * in-progress acquires/releases.  This proceeds in the usual</span></span><br><span class="line"><span class="comment">         * way of trying to unparkSuccessor of head if it needs</span></span><br><span class="line"><span class="comment">         * signal. But if it does not, status is set to PROPAGATE to</span></span><br><span class="line"><span class="comment">         * ensure that upon release, propagation continues.</span></span><br><span class="line"><span class="comment">         * Additionally, we must loop in case a new node is added</span></span><br><span class="line"><span class="comment">         * while we are doing this. Also, unlike other uses of</span></span><br><span class="line"><span class="comment">         * unparkSuccessor, we need to know if CAS to reset status</span></span><br><span class="line"><span class="comment">         * fails, if so rechecking.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            Node h = head;</span><br><span class="line">            <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">                <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">                <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                        <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                    unparkSuccessor(h);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                         !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                    <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sets head of queue, and checks if successor may be waiting</span></span><br><span class="line"><span class="comment">     * in shared mode, if so propagating if either propagate &gt; 0 or</span></span><br><span class="line"><span class="comment">     * PROPAGATE status was set.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node the node</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> propagate the return value from a tryAcquireShared</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHeadAndPropagate</span><span class="params">(Node node, <span class="keyword">int</span> propagate)</span> </span>&#123;</span><br><span class="line">        Node h = head; <span class="comment">// Record old head for check below</span></span><br><span class="line">        setHead(node);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Try to signal next queued node if:</span></span><br><span class="line"><span class="comment">         *   Propagation was indicated by caller,</span></span><br><span class="line"><span class="comment">         *     or was recorded (as h.waitStatus either before</span></span><br><span class="line"><span class="comment">         *     or after setHead) by a previous operation</span></span><br><span class="line"><span class="comment">         *     (note: this uses sign-check of waitStatus because</span></span><br><span class="line"><span class="comment">         *      PROPAGATE status may transition to SIGNAL.)</span></span><br><span class="line"><span class="comment">         * and</span></span><br><span class="line"><span class="comment">         *   The next node is waiting in shared mode,</span></span><br><span class="line"><span class="comment">         *     or we don&#x27;t know, because it appears null</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * The conservatism in both of these checks may cause</span></span><br><span class="line"><span class="comment">         * unnecessary wake-ups, but only when there are multiple</span></span><br><span class="line"><span class="comment">         * racing acquires/releases, so most need signals now or soon</span></span><br><span class="line"><span class="comment">         * anyway.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span> ||</span><br><span class="line">            (h = head) == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            Node s = node.next;</span><br><span class="line">            <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.isShared())</span><br><span class="line">                doReleaseShared();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Utilities for various versions of acquire</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Cancels an ongoing attempt to acquire.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node the node</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 取消获取锁，中断，把当前节点踢出掉队列</span></span><br><span class="line"><span class="comment">     * 1. 设置thread为空</span></span><br><span class="line"><span class="comment">     * 2. 找到它之前的节点，如果他之前的节点也是取消节点，那就是把当前节点连续的取消节点踢出队列中</span></span><br><span class="line"><span class="comment">     * 3. 接下来的操作就是将连续取消节点的prev节点指向连续取消节点的next节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cancelAcquire</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Ignore if node doesn&#x27;t exist</span></span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        node.thread = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Skip cancelled predecessors</span></span><br><span class="line">        Node pred = node.prev;</span><br><span class="line">        <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>)</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// predNext is the apparent node to unsplice. CASes below will</span></span><br><span class="line">        <span class="comment">// fail if not, in which case, we lost race vs another cancel</span></span><br><span class="line">        <span class="comment">// or signal, so no further action is necessary.</span></span><br><span class="line">        Node predNext = pred.next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Can use unconditional write instead of CAS here.</span></span><br><span class="line">        <span class="comment">// After this atomic step, other Nodes can skip past us.</span></span><br><span class="line">        <span class="comment">// Before, we are free of interference from other threads.</span></span><br><span class="line">        node.waitStatus = Node.CANCELLED;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If we are the tail, remove ourselves.</span></span><br><span class="line">        <span class="keyword">if</span> (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123;</span><br><span class="line">            compareAndSetNext(pred, predNext, <span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// If successor needs signal, try to set pred&#x27;s next-link</span></span><br><span class="line">            <span class="comment">// so it will get one. Otherwise wake it up to propagate.</span></span><br><span class="line">            <span class="keyword">int</span> ws;</span><br><span class="line">            <span class="keyword">if</span> (pred != head &amp;&amp;</span><br><span class="line">                ((ws = pred.waitStatus) == Node.SIGNAL ||</span><br><span class="line">                 (ws &lt;= <span class="number">0</span> &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp;</span><br><span class="line">                pred.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Node next = node.next;</span><br><span class="line">                <span class="keyword">if</span> (next != <span class="keyword">null</span> &amp;&amp; next.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                    compareAndSetNext(pred, predNext, next);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                unparkSuccessor(node);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            node.next = node; <span class="comment">// help GC</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Checks and updates status for a node that failed to acquire.</span></span><br><span class="line"><span class="comment">     * Returns true if thread should block. This is the main signal</span></span><br><span class="line"><span class="comment">     * control in all acquire loops.  Requires that pred == node.prev.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pred node&#x27;s predecessor holding status</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node the node</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if thread should block</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 这里是表示尝试获取锁时没获取到锁，然后准备阻塞线程</span></span><br><span class="line"><span class="comment">     * 1. 当前进入的节点前置节点默认进来就是0</span></span><br><span class="line"><span class="comment">     * 2. 然后前置节点状态设置成-1</span></span><br><span class="line"><span class="comment">     * 3. 这里很奇怪，刚才我们看unlock 时调用unparkSuccessor又把状态设置成0</span></span><br><span class="line"><span class="comment">     * 4. 这里解释下，为什么状态从0-&gt;-1-&gt;0，这里为什么要这么设计？因为在公平锁的时候，这个时候一定会是head后的第一个获取到锁，这是没有问题的，</span></span><br><span class="line"><span class="comment"> 但是如果是非公平锁的时候，head后的第一个节点线程是有可能获取不到锁的，还需要阻塞，这个时候进来的状态还是0，就还是会变成0-&gt;-1-&gt;0，循环就能持续下去</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">        <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * This node has already set status asking a release</span></span><br><span class="line"><span class="comment">             * to signal it, so it can safely park.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Predecessor was cancelled. Skip over predecessors and</span></span><br><span class="line"><span class="comment">             * indicate retry.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                node.prev = pred = pred.prev;</span><br><span class="line">            &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">            pred.next = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * waitStatus must be 0 or PROPAGATE.  Indicate that we</span></span><br><span class="line"><span class="comment">             * need a signal, but don&#x27;t park yet.  Caller will need to</span></span><br><span class="line"><span class="comment">             * retry to make sure it cannot acquire before parking.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Convenience method to interrupt current thread.</span></span><br><span class="line"><span class="comment">     * 中断当前线程，中断就是给线程打上一个中断标识</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selfInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread.currentThread().interrupt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Convenience method to park and then check if interrupted</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if interrupted</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 阻塞当前线程</span></span><br><span class="line"><span class="comment">     * Thread.interrupted() 判断当前是否中断过</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Various flavors of acquire, varying in exclusive/shared and</span></span><br><span class="line"><span class="comment">     * control modes.  Each is mostly the same, but annoyingly</span></span><br><span class="line"><span class="comment">     * different.  Only a little bit of factoring is possible due to</span></span><br><span class="line"><span class="comment">     * interactions of exception mechanics (including ensuring that we</span></span><br><span class="line"><span class="comment">     * cancel if tryAcquire throws exception) and other control, at</span></span><br><span class="line"><span class="comment">     * least not without hurting performance too much.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Acquires in exclusive uninterruptible mode for thread already in</span></span><br><span class="line"><span class="comment">     * queue. Used by condition wait methods as well as acquire.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node the node</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arg the acquire argument</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if interrupted while waiting</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 1. 这里是获取锁失败后，然后进入队列</span></span><br><span class="line"><span class="comment">     * 2. 这里有个点，发现如果是当前节点的前置节点是head，还会尝试获取锁，有可能在阻塞之前，刚好这个时候之前获取锁的时候正好释放锁，就可以获取到锁</span></span><br><span class="line"><span class="comment">     * 3. 这里如果是ReentrantLock不会走到cancelAcquire这里，因为这里都是正常返回，要不然就是阻塞到这里，那failed=false</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span> interrupted;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    interrupted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Acquires in exclusive interruptible mode.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arg the acquire argument</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 这个相比较acquireQueued就可能会进入到cancelAcquire，一旦发生中断，抛出异常，抛出异常之前会走到finally，然后这个时候failed = true就会走到cancelAcquire</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Acquires in exclusive timed mode.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arg the acquire argument</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nanosTimeout max wait time</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if acquired</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">doAcquireNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> deadline = System.nanoTime() + nanosTimeout;</span><br><span class="line">        <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                nanosTimeout = deadline - System.nanoTime();</span><br><span class="line">                <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    nanosTimeout &gt; spinForTimeoutThreshold)</span><br><span class="line">                    LockSupport.parkNanos(<span class="keyword">this</span>, nanosTimeout);</span><br><span class="line">                <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Acquires in shared uninterruptible mode.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arg the acquire argument</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                    <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                    <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        setHeadAndPropagate(node, r);</span><br><span class="line">                        p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                        <span class="keyword">if</span> (interrupted)</span><br><span class="line">                            selfInterrupt();</span><br><span class="line">                        failed = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    interrupted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Acquires in shared interruptible mode.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arg the acquire argument</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                    <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                    <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        setHeadAndPropagate(node, r);</span><br><span class="line">                        p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                        failed = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Acquires in shared timed mode.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arg the acquire argument</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nanosTimeout max wait time</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if acquired</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">doAcquireSharedNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> deadline = System.nanoTime() + nanosTimeout;</span><br><span class="line">        <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                    <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                    <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        setHeadAndPropagate(node, r);</span><br><span class="line">                        p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                        failed = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                nanosTimeout = deadline - System.nanoTime();</span><br><span class="line">                <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    nanosTimeout &gt; spinForTimeoutThreshold)</span><br><span class="line">                    LockSupport.parkNanos(<span class="keyword">this</span>, nanosTimeout);</span><br><span class="line">                <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Main exported methods</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Attempts to acquire in exclusive mode. This method should query</span></span><br><span class="line"><span class="comment">     * if the state of the object permits it to be acquired in the</span></span><br><span class="line"><span class="comment">     * exclusive mode, and if so to acquire it.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;This method is always invoked by the thread performing</span></span><br><span class="line"><span class="comment">     * acquire.  If this method reports failure, the acquire method</span></span><br><span class="line"><span class="comment">     * may queue the thread, if it is not already queued, until it is</span></span><br><span class="line"><span class="comment">     * signalled by a release from some other thread. This can be used</span></span><br><span class="line"><span class="comment">     * to implement method &#123;<span class="doctag">@link</span> Lock#tryLock()&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;The default</span></span><br><span class="line"><span class="comment">     * implementation throws &#123;<span class="doctag">@link</span> UnsupportedOperationException&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arg the acquire argument. This value is always the one</span></span><br><span class="line"><span class="comment">     *        passed to an acquire method, or is the value saved on entry</span></span><br><span class="line"><span class="comment">     *        to a condition wait.  The value is otherwise uninterpreted</span></span><br><span class="line"><span class="comment">     *        and can represent anything you like.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if successful. Upon success, this object has</span></span><br><span class="line"><span class="comment">     *         been acquired.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalMonitorStateException if acquiring would place this</span></span><br><span class="line"><span class="comment">     *         synchronizer in an illegal state. This exception must be</span></span><br><span class="line"><span class="comment">     *         thrown in a consistent fashion for synchronization to work</span></span><br><span class="line"><span class="comment">     *         correctly.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> UnsupportedOperationException if exclusive mode is not supported</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * AQS实现独占模式获取锁，子类需要实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Attempts to set the state to reflect a release in exclusive</span></span><br><span class="line"><span class="comment">     * mode.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;This method is always invoked by the thread performing release.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;The default implementation throws</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> UnsupportedOperationException&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arg the release argument. This value is always the one</span></span><br><span class="line"><span class="comment">     *        passed to a release method, or the current state value upon</span></span><br><span class="line"><span class="comment">     *        entry to a condition wait.  The value is otherwise</span></span><br><span class="line"><span class="comment">     *        uninterpreted and can represent anything you like.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if this object is now in a fully released</span></span><br><span class="line"><span class="comment">     *         state, so that any waiting threads may attempt to acquire;</span></span><br><span class="line"><span class="comment">     *         and &#123;<span class="doctag">@code</span> false&#125; otherwise.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalMonitorStateException if releasing would place this</span></span><br><span class="line"><span class="comment">     *         synchronizer in an illegal state. This exception must be</span></span><br><span class="line"><span class="comment">     *         thrown in a consistent fashion for synchronization to work</span></span><br><span class="line"><span class="comment">     *         correctly.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> UnsupportedOperationException if exclusive mode is not supported</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * AQS独占模式下释放锁，子类需要实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Attempts to acquire in shared mode. This method should query if</span></span><br><span class="line"><span class="comment">     * the state of the object permits it to be acquired in the shared</span></span><br><span class="line"><span class="comment">     * mode, and if so to acquire it.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;This method is always invoked by the thread performing</span></span><br><span class="line"><span class="comment">     * acquire.  If this method reports failure, the acquire method</span></span><br><span class="line"><span class="comment">     * may queue the thread, if it is not already queued, until it is</span></span><br><span class="line"><span class="comment">     * signalled by a release from some other thread.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;The default implementation throws &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * UnsupportedOperationException&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arg the acquire argument. This value is always the one</span></span><br><span class="line"><span class="comment">     *        passed to an acquire method, or is the value saved on entry</span></span><br><span class="line"><span class="comment">     *        to a condition wait.  The value is otherwise uninterpreted</span></span><br><span class="line"><span class="comment">     *        and can represent anything you like.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a negative value on failure; zero if acquisition in shared</span></span><br><span class="line"><span class="comment">     *         mode succeeded but no subsequent shared-mode acquire can</span></span><br><span class="line"><span class="comment">     *         succeed; and a positive value if acquisition in shared</span></span><br><span class="line"><span class="comment">     *         mode succeeded and subsequent shared-mode acquires might</span></span><br><span class="line"><span class="comment">     *         also succeed, in which case a subsequent waiting thread</span></span><br><span class="line"><span class="comment">     *         must check availability. (Support for three different</span></span><br><span class="line"><span class="comment">     *         return values enables this method to be used in contexts</span></span><br><span class="line"><span class="comment">     *         where acquires only sometimes act exclusively.)  Upon</span></span><br><span class="line"><span class="comment">     *         success, this object has been acquired.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalMonitorStateException if acquiring would place this</span></span><br><span class="line"><span class="comment">     *         synchronizer in an illegal state. This exception must be</span></span><br><span class="line"><span class="comment">     *         thrown in a consistent fashion for synchronization to work</span></span><br><span class="line"><span class="comment">     *         correctly.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> UnsupportedOperationException if shared mode is not supported</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 共享模式下获取锁，子类需要实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Attempts to set the state to reflect a release in shared mode.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;This method is always invoked by the thread performing release.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;The default implementation throws</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> UnsupportedOperationException&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arg the release argument. This value is always the one</span></span><br><span class="line"><span class="comment">     *        passed to a release method, or the current state value upon</span></span><br><span class="line"><span class="comment">     *        entry to a condition wait.  The value is otherwise</span></span><br><span class="line"><span class="comment">     *        uninterpreted and can represent anything you like.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if this release of shared mode may permit a</span></span><br><span class="line"><span class="comment">     *         waiting acquire (shared or exclusive) to succeed; and</span></span><br><span class="line"><span class="comment">     *         &#123;<span class="doctag">@code</span> false&#125; otherwise</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalMonitorStateException if releasing would place this</span></span><br><span class="line"><span class="comment">     *         synchronizer in an illegal state. This exception must be</span></span><br><span class="line"><span class="comment">     *         thrown in a consistent fashion for synchronization to work</span></span><br><span class="line"><span class="comment">     *         correctly.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> UnsupportedOperationException if shared mode is not supported</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 共享模式下释放锁，子类需要实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns &#123;<span class="doctag">@code</span> true&#125; if synchronization is held exclusively with</span></span><br><span class="line"><span class="comment">     * respect to the current (calling) thread.  This method is invoked</span></span><br><span class="line"><span class="comment">     * upon each call to a non-waiting &#123;<span class="doctag">@link</span> ConditionObject&#125; method.</span></span><br><span class="line"><span class="comment">     * (Waiting methods instead invoke &#123;<span class="doctag">@link</span> #release&#125;.)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;The default implementation throws &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * UnsupportedOperationException&#125;. This method is invoked</span></span><br><span class="line"><span class="comment">     * internally only within &#123;<span class="doctag">@link</span> ConditionObject&#125; methods, so need</span></span><br><span class="line"><span class="comment">     * not be defined if conditions are not used.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if synchronization is held exclusively;</span></span><br><span class="line"><span class="comment">     *         &#123;<span class="doctag">@code</span> false&#125; otherwise</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> UnsupportedOperationException if conditions are not supported</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 该线程是否正在独占资源。只有用到Condition才需要去实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Acquires in exclusive mode, ignoring interrupts.  Implemented</span></span><br><span class="line"><span class="comment">     * by invoking at least once &#123;<span class="doctag">@link</span> #tryAcquire&#125;,</span></span><br><span class="line"><span class="comment">     * returning on success.  Otherwise the thread is queued, possibly</span></span><br><span class="line"><span class="comment">     * repeatedly blocking and unblocking, invoking &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * #tryAcquire&#125; until success.  This method can be used</span></span><br><span class="line"><span class="comment">     * to implement method &#123;<span class="doctag">@link</span> Lock#lock&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arg the acquire argument.  This value is conveyed to</span></span><br><span class="line"><span class="comment">     *        &#123;<span class="doctag">@link</span> #tryAcquire&#125; but is otherwise uninterpreted and</span></span><br><span class="line"><span class="comment">     *        can represent anything you like.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 获取锁的通用模式</span></span><br><span class="line"><span class="comment">     * 1. tryAcquire(arg) 尝试获取锁，获取锁成功后返回true，获取锁失败后返回false</span></span><br><span class="line"><span class="comment">     * 2. addWaiter(Node.EXCLUSIVE) 获取锁后加入到队列中</span></span><br><span class="line"><span class="comment">     * 3. acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) 这个加入队列后准备阻塞线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Acquires in exclusive mode, aborting if interrupted.</span></span><br><span class="line"><span class="comment">     * Implemented by first checking interrupt status, then invoking</span></span><br><span class="line"><span class="comment">     * at least once &#123;<span class="doctag">@link</span> #tryAcquire&#125;, returning on</span></span><br><span class="line"><span class="comment">     * success.  Otherwise the thread is queued, possibly repeatedly</span></span><br><span class="line"><span class="comment">     * blocking and unblocking, invoking &#123;<span class="doctag">@link</span> #tryAcquire&#125;</span></span><br><span class="line"><span class="comment">     * until success or the thread is interrupted.  This method can be</span></span><br><span class="line"><span class="comment">     * used to implement method &#123;<span class="doctag">@link</span> Lock#lockInterruptibly&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arg the acquire argument.  This value is conveyed to</span></span><br><span class="line"><span class="comment">     *        &#123;<span class="doctag">@link</span> #tryAcquire&#125; but is otherwise uninterpreted and</span></span><br><span class="line"><span class="comment">     *        can represent anything you like.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException if the current thread is interrupted</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg))</span><br><span class="line">            doAcquireInterruptibly(arg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Attempts to acquire in exclusive mode, aborting if interrupted,</span></span><br><span class="line"><span class="comment">     * and failing if the given timeout elapses.  Implemented by first</span></span><br><span class="line"><span class="comment">     * checking interrupt status, then invoking at least once &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * #tryAcquire&#125;, returning on success.  Otherwise, the thread is</span></span><br><span class="line"><span class="comment">     * queued, possibly repeatedly blocking and unblocking, invoking</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> #tryAcquire&#125; until success or the thread is interrupted</span></span><br><span class="line"><span class="comment">     * or the timeout elapses.  This method can be used to implement</span></span><br><span class="line"><span class="comment">     * method &#123;<span class="doctag">@link</span> Lock#tryLock(long, TimeUnit)&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arg the acquire argument.  This value is conveyed to</span></span><br><span class="line"><span class="comment">     *        &#123;<span class="doctag">@link</span> #tryAcquire&#125; but is otherwise uninterpreted and</span></span><br><span class="line"><span class="comment">     *        can represent anything you like.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nanosTimeout the maximum number of nanoseconds to wait</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if acquired; &#123;<span class="doctag">@code</span> false&#125; if timed out</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException if the current thread is interrupted</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquireNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        <span class="keyword">return</span> tryAcquire(arg) ||</span><br><span class="line">            doAcquireNanos(arg, nanosTimeout);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Releases in exclusive mode.  Implemented by unblocking one or</span></span><br><span class="line"><span class="comment">     * more threads if &#123;<span class="doctag">@link</span> #tryRelease&#125; returns true.</span></span><br><span class="line"><span class="comment">     * This method can be used to implement method &#123;<span class="doctag">@link</span> Lock#unlock&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arg the release argument.  This value is conveyed to</span></span><br><span class="line"><span class="comment">     *        &#123;<span class="doctag">@link</span> #tryRelease&#125; but is otherwise uninterpreted and</span></span><br><span class="line"><span class="comment">     *        can represent anything you like.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the value returned from &#123;<span class="doctag">@link</span> #tryRelease&#125;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 1. 释放锁的通用方法，当前线程用完了锁，一个是将其释放，然后唤醒下一个线程（排队或者正在获取锁的线程）</span></span><br><span class="line"><span class="comment">     * 2. tryRelease(arg) 设置状态state</span></span><br><span class="line"><span class="comment">     * 3. 在执行unparkSuccessor(h)之前，有个逻辑判断，这里获取的是head为-1，有排队的线程，否则是进不去的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">            Node h = head;</span><br><span class="line">            <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Acquires in shared mode, ignoring interrupts.  Implemented by</span></span><br><span class="line"><span class="comment">     * first invoking at least once &#123;<span class="doctag">@link</span> #tryAcquireShared&#125;,</span></span><br><span class="line"><span class="comment">     * returning on success.  Otherwise the thread is queued, possibly</span></span><br><span class="line"><span class="comment">     * repeatedly blocking and unblocking, invoking &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * #tryAcquireShared&#125; until success.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arg the acquire argument.  This value is conveyed to</span></span><br><span class="line"><span class="comment">     *        &#123;<span class="doctag">@link</span> #tryAcquireShared&#125; but is otherwise uninterpreted</span></span><br><span class="line"><span class="comment">     *        and can represent anything you like.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">            doAcquireShared(arg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Acquires in shared mode, aborting if interrupted.  Implemented</span></span><br><span class="line"><span class="comment">     * by first checking interrupt status, then invoking at least once</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> #tryAcquireShared&#125;, returning on success.  Otherwise the</span></span><br><span class="line"><span class="comment">     * thread is queued, possibly repeatedly blocking and unblocking,</span></span><br><span class="line"><span class="comment">     * invoking &#123;<span class="doctag">@link</span> #tryAcquireShared&#125; until success or the thread</span></span><br><span class="line"><span class="comment">     * is interrupted.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arg the acquire argument.</span></span><br><span class="line"><span class="comment">     * This value is conveyed to &#123;<span class="doctag">@link</span> #tryAcquireShared&#125; but is</span></span><br><span class="line"><span class="comment">     * otherwise uninterpreted and can represent anything</span></span><br><span class="line"><span class="comment">     * you like.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException if the current thread is interrupted</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">            doAcquireSharedInterruptibly(arg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Attempts to acquire in shared mode, aborting if interrupted, and</span></span><br><span class="line"><span class="comment">     * failing if the given timeout elapses.  Implemented by first</span></span><br><span class="line"><span class="comment">     * checking interrupt status, then invoking at least once &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * #tryAcquireShared&#125;, returning on success.  Otherwise, the</span></span><br><span class="line"><span class="comment">     * thread is queued, possibly repeatedly blocking and unblocking,</span></span><br><span class="line"><span class="comment">     * invoking &#123;<span class="doctag">@link</span> #tryAcquireShared&#125; until success or the thread</span></span><br><span class="line"><span class="comment">     * is interrupted or the timeout elapses.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arg the acquire argument.  This value is conveyed to</span></span><br><span class="line"><span class="comment">     *        &#123;<span class="doctag">@link</span> #tryAcquireShared&#125; but is otherwise uninterpreted</span></span><br><span class="line"><span class="comment">     *        and can represent anything you like.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nanosTimeout the maximum number of nanoseconds to wait</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if acquired; &#123;<span class="doctag">@code</span> false&#125; if timed out</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException if the current thread is interrupted</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquireSharedNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        <span class="keyword">return</span> tryAcquireShared(arg) &gt;= <span class="number">0</span> ||</span><br><span class="line">            doAcquireSharedNanos(arg, nanosTimeout);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Releases in shared mode.  Implemented by unblocking one or more</span></span><br><span class="line"><span class="comment">     * threads if &#123;<span class="doctag">@link</span> #tryReleaseShared&#125; returns true.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arg the release argument.  This value is conveyed to</span></span><br><span class="line"><span class="comment">     *        &#123;<span class="doctag">@link</span> #tryReleaseShared&#125; but is otherwise uninterpreted</span></span><br><span class="line"><span class="comment">     *        and can represent anything you like.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the value returned from &#123;<span class="doctag">@link</span> #tryReleaseShared&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">            doReleaseShared();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Queue inspection methods</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Queries whether any threads are waiting to acquire. Note that</span></span><br><span class="line"><span class="comment">     * because cancellations due to interrupts and timeouts may occur</span></span><br><span class="line"><span class="comment">     * at any time, a &#123;<span class="doctag">@code</span> true&#125; return does not guarantee that any</span></span><br><span class="line"><span class="comment">     * other thread will ever acquire.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;In this implementation, this operation returns in</span></span><br><span class="line"><span class="comment">     * constant time.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if there may be other threads waiting to acquire</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedThreads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> head != tail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Queries whether any threads have ever contended to acquire this</span></span><br><span class="line"><span class="comment">     * synchronizer; that is if an acquire method has ever blocked.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;In this implementation, this operation returns in</span></span><br><span class="line"><span class="comment">     * constant time.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if there has ever been contention</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasContended</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> head != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the first (longest-waiting) thread in the queue, or</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> null&#125; if no threads are currently queued.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;In this implementation, this operation normally returns in</span></span><br><span class="line"><span class="comment">     * constant time, but may iterate upon contention if other threads are</span></span><br><span class="line"><span class="comment">     * concurrently modifying the queue.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the first (longest-waiting) thread in the queue, or</span></span><br><span class="line"><span class="comment">     *         &#123;<span class="doctag">@code</span> null&#125; if no threads are currently queued</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Thread <span class="title">getFirstQueuedThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// handle only fast path, else relay</span></span><br><span class="line">        <span class="keyword">return</span> (head == tail) ? <span class="keyword">null</span> : fullGetFirstQueuedThread();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Version of getFirstQueuedThread called when fastpath fails</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Thread <span class="title">fullGetFirstQueuedThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * The first node is normally head.next. Try to get its</span></span><br><span class="line"><span class="comment">         * thread field, ensuring consistent reads: If thread</span></span><br><span class="line"><span class="comment">         * field is nulled out or s.prev is no longer head, then</span></span><br><span class="line"><span class="comment">         * some other thread(s) concurrently performed setHead in</span></span><br><span class="line"><span class="comment">         * between some of our reads. We try this twice before</span></span><br><span class="line"><span class="comment">         * resorting to traversal.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Node h, s;</span><br><span class="line">        Thread st;</span><br><span class="line">        <span class="keyword">if</span> (((h = head) != <span class="keyword">null</span> &amp;&amp; (s = h.next) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">             s.prev == head &amp;&amp; (st = s.thread) != <span class="keyword">null</span>) ||</span><br><span class="line">            ((h = head) != <span class="keyword">null</span> &amp;&amp; (s = h.next) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">             s.prev == head &amp;&amp; (st = s.thread) != <span class="keyword">null</span>))</span><br><span class="line">            <span class="keyword">return</span> st;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Head&#x27;s next field might not have been set yet, or may have</span></span><br><span class="line"><span class="comment">         * been unset after setHead. So we must check to see if tail</span></span><br><span class="line"><span class="comment">         * is actually first node. If not, we continue on, safely</span></span><br><span class="line"><span class="comment">         * traversing from tail back to head to find first,</span></span><br><span class="line"><span class="comment">         * guaranteeing termination.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        Node t = tail;</span><br><span class="line">        Thread firstThread = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (t != <span class="keyword">null</span> &amp;&amp; t != head) &#123;</span><br><span class="line">            Thread tt = t.thread;</span><br><span class="line">            <span class="keyword">if</span> (tt != <span class="keyword">null</span>)</span><br><span class="line">                firstThread = tt;</span><br><span class="line">            t = t.prev;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> firstThread;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns true if the given thread is currently queued.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;This implementation traverses the queue to determine</span></span><br><span class="line"><span class="comment">     * presence of the given thread.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> thread the thread</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if the given thread is on the queue</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if the thread is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isQueued</span><span class="params">(Thread thread)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (thread == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">for</span> (Node p = tail; p != <span class="keyword">null</span>; p = p.prev)</span><br><span class="line">            <span class="keyword">if</span> (p.thread == thread)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns &#123;<span class="doctag">@code</span> true&#125; if the apparent first queued thread, if one</span></span><br><span class="line"><span class="comment">     * exists, is waiting in exclusive mode.  If this method returns</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> true&#125;, and the current thread is attempting to acquire in</span></span><br><span class="line"><span class="comment">     * shared mode (that is, this method is invoked from &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * #tryAcquireShared&#125;) then it is guaranteed that the current thread</span></span><br><span class="line"><span class="comment">     * is not the first queued thread.  Used only as a heuristic in</span></span><br><span class="line"><span class="comment">     * ReentrantReadWriteLock.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">apparentlyFirstQueuedIsExclusive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node h, s;</span><br><span class="line">        <span class="keyword">return</span> (h = head) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">            (s = h.next)  != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">            !s.isShared()         &amp;&amp;</span><br><span class="line">            s.thread != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Queries whether any threads have been waiting to acquire longer</span></span><br><span class="line"><span class="comment">     * than the current thread.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;An invocation of this method is equivalent to (but may be</span></span><br><span class="line"><span class="comment">     * more efficient than):</span></span><br><span class="line"><span class="comment">     *  &lt;pre&gt; &#123;<span class="doctag">@code</span></span></span><br><span class="line"><span class="comment">     * getFirstQueuedThread() != Thread.currentThread() &amp;&amp;</span></span><br><span class="line"><span class="comment">     * hasQueuedThreads()&#125;&lt;/pre&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Note that because cancellations due to interrupts and</span></span><br><span class="line"><span class="comment">     * timeouts may occur at any time, a &#123;<span class="doctag">@code</span> true&#125; return does not</span></span><br><span class="line"><span class="comment">     * guarantee that some other thread will acquire before the current</span></span><br><span class="line"><span class="comment">     * thread.  Likewise, it is possible for another thread to win a</span></span><br><span class="line"><span class="comment">     * race to enqueue after this method has returned &#123;<span class="doctag">@code</span> false&#125;,</span></span><br><span class="line"><span class="comment">     * due to the queue being empty.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;This method is designed to be used by a fair synchronizer to</span></span><br><span class="line"><span class="comment">     * avoid &lt;a href=&quot;AbstractQueuedSynchronizer#barging&quot;&gt;barging&lt;/a&gt;.</span></span><br><span class="line"><span class="comment">     * Such a synchronizer&#x27;s &#123;<span class="doctag">@link</span> #tryAcquire&#125; method should return</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> false&#125;, and its &#123;<span class="doctag">@link</span> #tryAcquireShared&#125; method should</span></span><br><span class="line"><span class="comment">     * return a negative value, if this method returns &#123;<span class="doctag">@code</span> true&#125;</span></span><br><span class="line"><span class="comment">     * (unless this is a reentrant acquire).  For example, the &#123;<span class="doctag">@code</span></span></span><br><span class="line"><span class="comment">     * tryAcquire&#125; method for a fair, reentrant, exclusive mode</span></span><br><span class="line"><span class="comment">     * synchronizer might look like this:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *  &lt;pre&gt; &#123;<span class="doctag">@code</span></span></span><br><span class="line"><span class="comment">     * protected boolean tryAcquire(int arg) &#123;</span></span><br><span class="line"><span class="comment">     *   if (isHeldExclusively()) &#123;</span></span><br><span class="line"><span class="comment">     *     // A reentrant acquire; increment hold count</span></span><br><span class="line"><span class="comment">     *     return true;</span></span><br><span class="line"><span class="comment">     *   &#125; else if (hasQueuedPredecessors()) &#123;</span></span><br><span class="line"><span class="comment">     *     return false;</span></span><br><span class="line"><span class="comment">     *   &#125; else &#123;</span></span><br><span class="line"><span class="comment">     *     // try to acquire normally</span></span><br><span class="line"><span class="comment">     *   &#125;</span></span><br><span class="line"><span class="comment">     * &#125;&#125;&lt;/pre&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if there is a queued thread preceding the</span></span><br><span class="line"><span class="comment">     *         current thread, and &#123;<span class="doctag">@code</span> false&#125; if the current thread</span></span><br><span class="line"><span class="comment">     *         is at the head of the queue or the queue is empty</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.7</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 在尝试获取锁时调用，判断是否有不包含当前线程中队列的前置节点，有就可以去尝试获取锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedPredecessors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// The correctness of this depends on head being initialized</span></span><br><span class="line">        <span class="comment">// before tail and on head.next being accurate if the current</span></span><br><span class="line">        <span class="comment">// thread is first in queue.</span></span><br><span class="line">        Node t = tail; <span class="comment">// Read fields in reverse initialization order</span></span><br><span class="line">        Node h = head;</span><br><span class="line">        Node s;</span><br><span class="line">        <span class="keyword">return</span> h != t &amp;&amp;</span><br><span class="line">            ((s = h.next) == <span class="keyword">null</span> || s.thread != Thread.currentThread());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Instrumentation and monitoring methods</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns an estimate of the number of threads waiting to</span></span><br><span class="line"><span class="comment">     * acquire.  The value is only an estimate because the number of</span></span><br><span class="line"><span class="comment">     * threads may change dynamically while this method traverses</span></span><br><span class="line"><span class="comment">     * internal data structures.  This method is designed for use in</span></span><br><span class="line"><span class="comment">     * monitoring system state, not for synchronization</span></span><br><span class="line"><span class="comment">     * control.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the estimated number of threads waiting to acquire</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getQueueLength</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node p = tail; p != <span class="keyword">null</span>; p = p.prev) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.thread != <span class="keyword">null</span>)</span><br><span class="line">                ++n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a collection containing threads that may be waiting to</span></span><br><span class="line"><span class="comment">     * acquire.  Because the actual set of threads may change</span></span><br><span class="line"><span class="comment">     * dynamically while constructing this result, the returned</span></span><br><span class="line"><span class="comment">     * collection is only a best-effort estimate.  The elements of the</span></span><br><span class="line"><span class="comment">     * returned collection are in no particular order.  This method is</span></span><br><span class="line"><span class="comment">     * designed to facilitate construction of subclasses that provide</span></span><br><span class="line"><span class="comment">     * more extensive monitoring facilities.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the collection of threads</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Collection&lt;Thread&gt; <span class="title">getQueuedThreads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Thread&gt; list = <span class="keyword">new</span> ArrayList&lt;Thread&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Node p = tail; p != <span class="keyword">null</span>; p = p.prev) &#123;</span><br><span class="line">            Thread t = p.thread;</span><br><span class="line">            <span class="keyword">if</span> (t != <span class="keyword">null</span>)</span><br><span class="line">                list.add(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a collection containing threads that may be waiting to</span></span><br><span class="line"><span class="comment">     * acquire in exclusive mode. This has the same properties</span></span><br><span class="line"><span class="comment">     * as &#123;<span class="doctag">@link</span> #getQueuedThreads&#125; except that it only returns</span></span><br><span class="line"><span class="comment">     * those threads waiting due to an exclusive acquire.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the collection of threads</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Collection&lt;Thread&gt; <span class="title">getExclusiveQueuedThreads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Thread&gt; list = <span class="keyword">new</span> ArrayList&lt;Thread&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Node p = tail; p != <span class="keyword">null</span>; p = p.prev) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!p.isShared()) &#123;</span><br><span class="line">                Thread t = p.thread;</span><br><span class="line">                <span class="keyword">if</span> (t != <span class="keyword">null</span>)</span><br><span class="line">                    list.add(t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a collection containing threads that may be waiting to</span></span><br><span class="line"><span class="comment">     * acquire in shared mode. This has the same properties</span></span><br><span class="line"><span class="comment">     * as &#123;<span class="doctag">@link</span> #getQueuedThreads&#125; except that it only returns</span></span><br><span class="line"><span class="comment">     * those threads waiting due to a shared acquire.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the collection of threads</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Collection&lt;Thread&gt; <span class="title">getSharedQueuedThreads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Thread&gt; list = <span class="keyword">new</span> ArrayList&lt;Thread&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Node p = tail; p != <span class="keyword">null</span>; p = p.prev) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.isShared()) &#123;</span><br><span class="line">                Thread t = p.thread;</span><br><span class="line">                <span class="keyword">if</span> (t != <span class="keyword">null</span>)</span><br><span class="line">                    list.add(t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a string identifying this synchronizer, as well as its state.</span></span><br><span class="line"><span class="comment">     * The state, in brackets, includes the String &#123;<span class="doctag">@code</span> &quot;State =&quot;&#125;</span></span><br><span class="line"><span class="comment">     * followed by the current value of &#123;<span class="doctag">@link</span> #getState&#125;, and either</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> &quot;nonempty&quot;&#125; or &#123;<span class="doctag">@code</span> &quot;empty&quot;&#125; depending on whether the</span></span><br><span class="line"><span class="comment">     * queue is empty.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a string identifying this synchronizer, as well as its state</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s = getState();</span><br><span class="line">        String q  = hasQueuedThreads() ? <span class="string">&quot;non&quot;</span> : <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.toString() +</span><br><span class="line">            <span class="string">&quot;[State = &quot;</span> + s + <span class="string">&quot;, &quot;</span> + q + <span class="string">&quot;empty queue]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Internal support methods for Conditions</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns true if a node, always one that was initially placed on</span></span><br><span class="line"><span class="comment">     * a condition queue, is now waiting to reacquire on sync queue.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node the node</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true if is reacquiring</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isOnSyncQueue</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node.waitStatus == Node.CONDITION || node.prev == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (node.next != <span class="keyword">null</span>) <span class="comment">// If has successor, it must be on queue</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * node.prev can be non-null, but not yet on queue because</span></span><br><span class="line"><span class="comment">         * the CAS to place it on queue can fail. So we have to</span></span><br><span class="line"><span class="comment">         * traverse from tail to make sure it actually made it.  It</span></span><br><span class="line"><span class="comment">         * will always be near the tail in calls to this method, and</span></span><br><span class="line"><span class="comment">         * unless the CAS failed (which is unlikely), it will be</span></span><br><span class="line"><span class="comment">         * there, so we hardly ever traverse much.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> findNodeFromTail(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns true if node is on sync queue by searching backwards from tail.</span></span><br><span class="line"><span class="comment">     * Called only when needed by isOnSyncQueue.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true if present</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">findNodeFromTail</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (t == node)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (t == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            t = t.prev;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Transfers a node from a condition queue onto sync queue.</span></span><br><span class="line"><span class="comment">     * Returns true if successful.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node the node</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true if successfully transferred (else the node was</span></span><br><span class="line"><span class="comment">     * cancelled before signal)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">transferForSignal</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * If cannot change waitStatus, the node has been cancelled.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Splice onto queue and try to set waitStatus of predecessor to</span></span><br><span class="line"><span class="comment">         * indicate that thread is (probably) waiting. If cancelled or</span></span><br><span class="line"><span class="comment">         * attempt to set waitStatus fails, wake up to resync (in which</span></span><br><span class="line"><span class="comment">         * case the waitStatus can be transiently and harmlessly wrong).</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Node p = enq(node);</span><br><span class="line">        <span class="keyword">int</span> ws = p.waitStatus;</span><br><span class="line">        <span class="keyword">if</span> (ws &gt; <span class="number">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))</span><br><span class="line">            LockSupport.unpark(node.thread);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Transfers node, if necessary, to sync queue after a cancelled wait.</span></span><br><span class="line"><span class="comment">     * Returns true if thread was cancelled before being signalled.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node the node</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true if cancelled before the node was signalled</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">transferAfterCancelledWait</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>)) &#123;</span><br><span class="line">            enq(node);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * If we lost out to a signal(), then we can&#x27;t proceed</span></span><br><span class="line"><span class="comment">         * until it finishes its enq().  Cancelling during an</span></span><br><span class="line"><span class="comment">         * incomplete transfer is both rare and transient, so just</span></span><br><span class="line"><span class="comment">         * spin.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">while</span> (!isOnSyncQueue(node))</span><br><span class="line">            Thread.yield();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Invokes release with current state value; returns saved state.</span></span><br><span class="line"><span class="comment">     * Cancels node and throws exception on failure.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node the condition node for this wait</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> previous sync state</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">fullyRelease</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> savedState = getState();</span><br><span class="line">            <span class="keyword">if</span> (release(savedState)) &#123;</span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> savedState;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                node.waitStatus = Node.CANCELLED;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Instrumentation methods for conditions</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Queries whether the given ConditionObject</span></span><br><span class="line"><span class="comment">     * uses this synchronizer as its lock.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> condition the condition</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if owned</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if the condition is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">owns</span><span class="params">(ConditionObject condition)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> condition.isOwnedBy(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Queries whether any threads are waiting on the given condition</span></span><br><span class="line"><span class="comment">     * associated with this synchronizer. Note that because timeouts</span></span><br><span class="line"><span class="comment">     * and interrupts may occur at any time, a &#123;<span class="doctag">@code</span> true&#125; return</span></span><br><span class="line"><span class="comment">     * does not guarantee that a future &#123;<span class="doctag">@code</span> signal&#125; will awaken</span></span><br><span class="line"><span class="comment">     * any threads.  This method is designed primarily for use in</span></span><br><span class="line"><span class="comment">     * monitoring of the system state.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> condition the condition</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if there are any waiting threads</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalMonitorStateException if exclusive synchronization</span></span><br><span class="line"><span class="comment">     *         is not held</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException if the given condition is</span></span><br><span class="line"><span class="comment">     *         not associated with this synchronizer</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if the condition is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasWaiters</span><span class="params">(ConditionObject condition)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!owns(condition))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Not owner&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> condition.hasWaiters();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns an estimate of the number of threads waiting on the</span></span><br><span class="line"><span class="comment">     * given condition associated with this synchronizer. Note that</span></span><br><span class="line"><span class="comment">     * because timeouts and interrupts may occur at any time, the</span></span><br><span class="line"><span class="comment">     * estimate serves only as an upper bound on the actual number of</span></span><br><span class="line"><span class="comment">     * waiters.  This method is designed for use in monitoring of the</span></span><br><span class="line"><span class="comment">     * system state, not for synchronization control.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> condition the condition</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the estimated number of waiting threads</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalMonitorStateException if exclusive synchronization</span></span><br><span class="line"><span class="comment">     *         is not held</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException if the given condition is</span></span><br><span class="line"><span class="comment">     *         not associated with this synchronizer</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if the condition is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getWaitQueueLength</span><span class="params">(ConditionObject condition)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!owns(condition))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Not owner&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> condition.getWaitQueueLength();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a collection containing those threads that may be</span></span><br><span class="line"><span class="comment">     * waiting on the given condition associated with this</span></span><br><span class="line"><span class="comment">     * synchronizer.  Because the actual set of threads may change</span></span><br><span class="line"><span class="comment">     * dynamically while constructing this result, the returned</span></span><br><span class="line"><span class="comment">     * collection is only a best-effort estimate. The elements of the</span></span><br><span class="line"><span class="comment">     * returned collection are in no particular order.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> condition the condition</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the collection of threads</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalMonitorStateException if exclusive synchronization</span></span><br><span class="line"><span class="comment">     *         is not held</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException if the given condition is</span></span><br><span class="line"><span class="comment">     *         not associated with this synchronizer</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if the condition is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Collection&lt;Thread&gt; <span class="title">getWaitingThreads</span><span class="params">(ConditionObject condition)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!owns(condition))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Not owner&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> condition.getWaitingThreads();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Condition implementation for a &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * AbstractQueuedSynchronizer&#125; serving as the basis of a &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * Lock&#125; implementation.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Method documentation for this class describes mechanics,</span></span><br><span class="line"><span class="comment">     * not behavioral specifications from the point of view of Lock</span></span><br><span class="line"><span class="comment">     * and Condition users. Exported versions of this class will in</span></span><br><span class="line"><span class="comment">     * general need to be accompanied by documentation describing</span></span><br><span class="line"><span class="comment">     * condition semantics that rely on those of the associated</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> AbstractQueuedSynchronizer&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;This class is Serializable, but all fields are transient,</span></span><br><span class="line"><span class="comment">     * so deserialized conditions have no waiters.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionObject</span> <span class="keyword">implements</span> <span class="title">Condition</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1173984872572414699L</span>;</span><br><span class="line">        <span class="comment">/** First node of condition queue. */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">transient</span> Node firstWaiter;</span><br><span class="line">        <span class="comment">/** Last node of condition queue. */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">transient</span> Node lastWaiter;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Creates a new &#123;<span class="doctag">@code</span> ConditionObject&#125; instance.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ConditionObject</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Internal methods</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Adds a new waiter to wait queue.</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> its new wait node</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> Node <span class="title">addConditionWaiter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Node t = lastWaiter;</span><br><span class="line">            <span class="comment">// If lastWaiter is cancelled, clean out.</span></span><br><span class="line">            <span class="keyword">if</span> (t != <span class="keyword">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">                unlinkCancelledWaiters();</span><br><span class="line">                t = lastWaiter;</span><br><span class="line">            &#125;</span><br><span class="line">            Node node = <span class="keyword">new</span> Node(Thread.currentThread(), Node.CONDITION);</span><br><span class="line">            <span class="keyword">if</span> (t == <span class="keyword">null</span>)</span><br><span class="line">                firstWaiter = node;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                t.nextWaiter = node;</span><br><span class="line">            lastWaiter = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Removes and transfers nodes until hit non-cancelled one or</span></span><br><span class="line"><span class="comment">         * null. Split out from signal in part to encourage compilers</span></span><br><span class="line"><span class="comment">         * to inline the case of no waiters.</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> first (non-null) the first node on condition queue</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSignal</span><span class="params">(Node first)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="keyword">null</span>)</span><br><span class="line">                    lastWaiter = <span class="keyword">null</span>;</span><br><span class="line">                first.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">while</span> (!transferForSignal(first) &amp;&amp;</span><br><span class="line">                     (first = firstWaiter) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Removes and transfers all nodes.</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> first (non-null) the first node on condition queue</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSignalAll</span><span class="params">(Node first)</span> </span>&#123;</span><br><span class="line">            lastWaiter = firstWaiter = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                Node next = first.nextWaiter;</span><br><span class="line">                first.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line">                transferForSignal(first);</span><br><span class="line">                first = next;</span><br><span class="line">            &#125; <span class="keyword">while</span> (first != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Unlinks cancelled waiter nodes from condition queue.</span></span><br><span class="line"><span class="comment">         * Called only while holding lock. This is called when</span></span><br><span class="line"><span class="comment">         * cancellation occurred during condition wait, and upon</span></span><br><span class="line"><span class="comment">         * insertion of a new waiter when lastWaiter is seen to have</span></span><br><span class="line"><span class="comment">         * been cancelled. This method is needed to avoid garbage</span></span><br><span class="line"><span class="comment">         * retention in the absence of signals. So even though it may</span></span><br><span class="line"><span class="comment">         * require a full traversal, it comes into play only when</span></span><br><span class="line"><span class="comment">         * timeouts or cancellations occur in the absence of</span></span><br><span class="line"><span class="comment">         * signals. It traverses all nodes rather than stopping at a</span></span><br><span class="line"><span class="comment">         * particular target to unlink all pointers to garbage nodes</span></span><br><span class="line"><span class="comment">         * without requiring many re-traversals during cancellation</span></span><br><span class="line"><span class="comment">         * storms.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unlinkCancelledWaiters</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Node t = firstWaiter;</span><br><span class="line">            Node trail = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">while</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Node next = t.nextWaiter;</span><br><span class="line">                <span class="keyword">if</span> (t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">                    t.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (trail == <span class="keyword">null</span>)</span><br><span class="line">                        firstWaiter = next;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        trail.nextWaiter = next;</span><br><span class="line">                    <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">                        lastWaiter = trail;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    trail = t;</span><br><span class="line">                t = next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// public methods</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Moves the longest-waiting thread, if one exists, from the</span></span><br><span class="line"><span class="comment">         * wait queue for this condition to the wait queue for the</span></span><br><span class="line"><span class="comment">         * owning lock.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@throws</span> IllegalMonitorStateException if &#123;<span class="doctag">@link</span> #isHeldExclusively&#125;</span></span><br><span class="line"><span class="comment">         *         returns &#123;<span class="doctag">@code</span> false&#125;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">            Node first = firstWaiter;</span><br><span class="line">            <span class="keyword">if</span> (first != <span class="keyword">null</span>)</span><br><span class="line">                doSignal(first);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Moves all threads from the wait queue for this condition to</span></span><br><span class="line"><span class="comment">         * the wait queue for the owning lock.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@throws</span> IllegalMonitorStateException if &#123;<span class="doctag">@link</span> #isHeldExclusively&#125;</span></span><br><span class="line"><span class="comment">         *         returns &#123;<span class="doctag">@code</span> false&#125;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signalAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">            Node first = firstWaiter;</span><br><span class="line">            <span class="keyword">if</span> (first != <span class="keyword">null</span>)</span><br><span class="line">                doSignalAll(first);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Implements uninterruptible condition wait.</span></span><br><span class="line"><span class="comment">         * &lt;ol&gt;</span></span><br><span class="line"><span class="comment">         * &lt;li&gt; Save lock state returned by &#123;<span class="doctag">@link</span> #getState&#125;.</span></span><br><span class="line"><span class="comment">         * &lt;li&gt; Invoke &#123;<span class="doctag">@link</span> #release&#125; with saved state as argument,</span></span><br><span class="line"><span class="comment">         *      throwing IllegalMonitorStateException if it fails.</span></span><br><span class="line"><span class="comment">         * &lt;li&gt; Block until signalled.</span></span><br><span class="line"><span class="comment">         * &lt;li&gt; Reacquire by invoking specialized version of</span></span><br><span class="line"><span class="comment">         *      &#123;<span class="doctag">@link</span> #acquire&#125; with saved state as argument.</span></span><br><span class="line"><span class="comment">         * &lt;/ol&gt;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">awaitUninterruptibly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Node node = addConditionWaiter();</span><br><span class="line">            <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">            <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">                LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">                    interrupted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (acquireQueued(node, savedState) || interrupted)</span><br><span class="line">                selfInterrupt();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * For interruptible waits, we need to track whether to throw</span></span><br><span class="line"><span class="comment">         * InterruptedException, if interrupted while blocked on</span></span><br><span class="line"><span class="comment">         * condition, versus reinterrupt current thread, if</span></span><br><span class="line"><span class="comment">         * interrupted while blocked waiting to re-acquire.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/** Mode meaning to reinterrupt on exit from wait */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> REINTERRUPT =  <span class="number">1</span>;</span><br><span class="line">        <span class="comment">/** Mode meaning to throw InterruptedException on exit from wait */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THROW_IE    = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Checks for interrupt, returning THROW_IE if interrupted</span></span><br><span class="line"><span class="comment">         * before signalled, REINTERRUPT if after signalled, or</span></span><br><span class="line"><span class="comment">         * 0 if not interrupted.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">checkInterruptWhileWaiting</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Thread.interrupted() ?</span><br><span class="line">                (transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) :</span><br><span class="line">                <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Throws InterruptedException, reinterrupts current thread, or</span></span><br><span class="line"><span class="comment">         * does nothing, depending on mode.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reportInterruptAfterWait</span><span class="params">(<span class="keyword">int</span> interruptMode)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (interruptMode == THROW_IE)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (interruptMode == REINTERRUPT)</span><br><span class="line">                selfInterrupt();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Implements interruptible condition wait.</span></span><br><span class="line"><span class="comment">         * &lt;ol&gt;</span></span><br><span class="line"><span class="comment">         * &lt;li&gt; If current thread is interrupted, throw InterruptedException.</span></span><br><span class="line"><span class="comment">         * &lt;li&gt; Save lock state returned by &#123;<span class="doctag">@link</span> #getState&#125;.</span></span><br><span class="line"><span class="comment">         * &lt;li&gt; Invoke &#123;<span class="doctag">@link</span> #release&#125; with saved state as argument,</span></span><br><span class="line"><span class="comment">         *      throwing IllegalMonitorStateException if it fails.</span></span><br><span class="line"><span class="comment">         * &lt;li&gt; Block until signalled or interrupted.</span></span><br><span class="line"><span class="comment">         * &lt;li&gt; Reacquire by invoking specialized version of</span></span><br><span class="line"><span class="comment">         *      &#123;<span class="doctag">@link</span> #acquire&#125; with saved state as argument.</span></span><br><span class="line"><span class="comment">         * &lt;li&gt; If interrupted while blocked in step 4, throw InterruptedException.</span></span><br><span class="line"><span class="comment">         * &lt;/ol&gt;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">            Node node = addConditionWaiter();</span><br><span class="line">            <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">            <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">                LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">                interruptMode = REINTERRUPT;</span><br><span class="line">            <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>) <span class="comment">// clean up if cancelled</span></span><br><span class="line">                unlinkCancelledWaiters();</span><br><span class="line">            <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">                reportInterruptAfterWait(interruptMode);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Implements timed condition wait.</span></span><br><span class="line"><span class="comment">         * &lt;ol&gt;</span></span><br><span class="line"><span class="comment">         * &lt;li&gt; If current thread is interrupted, throw InterruptedException.</span></span><br><span class="line"><span class="comment">         * &lt;li&gt; Save lock state returned by &#123;<span class="doctag">@link</span> #getState&#125;.</span></span><br><span class="line"><span class="comment">         * &lt;li&gt; Invoke &#123;<span class="doctag">@link</span> #release&#125; with saved state as argument,</span></span><br><span class="line"><span class="comment">         *      throwing IllegalMonitorStateException if it fails.</span></span><br><span class="line"><span class="comment">         * &lt;li&gt; Block until signalled, interrupted, or timed out.</span></span><br><span class="line"><span class="comment">         * &lt;li&gt; Reacquire by invoking specialized version of</span></span><br><span class="line"><span class="comment">         *      &#123;<span class="doctag">@link</span> #acquire&#125; with saved state as argument.</span></span><br><span class="line"><span class="comment">         * &lt;li&gt; If interrupted while blocked in step 4, throw InterruptedException.</span></span><br><span class="line"><span class="comment">         * &lt;/ol&gt;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">awaitNanos</span><span class="params">(<span class="keyword">long</span> nanosTimeout)</span></span></span><br><span class="line"><span class="function">                <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">            Node node = addConditionWaiter();</span><br><span class="line">            <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> deadline = System.nanoTime() + nanosTimeout;</span><br><span class="line">            <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                    transferAfterCancelledWait(node);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (nanosTimeout &gt;= spinForTimeoutThreshold)</span><br><span class="line">                    LockSupport.parkNanos(<span class="keyword">this</span>, nanosTimeout);</span><br><span class="line">                <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                nanosTimeout = deadline - System.nanoTime();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">                interruptMode = REINTERRUPT;</span><br><span class="line">            <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>)</span><br><span class="line">                unlinkCancelledWaiters();</span><br><span class="line">            <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">                reportInterruptAfterWait(interruptMode);</span><br><span class="line">            <span class="keyword">return</span> deadline - System.nanoTime();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Implements absolute timed condition wait.</span></span><br><span class="line"><span class="comment">         * &lt;ol&gt;</span></span><br><span class="line"><span class="comment">         * &lt;li&gt; If current thread is interrupted, throw InterruptedException.</span></span><br><span class="line"><span class="comment">         * &lt;li&gt; Save lock state returned by &#123;<span class="doctag">@link</span> #getState&#125;.</span></span><br><span class="line"><span class="comment">         * &lt;li&gt; Invoke &#123;<span class="doctag">@link</span> #release&#125; with saved state as argument,</span></span><br><span class="line"><span class="comment">         *      throwing IllegalMonitorStateException if it fails.</span></span><br><span class="line"><span class="comment">         * &lt;li&gt; Block until signalled, interrupted, or timed out.</span></span><br><span class="line"><span class="comment">         * &lt;li&gt; Reacquire by invoking specialized version of</span></span><br><span class="line"><span class="comment">         *      &#123;<span class="doctag">@link</span> #acquire&#125; with saved state as argument.</span></span><br><span class="line"><span class="comment">         * &lt;li&gt; If interrupted while blocked in step 4, throw InterruptedException.</span></span><br><span class="line"><span class="comment">         * &lt;li&gt; If timed out while blocked in step 4, return false, else true.</span></span><br><span class="line"><span class="comment">         * &lt;/ol&gt;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">awaitUntil</span><span class="params">(Date deadline)</span></span></span><br><span class="line"><span class="function">                <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">            <span class="keyword">long</span> abstime = deadline.getTime();</span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">            Node node = addConditionWaiter();</span><br><span class="line">            <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">            <span class="keyword">boolean</span> timedout = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (System.currentTimeMillis() &gt; abstime) &#123;</span><br><span class="line">                    timedout = transferAfterCancelledWait(node);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                LockSupport.parkUntil(<span class="keyword">this</span>, abstime);</span><br><span class="line">                <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">                interruptMode = REINTERRUPT;</span><br><span class="line">            <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>)</span><br><span class="line">                unlinkCancelledWaiters();</span><br><span class="line">            <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">                reportInterruptAfterWait(interruptMode);</span><br><span class="line">            <span class="keyword">return</span> !timedout;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Implements timed condition wait.</span></span><br><span class="line"><span class="comment">         * &lt;ol&gt;</span></span><br><span class="line"><span class="comment">         * &lt;li&gt; If current thread is interrupted, throw InterruptedException.</span></span><br><span class="line"><span class="comment">         * &lt;li&gt; Save lock state returned by &#123;<span class="doctag">@link</span> #getState&#125;.</span></span><br><span class="line"><span class="comment">         * &lt;li&gt; Invoke &#123;<span class="doctag">@link</span> #release&#125; with saved state as argument,</span></span><br><span class="line"><span class="comment">         *      throwing IllegalMonitorStateException if it fails.</span></span><br><span class="line"><span class="comment">         * &lt;li&gt; Block until signalled, interrupted, or timed out.</span></span><br><span class="line"><span class="comment">         * &lt;li&gt; Reacquire by invoking specialized version of</span></span><br><span class="line"><span class="comment">         *      &#123;<span class="doctag">@link</span> #acquire&#125; with saved state as argument.</span></span><br><span class="line"><span class="comment">         * &lt;li&gt; If interrupted while blocked in step 4, throw InterruptedException.</span></span><br><span class="line"><span class="comment">         * &lt;li&gt; If timed out while blocked in step 4, return false, else true.</span></span><br><span class="line"><span class="comment">         * &lt;/ol&gt;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">                <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">            <span class="keyword">long</span> nanosTimeout = unit.toNanos(time);</span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">            Node node = addConditionWaiter();</span><br><span class="line">            <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> deadline = System.nanoTime() + nanosTimeout;</span><br><span class="line">            <span class="keyword">boolean</span> timedout = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                    timedout = transferAfterCancelledWait(node);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (nanosTimeout &gt;= spinForTimeoutThreshold)</span><br><span class="line">                    LockSupport.parkNanos(<span class="keyword">this</span>, nanosTimeout);</span><br><span class="line">                <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                nanosTimeout = deadline - System.nanoTime();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">                interruptMode = REINTERRUPT;</span><br><span class="line">            <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>)</span><br><span class="line">                unlinkCancelledWaiters();</span><br><span class="line">            <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">                reportInterruptAfterWait(interruptMode);</span><br><span class="line">            <span class="keyword">return</span> !timedout;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  support for instrumentation</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Returns true if this condition was created by the given</span></span><br><span class="line"><span class="comment">         * synchronization object.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if owned</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isOwnedBy</span><span class="params">(AbstractQueuedSynchronizer sync)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> sync == AbstractQueuedSynchronizer.<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Queries whether any threads are waiting on this condition.</span></span><br><span class="line"><span class="comment">         * Implements &#123;<span class="doctag">@link</span> AbstractQueuedSynchronizer#hasWaiters(ConditionObject)&#125;.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if there are any waiting threads</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@throws</span> IllegalMonitorStateException if &#123;<span class="doctag">@link</span> #isHeldExclusively&#125;</span></span><br><span class="line"><span class="comment">         *         returns &#123;<span class="doctag">@code</span> false&#125;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasWaiters</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">            <span class="keyword">for</span> (Node w = firstWaiter; w != <span class="keyword">null</span>; w = w.nextWaiter) &#123;</span><br><span class="line">                <span class="keyword">if</span> (w.waitStatus == Node.CONDITION)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Returns an estimate of the number of threads waiting on</span></span><br><span class="line"><span class="comment">         * this condition.</span></span><br><span class="line"><span class="comment">         * Implements &#123;<span class="doctag">@link</span> AbstractQueuedSynchronizer#getWaitQueueLength(ConditionObject)&#125;.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> the estimated number of waiting threads</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@throws</span> IllegalMonitorStateException if &#123;<span class="doctag">@link</span> #isHeldExclusively&#125;</span></span><br><span class="line"><span class="comment">         *         returns &#123;<span class="doctag">@code</span> false&#125;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getWaitQueueLength</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">            <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (Node w = firstWaiter; w != <span class="keyword">null</span>; w = w.nextWaiter) &#123;</span><br><span class="line">                <span class="keyword">if</span> (w.waitStatus == Node.CONDITION)</span><br><span class="line">                    ++n;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Returns a collection containing those threads that may be</span></span><br><span class="line"><span class="comment">         * waiting on this Condition.</span></span><br><span class="line"><span class="comment">         * Implements &#123;<span class="doctag">@link</span> AbstractQueuedSynchronizer#getWaitingThreads(ConditionObject)&#125;.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> the collection of threads</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@throws</span> IllegalMonitorStateException if &#123;<span class="doctag">@link</span> #isHeldExclusively&#125;</span></span><br><span class="line"><span class="comment">         *         returns &#123;<span class="doctag">@code</span> false&#125;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> Collection&lt;Thread&gt; <span class="title">getWaitingThreads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">            ArrayList&lt;Thread&gt; list = <span class="keyword">new</span> ArrayList&lt;Thread&gt;();</span><br><span class="line">            <span class="keyword">for</span> (Node w = firstWaiter; w != <span class="keyword">null</span>; w = w.nextWaiter) &#123;</span><br><span class="line">                <span class="keyword">if</span> (w.waitStatus == Node.CONDITION) &#123;</span><br><span class="line">                    Thread t = w.thread;</span><br><span class="line">                    <span class="keyword">if</span> (t != <span class="keyword">null</span>)</span><br><span class="line">                        list.add(t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Setup to support compareAndSet. We need to natively implement</span></span><br><span class="line"><span class="comment">     * this here: For the sake of permitting future enhancements, we</span></span><br><span class="line"><span class="comment">     * cannot explicitly subclass AtomicInteger, which would be</span></span><br><span class="line"><span class="comment">     * efficient and useful otherwise. So, as the lesser of evils, we</span></span><br><span class="line"><span class="comment">     * natively implement using hotspot intrinsics API. And while we</span></span><br><span class="line"><span class="comment">     * are at it, we do the same for other CASable fields (which could</span></span><br><span class="line"><span class="comment">     * otherwise be done with atomic field updaters).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 这里是使用unsafe来操作，cas操作，原子操作</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> stateOffset;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> headOffset;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> tailOffset;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> waitStatusOffset;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> nextOffset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            stateOffset = unsafe.objectFieldOffset</span><br><span class="line">                (AbstractQueuedSynchronizer.class.getDeclaredField(<span class="string">&quot;state&quot;</span>));</span><br><span class="line">            headOffset = unsafe.objectFieldOffset</span><br><span class="line">                (AbstractQueuedSynchronizer.class.getDeclaredField(<span class="string">&quot;head&quot;</span>));</span><br><span class="line">            tailOffset = unsafe.objectFieldOffset</span><br><span class="line">                (AbstractQueuedSynchronizer.class.getDeclaredField(<span class="string">&quot;tail&quot;</span>));</span><br><span class="line">            waitStatusOffset = unsafe.objectFieldOffset</span><br><span class="line">                (Node.class.getDeclaredField(<span class="string">&quot;waitStatus&quot;</span>));</span><br><span class="line">            nextOffset = unsafe.objectFieldOffset</span><br><span class="line">                (Node.class.getDeclaredField(<span class="string">&quot;next&quot;</span>));</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * CAS head field. Used only by enq.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetHead</span><span class="params">(Node update)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapObject(<span class="keyword">this</span>, headOffset, <span class="keyword">null</span>, update);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * CAS tail field. Used only by enq.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetTail</span><span class="params">(Node expect, Node update)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapObject(<span class="keyword">this</span>, tailOffset, expect, update);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * CAS waitStatus field of a node.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetWaitStatus</span><span class="params">(Node node,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                         <span class="keyword">int</span> expect,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                         <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapInt(node, waitStatusOffset,</span><br><span class="line">                                        expect, update);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * CAS next field of a node.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetNext</span><span class="params">(Node node,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                   Node expect,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                   Node update)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapObject(node, nextOffset, expect, update);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>公平锁<br><img src="/images/pasted-52.png" alt="公平锁竞争流程"></p><p>非公平锁<br><img src="/images/pasted-53.png" alt="非公平锁竞争流程"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;AQS是什么呢？&lt;code&gt;AbstractQueuedSynchronizer&lt;/code</summary>
      
    
    
    
    <category term="并发" scheme="http://example.com/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="并发" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>synchronized</title>
    <link href="http://example.com/2021/05/19/%E5%B9%B6%E5%8F%91synchronized%E8%AF%A6%E8%A7%A3/"/>
    <id>http://example.com/2021/05/19/%E5%B9%B6%E5%8F%91synchronized%E8%AF%A6%E8%A7%A3/</id>
    <published>2021-05-19T01:02:00.000Z</published>
    <updated>2021-07-06T15:00:15.392Z</updated>
    
    <content type="html"><![CDATA[<h1 id="如何解决并发问题"><a href="#如何解决并发问题" class="headerlink" title="如何解决并发问题"></a>如何解决并发问题</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;实际上，所有的并发模式在解决并发安全问题时，采用的方案都是序列化访问临界资源。即在同一时刻，只能有一个线程访问临界资源，也称作同步互质访问。<br>Java中提供了两种方式来实现同步互质访问：<b><font color='red'>synchronized和lock</font></b>。<br>同步器的本质就是加锁，加锁的目的：序列化访问临界资源。</p><blockquote><p>当多个线程执行一个方法时，该方法的局部变量并不是临界资源，因为这些局部变量是在每个线程的私有栈中，因此不具备共享性，不会导致线程安全问题</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    countDownLatch.await();</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++) &#123;</span><br><span class="line">                        total++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(<span class="number">200</span>);</span><br><span class="line">        countDownLatch.countDown();</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        System.out.println(total);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这样的方式先采用<code>countDownLatch.await()</code>，然后再执行<code>countDownLatch.countDown()</code>，可以最大限度实现并发，这里的<code>CountDownLatch</code>为1，结果肯定是小于10000，解决方式可以采用<code>synchronized</code>和<code>lock</code></p><h1 id="锁发展历史"><a href="#锁发展历史" class="headerlink" title="锁发展历史"></a>锁发展历史</h1><ol><li><code>jdk&lt;1.6</code>是jdk自带的，这是第一代加锁方式，但是这种锁非常的重，一旦加锁，都是采用os实现的加锁方式，这里就会发生上下文切换，空间切换，非常缓慢。</li><li>doug li看<code>synchronized</code>太慢了，自己开发了一个并发包，juc，性能非常好，纯java写的，里面还实现了jdk没有的特性，虽然底层还是调用了一个java内置的函数。</li><li>oracle收购sun公司后，优化了synchronized，锁的膨胀升级，锁粗化，锁消除，现在的性能和aqs差不多。</li></ol><p><img src="/images/pasted-43.png" alt="锁的升级历史"></p><h1 id="synchronized原理详解"><a href="#synchronized原理详解" class="headerlink" title="synchronized原理详解"></a>synchronized原理详解</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;这里主要还是聊<code>jdk&gt;=1/6</code>后的<code>synchronized</code>。<br>&nbsp;&nbsp;&nbsp;&nbsp;<code>synchronized</code>内置锁是一种对象锁（锁的是对象而非引用），作用粒度是对象，可以用来实现对临界资源的访问，是可重入的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span> 锁的是这个实例对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span> 锁的是这个类对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span></span>&#123; 锁的是括号里的这个对象</span><br><span class="line"><span class="keyword">synchronized</span>(Object.class)</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h2 id="synchronized底层原理"><a href="#synchronized底层原理" class="headerlink" title="synchronized底层原理"></a>synchronized底层原理</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;synchronized是基于<b><font color='red'>JVM内置锁实现，通过内部对象Monitor（监视器锁）实现。基于进入与退出Monitor对象实现方法与代码块同步，监视器锁的实现依赖操作系统的Mutex Lock（互斥锁）实现，它是一个重量级锁性能低。（在&gt;=jdk1.6，实现重量级锁是monitor锁，轻量级锁、偏向锁不是使用monitor锁）</font></b>当然JVM内置锁在jdk&gt;=1.6后做了升级优化，锁粗化（Lock Coarsening）、锁消除（Lock Elimination）、轻量级锁（LightWeight Locking）、偏向锁（Biased Locking）、适应性自旋锁（adaptive Spinning）等技术减少锁的开销。</p><blockquote><p>jdk&gt;=1.6，偏向锁、轻量级锁的实现是通过对象头的mark word锁标识和lock record来实现。那为什么一个线程的锁编译还是有monitorenter和monitorexit呢？其实是编译器加的<a href="https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-3.html">https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-3.html</a><br>The compiler ensures that at any method invocation completion, a monitorexit instruction will have been executed for each monitorenter instruction executed since the method invocation.</p></blockquote><h2 id="monitor监视器锁"><a href="#monitor监视器锁" class="headerlink" title="monitor监视器锁"></a>monitor监视器锁</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;任何一个对象都有一个<code>monitor</code>与之关联，并且一个<code>monitor</code>被持有后，它将处于锁定状态。<br>synchronized在jvm里的实现都是基于进入和退出monitor对象来实现方法的同步与代码块同步。虽然具体实现细节不一样，但是都可以成对的<code>monitorenter</code>和<code>monitorexit</code>指令来实现。</p><ul><li>monitorenter<ul><li>当monitorenter为0，如果线程进入monitor，则进入数加1，该线程持有了monitor<br>   * 如果这个线程持有了monitor，尝试再进入monitor（例如方法调用方法），则monitor的进入数加1<br>   * 那其他线程已经占有的monitor，则其他线程会阻塞状态，直至monitor的进入数为0，再重新尝试获取monitor的所有权</li></ul></li><li>monitorexit<ul><li>执行monitorexit的线程必须是objectref所对应的monitor的所有者，指令执行时，monitor的进入数减1，如果减1为0，那线程退出monitor，不再是这个monitor的持有者了。</li></ul></li></ul><p>下面这个例子，其中有一个<code>monitorenter</code>和两个<code>monitorexit</code>，两个中的一个是异常情况下的退出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Object object = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sync</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (object)&#123;</span><br><span class="line">            System.out.println(<span class="number">111</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">#对应的字节码</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sync</span><span class="params">()</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       <span class="number">1</span>: getfield      #<span class="number">3</span>                  <span class="comment">// Field object:Ljava/lang/Object;</span></span><br><span class="line">       <span class="number">4</span>: dup</span><br><span class="line">       <span class="number">5</span>: astore_1</span><br><span class="line">       <span class="number">6</span>: monitorenter</span><br><span class="line">       <span class="number">7</span>: getstatic     #<span class="number">4</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">      <span class="number">10</span>: bipush        <span class="number">111</span></span><br><span class="line">      <span class="number">12</span>: invokevirtual #<span class="number">5</span>                  <span class="comment">// Method java/io/PrintStream.println:(I)V</span></span><br><span class="line">      <span class="number">15</span>: aload_1</span><br><span class="line">      <span class="number">16</span>: monitorexit</span><br><span class="line">      <span class="number">17</span>: goto          <span class="number">25</span></span><br><span class="line">      <span class="number">20</span>: astore_2</span><br><span class="line">      <span class="number">21</span>: aload_1</span><br><span class="line">      <span class="number">22</span>: monitorexit</span><br><span class="line">      <span class="number">23</span>: aload_2</span><br><span class="line">      <span class="number">24</span>: athrow</span><br><span class="line">      <span class="number">25</span>: <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p>下面这个例子是修饰在方法上，看字节码，里面的flags增加了<code>ACC_SYNCHRONIZED</code>，虽然没有加上monitor对象，但是jvm也能根据这个标识来实现方法的同步，当调用指令将会检查方法的<code>ACC_SYNCHRONIZED</code>访问标志是否被设置，如果设置了，执行线程将先获取monitor，获取成功之后才能执行方法体，方法执行完了再释放monitor。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> synchronized <span class="keyword">void</span> <span class="title">syncO</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="number">111</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"># 对应字节码</span><br><span class="line"><span class="function"><span class="keyword">public</span> synchronized <span class="keyword">void</span> <span class="title">syncO</span><span class="params">()</span></span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_SYNCHRONIZED</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: getstatic     #<span class="number">4</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">         <span class="number">3</span>: bipush        <span class="number">111</span></span><br><span class="line">         <span class="number">5</span>: invokevirtual #<span class="number">5</span>                  <span class="comment">// Method java/io/PrintStream.println:(I)V</span></span><br><span class="line">         <span class="number">8</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">14</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">15</span>: <span class="number">8</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">9</span>     <span class="number">0</span>  <span class="keyword">this</span>   Ljuc/juc04/SynchronizedDemo;            </span><br></pre></td></tr></table></figure><p><b><font color='red'>两种同步方法本质上没有区别，只是方法的同步是一种隐式的方法来实现，无需通过字节码来完成。两个指令的执行是jvm通过调用操作系统的互斥源于mutex来实现，被阻塞的线程会被挂起，等待重新调度，会导致”用户态和内核态“两个态切换。</font></b></p><blockquote><p>Synchronized的语义底层是通过一个monitor的对象来完成，其实wait/notify等方法也依赖于monitor对象，这就是为什么只有在同步的块或者方法中才能调用wait/notify等方法，否则 会抛出java.lang.IllegalMonitorStateException的异常的原因。</p></blockquote><h2 id="什么是monitor"><a href="#什么是monitor" class="headerlink" title="什么是monitor"></a>什么是monitor</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;<code>monitor</code>可以把它理解为一个同步工具，也可以描述为一个同步机制，它通常被描述一个对象。<b><font color='red'>所有的java对象都是monitor，每一个java对象都有成为monitor的潜质。因为在java设计中，每一个java对象都带一把看不见的锁，它叫做内部锁或者monitor锁。也就是synchronized的对象锁。MarkWord锁标志位为10，其中指针指向monitor对象的起始地址。</font></b></p><p>在jdk中Monitor由ObjectMonitor.hpp文件实现的（c++实现）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ObjectMonitor</span>() &#123;</span><br><span class="line">   _header       = <span class="literal">NULL</span>;</span><br><span class="line">   _count        = <span class="number">0</span>; <span class="comment">//记录个数</span></span><br><span class="line">   _waiters      = <span class="number">0</span>,</span><br><span class="line">   _recursions   = <span class="number">0</span>;</span><br><span class="line">   _object       = <span class="literal">NULL</span>;</span><br><span class="line">   _owner        = <span class="literal">NULL</span>; <span class="comment">// 线程拥有者</span></span><br><span class="line">   _WaitSet      = <span class="literal">NULL</span>; <span class="comment">// 等待wait状态的线程，会被加入到这里</span></span><br><span class="line">   _WaitSetLock  = <span class="number">0</span> ;</span><br><span class="line">   _Responsible  = <span class="literal">NULL</span> ;</span><br><span class="line">   _succ         = <span class="literal">NULL</span> ;</span><br><span class="line">   _cxq          = <span class="literal">NULL</span> ;</span><br><span class="line">   FreeNext      = <span class="literal">NULL</span> ;</span><br><span class="line">   _EntryList    = <span class="literal">NULL</span> ;<span class="comment">// 处于等待锁block状态的线程，会被加入到这里</span></span><br><span class="line">   _SpinFreq     = <span class="number">0</span> ;</span><br><span class="line">   _SpinClock    = <span class="number">0</span> ;</span><br><span class="line">   OwnerIsThread = <span class="number">0</span> ;</span><br><span class="line">   _previous_owner_tid = <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>ObjectMonitor</code>中有两个队列，<code>_WaitSet</code>和<code>_EntryList</code>，用来保存ObjectWaiter对象列表（每个等待锁的线程都会被封装成ObjectWaiter对象），<code>_owner</code>指向持有<code>ObjectMonitor</code>对象的线程，多个线程访问一个同步代码时：</p><ol><li>首先会进入<code>_EntryList</code>，当线程获取到对象的monitor后，进入<code>_owner</code>区域并把monitor的<code>_owner</code>为当前线程，同时<code>_count</code>计数器会加1</li><li>若线程调用wait()方法，将释放当前持有的monitor，owner变量恢复为null，count自减1，同时该线程进入waitSet集合中等待被唤醒</li><li>若当前线程执行完毕，也将释放monitor并复位count的值，以便其他线程进入获取monitor。</li></ol><blockquote><p>monitor对象存在于每个java对象的对象头mark word中（存储的指针的指向），synchronized锁便是通过这种方式获取锁的，也是为什么java中任意对象可以作为锁的原因，同时notify、notifyAll、wait等方法会使用monitor对象，所以必须在同步代码块中使用。</p></blockquote><h2 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;当成功对分配的内存空间进行零值初始化后，jvm就会对对象进行实例化。在hotSpot中，对象实例化操作无非就是初始化<b><font color='red'>对象头</font></b>和<b><font color='red'>实例数据</font></b>，而且存储对象实例信息的内存布局也主要由这两个部分组成。</p><ul><li>对象头<ul><li>主要存储Mark Word和元数据指针等数据，其中Mark Word主要用于存储对象运行时的数据信息，比如HashCode、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。元数据指针则是用于指向方法区中目标类的类型信息，也就是说可以通过元数据指针可以准确定位到当前对象的具体目标类型</li></ul></li><li>实例数据<ul><li>用于存储定义在当前对象中各种类型的字段信息（包括派生于超类的字段信息）</li></ul></li><li>对齐填充<ul><li>由于虚拟机要求对象起始地址必须是8字节的整数倍。填充数据不是必须存在的，仅仅是为了字节对齐</li></ul></li></ul><p><img src="/images/pasted-44.png" alt="对象内存布局"></p><h3 id="Mark-Word"><a href="#Mark-Word" class="headerlink" title="Mark Word"></a>Mark Word</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;现在我们虚拟机基本是64位的，而64位的对象头有点浪费空间,JVM默认会开启指针压缩，所以基本上也是按32位的形式记录对象头的，手动设置<code>‐XX:+UseCompressedOops</code></p><p><img src="/images/pasted-46.png" alt="32位Mark Word"></p><p><img src="/images/pasted-45.png" alt="64位Mark Word"></p><p>mark word，有方法可以去看吗？</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 1. 引入下面pom</span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.openjdk.jol<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jol-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.15<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"># 2.打印对象头，object是锁对象</span><br><span class="line">System.out.println(ClassLayout.parseInstance(object).toPrintable());</span><br></pre></td></tr></table></figure><h3 id="锁的膨胀升级过程"><a href="#锁的膨胀升级过程" class="headerlink" title="锁的膨胀升级过程"></a>锁的膨胀升级过程</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;锁的状态总共有四种，无锁状态、偏向锁、轻量级锁、重量级锁。锁可以从偏向锁升级到轻量级锁，再升级到重量级锁，锁的升级是单向的，只能从低到高，不会出现锁的降级。<br><img src="/images/pasted-47.png" alt="锁的膨胀升级"></p><h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;偏向锁是在jdk1.6引入的新锁，它是一种针对加锁的优化手段，经过研究发现，在大多情况下，锁不仅不存在多线程竞争，而且总是有同一线程多次获得，因此为了减少同一线程获取锁（会涉及一些cas操作，耗时）的代价而引入偏向锁。偏向锁的核心思想是，如果一个线程获得了锁，那么锁就进入偏向模式，此时Mark Word的结构也变为偏向锁的结构，当这个线程再次请求锁时，无需再做任何同步的操作，从而节省锁的申请过程，提供了性能。所以，对于没有锁竞争的场合，偏向锁有很好的效果，毕竟极有可能连续多次是同一线程申请相同的锁。但是对于锁竞争比较激烈的场合，偏向锁就失效了，因为这个场合极有可能申请锁的线程是不相同的，因此使用偏向锁就得不偿失，<b><font color='red'>需要注意的是，偏向锁失败后，并不会直接升级重量级锁，而是先升级轻量级锁。</font></b></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">默认开启偏向锁 </span><br><span class="line"><span class="section">开启偏向锁：-XX:+UseBiasedLocking -XX:BiasedLockingStartupDelay=0 </span></span><br><span class="line"><span class="section">关闭偏向锁：-XX:-UseBiasedLocking</span></span><br></pre></td></tr></table></figure><p>下面是偏向锁的例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">      Object o = <span class="keyword">new</span> Object();</span><br><span class="line">      System.out.println(ClassLayout.parseInstance(o).toPrintable());</span><br><span class="line">      <span class="keyword">synchronized</span> (o)&#123;</span><br><span class="line">          System.out.println(ClassLayout.parseInstance(o).toPrintable());</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>打印Mark Word</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">java</span>.lang.Object object internals:</span><br><span class="line"><span class="attribute">OFF</span>  SZ   TYPE DESCRIPTION               VALUE</span><br><span class="line">  <span class="attribute">0</span>   <span class="number">8</span>        (object header: mark)     <span class="number">0</span>x<span class="number">0000000000000005</span> (biasable; age: <span class="number">0</span>)</span><br><span class="line">  <span class="attribute">8</span>   <span class="number">4</span>        (object header: class)    <span class="number">0</span>xf<span class="number">80001</span>e<span class="number">5</span></span><br><span class="line"> <span class="attribute">12</span>   <span class="number">4</span>        (object alignment gap)    </span><br><span class="line"><span class="attribute">Instance</span> size: <span class="number">16</span> bytes</span><br><span class="line"><span class="attribute">Space</span> losses: <span class="number">0</span> bytes internal + <span class="number">4</span> bytes external = <span class="number">4</span> bytes total</span><br><span class="line"></span><br><span class="line"><span class="attribute">java</span>.lang.Object object internals:</span><br><span class="line"><span class="attribute">OFF</span>  SZ   TYPE DESCRIPTION               VALUE</span><br><span class="line">  <span class="attribute">0</span>   <span class="number">8</span>        (object header: mark)     <span class="number">0</span>x<span class="number">00007</span>fd<span class="number">8</span>f<span class="number">000</span>a<span class="number">805</span> (biased: <span class="number">0</span>x<span class="number">0000001</span>ff<span class="number">63</span>c<span class="number">002</span>a; epoch: <span class="number">0</span>; age: <span class="number">0</span>)</span><br><span class="line">  <span class="attribute">8</span>   <span class="number">4</span>        (object header: class)    <span class="number">0</span>xf<span class="number">80001</span>e<span class="number">5</span></span><br><span class="line"> <span class="attribute">12</span>   <span class="number">4</span>        (object alignment gap)    </span><br><span class="line"><span class="attribute">Instance</span> size: <span class="number">16</span> bytes</span><br><span class="line"><span class="attribute">Space</span> losses: <span class="number">0</span> bytes internal + <span class="number">4</span> bytes external = <span class="number">4</span> bytes total</span><br></pre></td></tr></table></figure><p>其中，java虚拟机开启偏向锁是懒加载的方式，默认需要等待4s的时间，因为java虚拟机在启动的时候，里面有多个线程会去加载，会存在竞争，如果打开偏向锁，多个线程竞争还需要锁升级，这里要演示偏向锁就需要等待4s多，其中<code>biasable</code>表示无锁状态，但是可偏向，表示能偏向线程，mark word 为<code>101</code>，但是mark word 前面字节都是0，但是还没有偏向。<code>biased</code>表示偏向锁。</p><h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;偏向锁失败后，虚拟机并不会立马升级为重量级锁，它还会尝试使用一种轻量级锁的优化手段，此时Mark Word的结构也变为轻量级锁的结构。轻量级锁能够提升程序性能的依据是“对绝大部分的锁，在整个同步周期内都不存在竞争”，注意这是经验数据。轻量级锁所适应的场景是线程交替执行同步块的场合，如果存在同一时间访问同一个锁的场景，就会导致轻量级锁升级为重量级锁。</p><p>下面是轻量级锁的例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">      <span class="keyword">final</span> Object o = <span class="keyword">new</span> Object();</span><br><span class="line">      System.out.println(ClassLayout.parseInstance(o).toPrintable());</span><br><span class="line">      <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">              <span class="keyword">synchronized</span> (o)&#123;</span><br><span class="line">                  System.out.println(ClassLayout.parseInstance(o).toPrintable());</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;).start();</span><br><span class="line">      <span class="comment">// 等待的时间如果长的话，接下来mark word不一定是轻量级锁，如果等待3s有可能是偏向锁，看资源已经释放</span></span><br><span class="line">      Thread.sleep(<span class="number">30</span>); </span><br><span class="line">      <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">              <span class="keyword">synchronized</span> (o)&#123;</span><br><span class="line">                  System.out.println(ClassLayout.parseInstance(o).toPrintable());</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;).start();</span><br></pre></td></tr></table></figure><p>打印Mark Word</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">java</span>.lang.Object object internals:</span><br><span class="line"><span class="attribute">OFF</span>  SZ   TYPE DESCRIPTION               VALUE</span><br><span class="line">  <span class="attribute">0</span>   <span class="number">8</span>        (object header: mark)     <span class="number">0</span>x<span class="number">0000000000000005</span> (biasable; age: <span class="number">0</span>)</span><br><span class="line">  <span class="attribute">8</span>   <span class="number">4</span>        (object header: class)    <span class="number">0</span>xf<span class="number">80001</span>e<span class="number">5</span></span><br><span class="line"> <span class="attribute">12</span>   <span class="number">4</span>        (object alignment gap)    </span><br><span class="line"><span class="attribute">Instance</span> size: <span class="number">16</span> bytes</span><br><span class="line"><span class="attribute">Space</span> losses: <span class="number">0</span> bytes internal + <span class="number">4</span> bytes external = <span class="number">4</span> bytes total</span><br><span class="line"></span><br><span class="line"><span class="attribute">java</span>.lang.Object object internals:</span><br><span class="line"><span class="attribute">OFF</span>  SZ   TYPE DESCRIPTION               VALUE</span><br><span class="line">  <span class="attribute">0</span>   <span class="number">8</span>        (object header: mark)     <span class="number">0</span>x<span class="number">00007</span>f<span class="number">81460</span>aa<span class="number">805</span> (biased: <span class="number">0</span>x<span class="number">0000001</span>fe<span class="number">05182</span>aa; epoch: <span class="number">0</span>; age: <span class="number">0</span>)</span><br><span class="line">  <span class="attribute">8</span>   <span class="number">4</span>        (object header: class)    <span class="number">0</span>xf<span class="number">80001</span>e<span class="number">5</span></span><br><span class="line"> <span class="attribute">12</span>   <span class="number">4</span>        (object alignment gap)    </span><br><span class="line"><span class="attribute">Instance</span> size: <span class="number">16</span> bytes</span><br><span class="line"><span class="attribute">Space</span> losses: <span class="number">0</span> bytes internal + <span class="number">4</span> bytes external = <span class="number">4</span> bytes total</span><br><span class="line"></span><br><span class="line"><span class="attribute">java</span>.lang.Object object internals:</span><br><span class="line"><span class="attribute">OFF</span>  SZ   TYPE DESCRIPTION               VALUE</span><br><span class="line">  <span class="attribute">0</span>   <span class="number">8</span>        (object header: mark)     <span class="number">0</span>x<span class="number">0000700003528960</span> (thin lock: <span class="number">0</span>x<span class="number">0000700003528960</span>)</span><br><span class="line">  <span class="attribute">8</span>   <span class="number">4</span>        (object header: class)    <span class="number">0</span>xf<span class="number">80001</span>e<span class="number">5</span></span><br><span class="line"> <span class="attribute">12</span>   <span class="number">4</span>        (object alignment gap)    </span><br><span class="line"><span class="attribute">Instance</span> size: <span class="number">16</span> bytes</span><br><span class="line"><span class="attribute">Space</span> losses: <span class="number">0</span> bytes internal + <span class="number">4</span> bytes external = <span class="number">4</span> bytes total</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>还有一个例子，是调用对象的hashCode会导致偏向锁升级为轻量级锁</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>sleep(<span class="number">5000</span>);</span><br><span class="line">        Object o = <span class="keyword">new</span> <span class="constructor">Object()</span>;</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="module-access"><span class="module"><span class="identifier">ClassLayout</span>.</span></span>parse<span class="constructor">Instance(<span class="params">o</span>)</span>.<span class="keyword">to</span><span class="constructor">Printable()</span>);</span><br><span class="line">        synchronized (o)&#123;</span><br><span class="line">            <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="module-access"><span class="module"><span class="identifier">ClassLayout</span>.</span></span>parse<span class="constructor">Instance(<span class="params">o</span>)</span>.<span class="keyword">to</span><span class="constructor">Printable()</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(o.hash<span class="constructor">Code()</span>); <span class="comment">// 会将偏向锁升级为轻量级锁</span></span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="module-access"><span class="module"><span class="identifier">ClassLayout</span>.</span></span>parse<span class="constructor">Instance(<span class="params">o</span>)</span>.<span class="keyword">to</span><span class="constructor">Printable()</span>); <span class="comment">//可重偏向</span></span><br><span class="line">        synchronized (o)&#123;</span><br><span class="line">            <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="module-access"><span class="module"><span class="identifier">ClassLayout</span>.</span></span>parse<span class="constructor">Instance(<span class="params">o</span>)</span>.<span class="keyword">to</span><span class="constructor">Printable()</span>); <span class="comment">// 轻量级锁</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>打印的Mark Word</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">java</span>.lang.Object object internals:</span><br><span class="line"><span class="attribute">OFF</span>  SZ   TYPE DESCRIPTION               VALUE</span><br><span class="line">  <span class="attribute">0</span>   <span class="number">8</span>        (object header: mark)     <span class="number">0</span>x<span class="number">0000000000000005</span> (biasable; age: <span class="number">0</span>)</span><br><span class="line">  <span class="attribute">8</span>   <span class="number">4</span>        (object header: class)    <span class="number">0</span>xf<span class="number">80001</span>e<span class="number">5</span></span><br><span class="line"> <span class="attribute">12</span>   <span class="number">4</span>        (object alignment gap)    </span><br><span class="line"><span class="attribute">Instance</span> size: <span class="number">16</span> bytes</span><br><span class="line"><span class="attribute">Space</span> losses: <span class="number">0</span> bytes internal + <span class="number">4</span> bytes external = <span class="number">4</span> bytes total</span><br><span class="line"></span><br><span class="line"><span class="attribute">java</span>.lang.Object object internals:</span><br><span class="line"><span class="attribute">OFF</span>  SZ   TYPE DESCRIPTION               VALUE</span><br><span class="line">  <span class="attribute">0</span>   <span class="number">8</span>        (object header: mark)     <span class="number">0</span>x<span class="number">00007</span>ffeda<span class="number">809005</span> (biased: <span class="number">0</span>x<span class="number">0000001</span>fffb<span class="number">6</span>a<span class="number">024</span>; epoch: <span class="number">0</span>; age: <span class="number">0</span>)</span><br><span class="line">  <span class="attribute">8</span>   <span class="number">4</span>        (object header: class)    <span class="number">0</span>xf<span class="number">80001</span>e<span class="number">5</span></span><br><span class="line"> <span class="attribute">12</span>   <span class="number">4</span>        (object alignment gap)    </span><br><span class="line"><span class="attribute">Instance</span> size: <span class="number">16</span> bytes</span><br><span class="line"><span class="attribute">Space</span> losses: <span class="number">0</span> bytes internal + <span class="number">4</span> bytes external = <span class="number">4</span> bytes total</span><br><span class="line"></span><br><span class="line"><span class="attribute">607635164</span></span><br><span class="line"><span class="attribute">java</span>.lang.Object object internals:</span><br><span class="line"><span class="attribute">OFF</span>  SZ   TYPE DESCRIPTION               VALUE</span><br><span class="line">  <span class="attribute">0</span>   <span class="number">8</span>        (object header: mark)     <span class="number">0</span>x<span class="number">0000002437</span>c<span class="number">6</span>dc<span class="number">01</span> (hash: <span class="number">0</span>x<span class="number">2437</span>c<span class="number">6</span>dc; age: <span class="number">0</span>)</span><br><span class="line">  <span class="attribute">8</span>   <span class="number">4</span>        (object header: class)    <span class="number">0</span>xf<span class="number">80001</span>e<span class="number">5</span></span><br><span class="line"> <span class="attribute">12</span>   <span class="number">4</span>        (object alignment gap)    </span><br><span class="line"><span class="attribute">Instance</span> size: <span class="number">16</span> bytes</span><br><span class="line"><span class="attribute">Space</span> losses: <span class="number">0</span> bytes internal + <span class="number">4</span> bytes external = <span class="number">4</span> bytes total</span><br><span class="line"></span><br><span class="line"><span class="attribute">java</span>.lang.Object object internals:</span><br><span class="line"><span class="attribute">OFF</span>  SZ   TYPE DESCRIPTION               VALUE</span><br><span class="line">  <span class="attribute">0</span>   <span class="number">8</span>        (object header: mark)     <span class="number">0</span>x<span class="number">000070000</span>c<span class="number">4</span>d<span class="number">2988</span> (thin lock: <span class="number">0</span>x<span class="number">000070000</span>c<span class="number">4</span>d<span class="number">2988</span>)</span><br><span class="line">  <span class="attribute">8</span>   <span class="number">4</span>        (object header: class)    <span class="number">0</span>xf<span class="number">80001</span>e<span class="number">5</span></span><br><span class="line"> <span class="attribute">12</span>   <span class="number">4</span>        (object alignment gap)    </span><br><span class="line"><span class="attribute">Instance</span> size: <span class="number">16</span> bytes</span><br><span class="line"><span class="attribute">Space</span> losses: <span class="number">0</span> bytes internal + <span class="number">4</span> bytes external = <span class="number">4</span> bytes total</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>那打印的<code>System.out.println(o.hashCode());</code>不是锁降为无锁状态，而是此时作为没有synchronized修饰对象，获取的此时对象的头。<br>那这里为什么偏向锁调用hashCode会升级偏向锁呢？由于偏向锁的时候Mark Word里是没有存储hashCode，而轻量级锁里面是有hashCode的，hashCode是锁对象里的Mark Word的指针指向栈中lock record中的mark word的hashCode，详细见锁的膨胀升级。那这是直接调用底层生成的hashcode，还是使用的lock record的hashcode，这块是不确定的。</p><h4 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;轻量级锁失败后，虚拟机为了避免线程真实地在操作系统层面挂起，还会进行一项称为自旋锁的手段。这是基于在大多情况下，线程持有锁的时间都不太长，如果直接挂起操作系统层面的线程可能会得不偿失，毕竟操作系统实现线程之间的切换时需要从用户态切换到核心态，这个状态切换是需要时间的，成本比较高。因此自旋锁会假设在不久将来，当前的线程可以获取锁，因此虚拟机会让当前想要获取锁的线程做几个空循环（这也是成为自旋的原因），一般不会太久，可能是50个循环或100循环，在经过若干次循环后，如果得到锁，就顺利进入临界区。如果还不能获取锁，那就会将线程在操作系统层面挂起，这就是自旋锁的优化。否则就升级为重量级锁</p><h4 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;锁消除是虚拟机的另外一种锁的优化。这种优化更彻底，java虚拟机在Jit编译时（可以简单理解为当某段代码即将第一次被执行时进行编译，又称及时编译），通过对上下文的扫描，去除不可能存在共享资源竞争的锁，通过这种方式消除没有必要的锁，可以节省毫无意义的请求锁时间。所消除的依据是逃逸分析的数据支持。</p><blockquote><p>如StringBuffer的append是一个同步方法，但是在add方法中的StringBuffer属于一个局部变量，并且不会被其他线程所使用，因此StringBuffer不可能存在共享资源竞争的情景，JVM会自动将其锁消除。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sync</span><span class="params">()</span></span>&#123;</span><br><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">synchronized</span>(obj)&#123;</span><br><span class="line">    <span class="comment">// xxx</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的synchronized可以去掉，锁的对象是方法内部，不会存在竞争</p><blockquote><p>锁消除，前提是java必须运行在server模式，同时必须开启逃逸分析<br>:-XX:+DoEscapeAnalysis 开启逃逸分析<br>-XX:+EliminateLocks 表示开启锁消除。</p></blockquote><h4 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;按理来说，同步块的作用范围应该尽可能小，仅在共享数据的实际作用域中才进行同步，这样做的目的是为了使需要同步的操作数量尽可能缩小，缩短阻塞时间，如果存在锁竞争，那么等待锁的线程也能尽快拿到锁。但是加锁解锁也需要消耗资源，如果存在一系列的连续加锁解锁操作，可能会导致不必要的性能损耗。锁粗化就是将多个连续的加锁、解锁操作连接在一起，扩展成一个范围更大的锁，避免频繁的加锁解锁操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sync</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(Object.class)&#123;</span><br><span class="line">    <span class="comment">// aaa</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">synchronized</span>(Object.class)&#123;</span><br><span class="line">    <span class="comment">// bbb</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">synchronized</span>(Object.class)&#123;</span><br><span class="line">    <span class="comment">// ccc</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以优化为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sync</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(Object.class)&#123;</span><br><span class="line">    <span class="comment">// aaa</span></span><br><span class="line">        <span class="comment">// bbb</span></span><br><span class="line">        <span class="comment">// ccc</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;如何解决并发问题&quot;&gt;&lt;a href=&quot;#如何解决并发问题&quot; class=&quot;headerlink&quot; title=&quot;如何解决并发问题&quot;&gt;&lt;/a&gt;如何解决并发问题&lt;/h1&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;实际上，所有的并发模式在解决并发安全问题时，</summary>
      
    
    
    
    <category term="并发" scheme="http://example.com/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="并发" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>MESI</title>
    <link href="http://example.com/2021/05/15/MESI/"/>
    <id>http://example.com/2021/05/15/MESI/</id>
    <published>2021-05-15T12:17:00.000Z</published>
    <updated>2021-07-06T15:00:15.406Z</updated>
    
    <content type="html"><![CDATA[<h1 id="jvm整个执行过程"><a href="#jvm整个执行过程" class="headerlink" title="jvm整个执行过程"></a>jvm整个执行过程</h1><p><img src="/images/pasted-39.png" alt="jvm-&gt;cpu执行过程"></p><h1 id="volatile可见性"><a href="#volatile可见性" class="headerlink" title="volatile可见性"></a>volatile可见性</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 打印汇编</span></span><br><span class="line"><span class="comment"> * 在jdk库里加上/Library/Java/JavaVirtualMachines/jdk1.8.0_201.jdk/Contents/Home/jre/lib/hsdis-amd64.dylib</span></span><br><span class="line"><span class="comment"> * vm options：-server -Xcomp -XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly -XX:CompileCommand=compileonly,*JavaVolatile.fresh</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaVolatile</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="keyword">boolean</span> initFlag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fresh</span><span class="params">()</span></span>&#123;</span><br><span class="line">        initFlag = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">while</span> (!initFlag) &#123;</span><br><span class="line">                    j++;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;param=&quot;</span> + initFlag);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                fresh();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        thread1.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中输出结果如下，发现被volatile修饰的initFlag中有<code>lock#</code>打头。</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x000000010657165b</span>: movabs $0x7956a1a38,%rsi  ;   &#123;oop(a <span class="string">&#x27;java/lang/Class&#x27;</span> = <span class="string">&#x27;juc/juc03/JavaVolatile&#x27;</span>)&#125;</span><br><span class="line"><span class="number">0x0000000106571665</span>: mov    $0x1,%edi</span><br><span class="line"><span class="number">0x000000010657166a</span>: mov    %dil,<span class="number">0x6c</span>(%rsi)</span><br><span class="line"><span class="number">0x000000010657166e</span>: lock addl $0x0,(%rsp)     ;*putstatic initFlag</span><br><span class="line">                                              ; - juc.juc03.JavaVolatile::fresh@1 (line <span class="number">14</span>)</span><br></pre></td></tr></table></figure><h1 id="总线锁和缓存一致性协议"><a href="#总线锁和缓存一致性协议" class="headerlink" title="总线锁和缓存一致性协议"></a>总线锁和缓存一致性协议</h1><p><code>lock#</code>是汇编指令。用lock会触发硬件缓存锁定机制。总线锁和缓存一致性协议。</p><blockquote><p>在IA-32架构中有描述以下文字：在修改内存操作时，使用 LOCK 前缀去调用加锁的读-修改-写操作(原子的)。这种机制用于多处理器系统中处理器之间进行可靠的通讯，具体描述如下：在 Pentium 和早期的 IA-32 处理器中，LOCK 前缀会使处理器执行当前指令时产生一个 LOCK#信号，这总是引起显式总线锁定出现</p></blockquote><h2 id="总线锁"><a href="#总线锁" class="headerlink" title="总线锁"></a>总线锁</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;早期技术比较落后，cpu多核操作主内存，会发生线程安全问题，然后会加一个总线锁来解决线程安全。如果一个cpu要操作数据，首先先获取总线锁。然后再去操作数据。但是这样的效率非常低，一个cpu拿到总线锁，另外的cpu就只能等待。发挥不了多核的能力。</p><blockquote><p>这里要引申下，现在还是用到总线锁，是在mesi操作不了的时候才采用总线锁，那么什么是mesi操作不了，那接下来看下mesi。<br>这里还是解释下，由于cpu数据是放在cache line里的，如果锁不住cache line。就只能是用总线锁。（什么情况下锁不住cache line，使用多个cache line，多个cache line不是原子操作）</p></blockquote><h2 id="缓存一致性协议（MESI）"><a href="#缓存一致性协议（MESI）" class="headerlink" title="缓存一致性协议（MESI）"></a>缓存一致性协议（MESI）</h2><p>现在的处理器都是多核处理器，并且每个核都带有多个缓存（指令缓存和数据缓存，见下图）。为什么需要缓存呢，这是因为CPU访问内存的速度比较慢，所以在CPU和内存之间加了个缓存以提高访问速度。既然每个核都有缓存，那么假设两个核或者多个核同时访问同一个变量时这些缓存是如何进行同步的呢（缓存细分为一个个缓存行），这就有了MESI协议。MESI是指4个状态的首字母。每个cache line有4个状态。用两个2个bit表示。</p><table><thead><tr><th align="left">状态</th><th align="left">描述</th><th align="left">监听任务</th></tr></thead><tbody><tr><td align="left">M(修改)</td><td align="left"><b><font color='red'>该cache line有效，数据被修改了，和内存中的数据不一致，数据只存在本cache中</font></b></td><td align="left">缓存行必须时刻监听所有试图读该缓存行相对就主存的操作，这种操作必须在缓存将该缓存行写回主存并将状态变成S（共享）状态之前被延迟执行</td></tr><tr><td align="left">E(独享)</td><td align="left"><b><font color='red'>该Cache line有效，数据和内存中的数据一致，数据只存在于本Cache中。</font></b></td><td align="left">缓存行也必须监听其它缓存读主存中该缓存行的操作，一旦有这种操作，该缓存行需要变成S（共享）状态。</td></tr><tr><td align="left">S(共享)</td><td align="left"><b><font color='red'>该Cache line有效，数据和内存中的数据一致，数据存在于很多Cache中。</font></b></td><td align="left">缓存行也必须监听其它缓存使该缓存行无效或者独享该缓存行的请求，并将该缓存行变成无效（Invalid）。</td></tr><tr><td align="left">I(无效)</td><td align="left"><b><font color='red'>该Cache line无效。</font></b></td><td align="left">无</td></tr></tbody></table><blockquote><p>对于M和E状态而言总是精准的。他们在和该缓存行的真正状态是一致的，而S状态有可能是不一致的。如果一个缓存将处于S状态的缓存行作废了，而另一个缓存实际上可能已经独享了该缓存行，但是该缓存却不会将该缓存行升迁为E状态，这是因为其它缓存不会广播他们作废掉该缓存行的通知，同样由于缓存并没有保存该缓存行的copy的数量，因此（即使有这种通知）也没有办法确定自己是否已经独享了该缓存行。<br>从上面的意义看来E状态是一种投机性的优化：如果一个CPU想修改一个处于S状态的缓存行，总线事务需要将所有该缓存行的copy变成invalid状态，而修改E状态的缓存不需要使用总线事务。</p></blockquote><h3 id="MESI状态切换"><a href="#MESI状态切换" class="headerlink" title="MESI状态切换"></a>MESI状态切换</h3><p><img src="/images/pasted-41.png"><br>理解该图的前置说明：</p><ol><li>触发事件</li></ol><ul><li>本地读取(local read)-本地内核读取本地cache数据</li><li>本地写入(local write)-本地内核写入本地cache数据</li><li>远端读取(remote read)-其它内核读取其它Cache中的值</li><li>远端写入(remote write)-其他内核写入其他cache数据</li></ul><p>MESI状态扭转：</p><table>    <tr>        <th>当前状态</th>        <th>事件</th>        <th>行为</th>          <th>下一个状态</th>    </tr >    <tr >        <td rowspan="4">I</td>        <td>local read</td>        <td>如果其它Cache没有这份数据，本Cache从内存中取数据，Cache line状态变成E；          如果其它Cache有这份数据，且状态为M，则将数据更新到内存，本Cache再从内存中取数据，2个Cache 的Cache line状态都变成S；如果其它Cache有这份数据，且状态为S或者E，本Cache从内存中取数据，这些Cache 的Cache line状态都变成S</td>        <td>E/S</td>    </tr>    <tr>        <td>local write</td>        <td>从内存中取数据，在Cache中修改，状态变成M；          如果其它Cache有这份数据，且状态为M，则要先将数据更新到内存；          如果其它Cache有这份数据，则其它Cache的Cache line状态变成I</td>              <td>M</td>    </tr>    <tr>        <td>remote read</td>        <td>既然是Invalid，别的核的操作与它无关</td>              <td>I</td>    </tr>    <tr>        <td>remote write</td>        <td>既然是Invalid，别的核的操作与它无关</td>              <td>I</td>    </tr>  <tr >        <td rowspan="4">E</td>        <td>local read</td>        <td>从Cache中取数据，状态不变</td>        <td>E</td>    </tr>    <tr>        <td>local write</td>        <td>修改Cache中的数据，状态变成M</td>          <td>M</td>    </tr>    <tr>        <td>remote read</td>        <td>数据和其它核共用，状态变成了S</td>          <td>S</td>    </tr>    <tr>        <td>remote write</td>        <td>数据被修改，本Cache line不能再使用，状态变成I</td>          <td>I</td>    </tr>  <tr >        <td rowspan="4">S</td>        <td>local read</td>        <td>从Cache中取数据，状态不变</td>        <td>S</td>    </tr>    <tr>        <td>local write</td>        <td>修改Cache中的数据，状态变成M，其它核共享的Cache line状态变成I</td>          <td>M</td>    </tr>    <tr>        <td>remote read</td>        <td>状态不变</td>              <td>S</td>    </tr>    <tr>        <td>remote write</td>        <td>数据被修改，本Cache line不能再使用，状态变成I</td>          <td>I</td>    </tr>  <tr >        <td rowspan="4">M</td>        <td>local read</td>        <td>从Cache中取数据，状态不变</td>        <td>E</td>    </tr>    <tr>        <td>local write</td>        <td>修改Cache中的数据，状态不变</td>          <td>M</td>    </tr>    <tr>        <td>remote read</td>        <td>这行数据被写到内存中，使其它核能使用到最新的数据，状态变成S</td>          <td>S</td>    </tr>    <tr>        <td>remote write</td>        <td>这行数据被写到内存中，使其它核能使用到最新的数据，由于其它核会修改这行数据，状态变成I</td>          <td>I</td>    </tr></table><h4 id="Store-Buffer和Invalidate-Queue"><a href="#Store-Buffer和Invalidate-Queue" class="headerlink" title="Store Buffer和Invalidate Queue"></a>Store Buffer和Invalidate Queue</h4><p>CPU架构中传统的MESI协议中有两个行为的执行成本比较大。一个是将某个Cache Line标记为Invalid状态，另一个是当某Cache Line当前状态为Invalid时写入新的数据。所以CPU通过Store Buffer和Invalidate Queue组件来降低这类操作的延时。</p><p><img src="/images/pasted-37.png" alt="MESI"></p><blockquote><p>当一个核心在Invalid状态进行写入时，首先会给其它CPU核发送Invalid消息，然后把当前写入的数据写入到Store Buffer中。然后异步在某个时刻真正的写入到Cache Line中。当前CPU核如果要读Cache Line中的数据，需要先扫描Store Buffer之后再读取Cache Line（Store-Buffer Forwarding）。但是此时其它CPU核是看不到当前核的Store Buffer中的数据的，要等到Store Buffer中的数据被刷到了Cache Line之后才会触发失效操作。<br>而当一个CPU核收到Invalid消息时，会把消息写入自身的Invalidate Queue中，随后异步将其设为Invalid状态。和Store Buffer不同的是，当前CPU核心使用Cache时并不扫描Invalidate Queue部分，所以可能会有极短时间的脏读问题。这里的Store Buffer和Invalidate Queue的说法是针对一般的SMP架构来说的，不涉及具体架构。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;jvm整个执行过程&quot;&gt;&lt;a href=&quot;#jvm整个执行过程&quot; class=&quot;headerlink&quot; title=&quot;jvm整个执行过程&quot;&gt;&lt;/a&gt;jvm整个执行过程&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/images/pasted-39.png&quot; alt=&quot;jvm-</summary>
      
    
    
    
    <category term="并发" scheme="http://example.com/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="并发" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>JMM内存模型</title>
    <link href="http://example.com/2021/04/22/JMM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    <id>http://example.com/2021/04/22/JMM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</id>
    <published>2021-04-22T13:01:00.000Z</published>
    <updated>2021-07-06T15:00:15.402Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是JMM"><a href="#什么是JMM" class="headerlink" title="什么是JMM?"></a>什么是JMM?</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;Java 内存模型（Java Mermory Model）是一个抽象的概念，并不真实存在。它描述的是一种规范和准则，通过这组规范定义了程序中各个变量的访问方式。</b><font color='red'>它是描述的线程模型。</font></b>JVM运行程序的实体是线程，而每个线程创建时JVM都会为其创建一个工作内存，用户存储线程私有的数据，而Java内存模型中规定所有变量都存储在主内存，主内存是共享区域，所有线程都可以访问，但线程对变量的操作必须在工作内存中，其中首先会从主内存中变量复制到工作内存中，然后对变量进行操作后写会到主内存中。不同的工作线程无法通信，只能通过主内存来进行通信。</p><p><img src="/images/pasted-29.png" alt="java memory model"></p><h2 id="主内存"><a href="#主内存" class="headerlink" title="主内存"></a>主内存</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;主要存储的是java对象，所有线程创建的实例对象都存放在主内存，不管该实例对象是成员变量还是局部变量，还包括类信息、常量、静态变量。由于是共享区域，会发生线程安全问题。</p><h2 id="工作内存"><a href="#工作内存" class="headerlink" title="工作内存"></a>工作内存</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;主要存储当前方法的所有本地方法变量，存储的主内存的变量副本，每个线程只能访问自己的工作内存，线程间无法通信，工作内存不存在线程安全问题。</p><h1 id="JMM和jvm内存区域模型关系"><a href="#JMM和jvm内存区域模型关系" class="headerlink" title="JMM和jvm内存区域模型关系"></a>JMM和jvm内存区域模型关系</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;提起jvm内存模型，那就肯定有堆、栈、本地方法栈、方法区、程序计数器这些，他和jmm有相似之处，都有共享区域和私有区域，不同的地方是，jmm是描述的一个规范，通过这种规范来控制变量在共享区域和私有区域的访问方式，jmm围绕的还是原子性、可见性、有序性。</p><h1 id="JMM和硬件内存架构关系"><a href="#JMM和硬件内存架构关系" class="headerlink" title="JMM和硬件内存架构关系"></a>JMM和硬件内存架构关系</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;从前面可以了解到，多线程的执行还是会映射到硬件上，但是jmm和硬件内存架构并不完全一致。硬件内存架构只有寄存器、缓存内存、主内存的概念，并没有工作内存和主内存。对于硬件内存架构中数据存储在主内存、寄存器中。java内存模型和计算机硬件内存架构是一个相互交叉的关系，是一种抽象和真实物理硬件的交叉。</p><p><img src="/images/pasted-30.png" alt="jmm-&gt;硬件"></p><h1 id="JMM存在必要性"><a href="#JMM存在必要性" class="headerlink" title="JMM存在必要性"></a>JMM存在必要性</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;从下面这个问题，线程B读取的值到底是1还是2，工作内存读取主内存变量实现细节，jmm定义了八种操作来完成，来解决这类问题。<br><img src="/images/pasted-31.png" alt="jmm问题"></p><h2 id="数据同步八大原子操作"><a href="#数据同步八大原子操作" class="headerlink" title="数据同步八大原子操作"></a>数据同步八大原子操作</h2><ol><li>lock（锁定）：作用于主内存的变量，把一个变量标记为一条线程独占状态</li><li>unlock（解锁）：作用于主内存的变量，把一个变量处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定</li><li>read（读取）：作用于主内存的变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用</li><li>load（载入）：作用于工作内存的变量，他把read操作从主内存中得到的变量值放入工作内存的变量副本中</li><li>use（使用）：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎</li><li>assign（赋值）：作用于工作内存的变量，他把一个从执行引擎执行后的变量赋值给工作内存的变量</li><li>store（存储）：作用于工作内存的变量，把工作内存中的一个变量的值传递给主内存中，以便随后的write的操作</li><li>write（写入）：作用于工作内存的变量，它把store操作从工作内存中的一个变量的值传送到主内存的变量中</li></ol><p><img src="/images/pasted-32.png" alt="数据同步过程"></p><h2 id="同步规则分析"><a href="#同步规则分析" class="headerlink" title="同步规则分析"></a>同步规则分析</h2><ol><li>不允许一个线程无原因地把数据（没有经过任何assign操作）从工作内存同步到主内存中</li><li>一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化变量。</li><li>一个变量在同一时刻只允许一条线程对其进行lock操作，但lock操作可以被同一线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，才有可能被其他线程给获取。lock和unlock必须成对出现</li><li>如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量之前需要重新执行load或assign操作初始化变量的值</li><li>如果一个变量事先没有被lock操作锁定，则不允许对它执行unlock操作；也不允许去 unlock一个被其他线程锁定的变量。</li><li>对一个变量执行unlock操作之前，必须先把此变量同步到主内存中（执行store和write 操作）</li></ol><h1 id="三大特性问题"><a href="#三大特性问题" class="headerlink" title="三大特性问题"></a>三大特性问题</h1><h2 id="原子性问题"><a href="#原子性问题" class="headerlink" title="原子性问题"></a>原子性问题</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;原子性指的是一个操作是不可中断的，即使在多线程的环境下，一个操作一旦开始就不会被其他线程影响。在并发情况下可以使用synchronized关键字来解决原子性,<br>后面会着重讲解<font color='red'><b><code>synchronized</code>和<code>lock</code></b></font></p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="keyword">count</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Object o = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> run() &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;<span class="number">1000</span>; j++) &#123;</span><br><span class="line">                        <span class="keyword">synchronized</span> (o) &#123; <span class="comment">//一个线程只能进入一次</span></span><br><span class="line">                            <span class="keyword">count</span>++; <span class="comment">//不会发生指令重排</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(<span class="number">200</span>);</span><br><span class="line">        System.out.<span class="keyword">println</span>(<span class="keyword">count</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="可见性问题"><a href="#可见性问题" class="headerlink" title="可见性问题"></a>可见性问题</h2><p>下面这个会出现可见性问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> initFlag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">       <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               System.out.println(<span class="string">&quot;thread 1 start&quot;</span>);</span><br><span class="line">               <span class="keyword">while</span> (!initFlag)&#123;</span><br><span class="line">               &#125;</span><br><span class="line">               System.out.println(<span class="string">&quot;thread 1 stop&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;).start();</span><br><span class="line">       Thread.sleep(<span class="number">200</span>); <span class="comment">// 休眠</span></span><br><span class="line">       <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               System.out.println(<span class="string">&quot;thread 2 start&quot;</span>);</span><br><span class="line">               initFlag = <span class="keyword">true</span>;</span><br><span class="line">               System.out.println(<span class="string">&quot;thread 2 stop&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;).start();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>可见性解决方案，后面会着重讲解<font color='red'><b><code>volatile</code>和<code>synchronized</code></b></font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"># 第一种方案（<span class="keyword">volatile</span>可以解决可见性问题，通过MESI来控制）</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> initFlag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">       <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               System.out.println(<span class="string">&quot;thread 1 start&quot;</span>);</span><br><span class="line">               <span class="keyword">while</span> (!initFlag)&#123;</span><br><span class="line">               &#125;</span><br><span class="line">               System.out.println(<span class="string">&quot;thread 1 stop&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;).start();</span><br><span class="line">       Thread.sleep(<span class="number">200</span>); <span class="comment">// 休眠</span></span><br><span class="line">       <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               System.out.println(<span class="string">&quot;thread 2 start&quot;</span>);</span><br><span class="line">               initFlag = <span class="keyword">true</span>;</span><br><span class="line">               System.out.println(<span class="string">&quot;thread 2 stop&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;).start();</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   # 第二种方案（原因有可能是i和initFlag在一个cacheline上面，导致获取i的时候initFlag也读取到最新的）</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> initFlag = <span class="keyword">false</span>;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 如果换成int类型就不可以了</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> Integer i = <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">       <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               System.out.println(<span class="string">&quot;thread 1 start&quot;</span>);</span><br><span class="line">               <span class="keyword">while</span> (!initFlag)&#123;</span><br><span class="line">               i++;</span><br><span class="line">               &#125;</span><br><span class="line">               System.out.println(<span class="string">&quot;thread 1 stop&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;).start();</span><br><span class="line">       Thread.sleep(<span class="number">200</span>); <span class="comment">// 休眠</span></span><br><span class="line">       <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               System.out.println(<span class="string">&quot;thread 2 start&quot;</span>);</span><br><span class="line">               initFlag = <span class="keyword">true</span>;</span><br><span class="line">               System.out.println(<span class="string">&quot;thread 2 stop&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;).start();</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   # 第三种方案（原因有可能是i和initFlag在一个cacheline上面，导致获取i的时候initFlag也读取到最新的）</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> initFlag = <span class="keyword">false</span>;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">       <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               System.out.println(<span class="string">&quot;thread 1 start&quot;</span>);</span><br><span class="line">               <span class="keyword">while</span> (!initFlag)&#123;</span><br><span class="line">               i++;</span><br><span class="line">               &#125;</span><br><span class="line">               System.out.println(<span class="string">&quot;thread 1 stop&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;).start();</span><br><span class="line">       Thread.sleep(<span class="number">200</span>); <span class="comment">// 休眠</span></span><br><span class="line">       <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               System.out.println(<span class="string">&quot;thread 2 start&quot;</span>);</span><br><span class="line">               initFlag = <span class="keyword">true</span>;</span><br><span class="line">               System.out.println(<span class="string">&quot;thread 2 stop&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;).start();</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   # 第四种方案（为什么加上sout就会可以，因为空循环的优先级非常高，一旦获取cpu，很难切换时间片的）</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> initFlag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">       <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               System.out.println(<span class="string">&quot;thread 1 start&quot;</span>);</span><br><span class="line">               <span class="keyword">while</span> (!initFlag)&#123;</span><br><span class="line">System.out.println(<span class="number">111</span>);</span><br><span class="line">               &#125;</span><br><span class="line">               System.out.println(<span class="string">&quot;thread 1 stop&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;).start();</span><br><span class="line">       Thread.sleep(<span class="number">200</span>); <span class="comment">// 休眠</span></span><br><span class="line">       <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               System.out.println(<span class="string">&quot;thread 2 start&quot;</span>);</span><br><span class="line">               initFlag = <span class="keyword">true</span>;</span><br><span class="line">               System.out.println(<span class="string">&quot;thread 2 stop&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;).start();</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   # 第五种方案（jvm 增加-Djava.compiler=NONE 这是关掉jvm jit编译，jit编译优化是：编译过一次，下次再执行的时候就不用再次编译了，类似于<span class="keyword">for</span>循环，就非常好）</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> initFlag = <span class="keyword">false</span>;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 注意这里是int类型</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">       <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               System.out.println(<span class="string">&quot;thread 1 start&quot;</span>);</span><br><span class="line">               <span class="keyword">while</span> (!initFlag)&#123;</span><br><span class="line">               i++;</span><br><span class="line">               &#125;</span><br><span class="line">               System.out.println(<span class="string">&quot;thread 1 stop&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;).start();</span><br><span class="line">       Thread.sleep(<span class="number">200</span>); <span class="comment">// 休眠</span></span><br><span class="line">       <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               System.out.println(<span class="string">&quot;thread 2 start&quot;</span>);</span><br><span class="line">               initFlag = <span class="keyword">true</span>;</span><br><span class="line">               System.out.println(<span class="string">&quot;thread 2 stop&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;).start();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="有序性问题"><a href="#有序性问题" class="headerlink" title="有序性问题"></a>有序性问题</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Integer x, y = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Integer a, b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;)&#123;</span><br><span class="line">            i++;</span><br><span class="line">            x=<span class="number">0</span>;y=<span class="number">0</span>;</span><br><span class="line">            a=<span class="number">0</span>;b=<span class="number">0</span>;</span><br><span class="line">            Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="comment">// 等待</span></span><br><span class="line">                    sleep();</span><br><span class="line">                    a = <span class="number">1</span>;</span><br><span class="line">                    x = b;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="comment">// 等待</span></span><br><span class="line">                    sleep();</span><br><span class="line">                    b = <span class="number">1</span>;</span><br><span class="line">                    y = a;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            t1.start();</span><br><span class="line">            t2.start();</span><br><span class="line">            t1.join();</span><br><span class="line">            t2.join();</span><br><span class="line">            <span class="keyword">if</span>(x ==<span class="number">0</span> &amp;&amp; y ==<span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;第&quot;</span>+i+<span class="string">&quot;次&quot;</span>+<span class="string">&quot;,x=&quot;</span>+x+<span class="string">&quot;,y=&quot;</span>+y);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;第&quot;</span>+i+<span class="string">&quot;次&quot;</span>+<span class="string">&quot;,x=&quot;</span>+x+<span class="string">&quot;,y=&quot;</span>+y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>当x和y都是0的时候就发生指令重排，可以通过<font color='red'><b><code>volatile</code></b></font>来解决。<br><img src="/images/pasted-33.png" alt="分析"></p><h3 id="happens-before原则"><a href="#happens-before原则" class="headerlink" title="happens-before原则"></a>happens-before原则</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;每个线程都有自己的工作内存。每个线程对变量的操作都必须在工作内存中进行，而不是直接对主内存进行操作。并且每个线程不能访问其他线程的工作内存。在java内存模型中存在一些先天的“有序性”，即不需要通过任何手段就能够得到程序的有序性。这个就是happens-before原则。如果两个操作无法从happens-before原则推导出来，那么他们就不能保证有序性。<br>那happens-before原则原则就是如下：</p><ol><li>程序顺序原则，即在一个线程内必须保证语义串行性，也就是说按照代码顺序执行。</li><li>锁规则 解锁(unlock)操作必然发生在后续的同一个锁的加锁(lock)之前，也就是说，如果对于一个锁解锁后，再加锁，那么加锁的动作必须在解锁动作之后(同一个 锁)。 </li><li>volatile规则 volatile变量的写，先发生于读，这保证了volatile变量的可见性，简 单的理解就是，volatile变量在每次被线程访问时，都强迫从主内存中读该变量的 值，而当该变量发生变化时，又会强迫将最新的值刷新到主内存，任何时刻，不同的 线程总是能够看到该变量的最新值。 4. 线程启动规则 线程的start()方法先于它的每一个动作，即如果线程A在执行线程B 的start方法之前修改了共享变量的值，那么当线程B执行start方法时，线程A对共享 变量的修改对线程B可见 </li><li>传递性 A先于B ，B先于C 那么A必然先于C </li><li>线程终止规则 线程的所有操作先于线程的终结，Thread.join()方法的作用是等待 当前执行的线程终止。假设在线程B终止之前，修改了共享变量，线程A从线程B的 join方法成功返回后，线程B对共享变量的修改将对线程A可见。 </li><li>线程中断规则 对线程 interrupt()方法的调用先行发生于被中断线程的代码检测到 中断事件的发生，可以通过Thread.interrupted()方法检测线程是否中断。 </li><li>对象终结规则对象的构造函数执行，结束先于finalize()方法</li></ol><h3 id="指令重排"><a href="#指令重排" class="headerlink" title="指令重排"></a>指令重排</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;java语言规范规定jvm线程内部维持顺序化语义。即只要程序的最终结果与它顺序的结果相等，那么指令的执行顺序可以与代码顺序不一致，此过程叫指令的重排序。指令重排的意义在哪？jvm能够根据处理器的特性（CPU多级缓存、多核处理器等）适当对机器指令进行重排序，是机器指令能更符合CPU的执行特性，最大限度发挥机器性能。</p><p><img src="/images/pasted-36.png" alt="指令优化"></p><h3 id="as-if-serial语义"><a href="#as-if-serial语义" class="headerlink" title="as-if-serial语义"></a>as-if-serial语义</h3><p>不管怎么重排序（编译器和处理器为了提高并行度），（单线程下）程序的执行结果不能被改变。编译器，runtime 和处理器都必须遵守as-if-serial语义。</p><h2 id="volatile语义"><a href="#volatile语义" class="headerlink" title="volatile语义"></a>volatile语义</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;volatile是java虚拟机提供的轻量级的同步机制。有两个作用：</p><ol><li>可见性，一个被volatile变量修改会被其他线程感知到</li><li>有序性，通过内存屏障，禁止指令重排</li><li>无法保证原子性，参照下面的代码，并发情况下，执行incr方法会线程安全问题，可以通过<code>synchronized</code>解决。其中<code>synchronized</code>本身也具有可见性，故不用<code>volatile</code>修饰</li></ol><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Interger counter = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">incr</span><span class="params">()</span></span>&#123;</span><br><span class="line">counter++; <span class="comment">// 不会发生指令重排，但是不是原子性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里引申下，dcl（双重检测锁）在并发情况下，会有线程问题，细节不过多展示，那这里需要加入<code>volatile</code>，这里<code>volatile</code>和<code>synchronized</code>都必须在，因为不加<code>volatile</code>,这里<code>instance = new Instance()</code>会发生指令重排，会出现线程问题</p></blockquote><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private<span class="keyword"> static</span> Instance instance;</span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">public</span><span class="keyword"> static</span> Instance getInstance()&#123;</span><br><span class="line">if(instance == null)&#123;</span><br><span class="line">    synchronized(Instance.class)&#123;</span><br><span class="line">        if(instance == null)&#123;</span><br><span class="line">            <span class="built_in">instance </span>=<span class="built_in"> new </span>Instance();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="volatile禁止重排优化"><a href="#volatile禁止重排优化" class="headerlink" title="volatile禁止重排优化"></a>volatile禁止重排优化</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;要说明<code>volatile</code>禁止重排，这里就的引入一个名词<b><font color='red'>内存屏障（memory barrier）</font></b>。</p><h4 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h4><p>是一个cpu指令。jvm有四个内存屏障指令。</p><table><thead><tr><th align="left">屏蔽类型</th><th align="left">指令实例</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">LoadLoad</td><td align="left">Load1;LoadLoad;Load2</td><td align="left">保证Load1的读取操作在Load2之前</td></tr><tr><td align="left">StoreStore</td><td align="left">Store1;StoreStore;Store2</td><td align="left">在Store2及其后的写操作执行前，保证Store1的写操作已刷新到主内存</td></tr><tr><td align="left">LoadStore</td><td align="left">Load1;LoadStore;Store2;</td><td align="left">在Store2及其后的写操作执行前，保证Load1的读操作是正确数据</td></tr><tr><td align="left">StoreLoad</td><td align="left">Store1;StoreLoad;Load2</td><td align="left">保证Store1的写操作已刷新内存，Load2读取数据是正确数据</td></tr></tbody></table><h5 id="编译器屏障（Compiler-Barrior）"><a href="#编译器屏障（Compiler-Barrior）" class="headerlink" title="编译器屏障（Compiler Barrior）"></a>编译器屏障（Compiler Barrior）</h5><p>阻止编译器重排，保证编译程序时在优化屏障之前的指令不会在优化屏障之后执行。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* The &quot;volatile&quot; is due to gcc bugs */</span></span><br><span class="line"><span class="selector-id">#define</span> <span class="selector-tag">barrier</span>() <span class="selector-tag">__asm__</span> <span class="selector-tag">__volatile__</span>(<span class="string">&quot;&quot;</span>: : :<span class="string">&quot;memory&quot;</span>) </span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="CPU屏障（Cpu-Barrior）"><a href="#CPU屏障（Cpu-Barrior）" class="headerlink" title="CPU屏障（Cpu Barrior）"></a>CPU屏障（Cpu Barrior）</h5><ol><li>作用：<ol><li>防止指令重排序</li><li>保证数据可见性</li></ol></li><li>分类：<ol><li>lfence，是一种Load Barrior 读屏障，会将invalidate queue失效，强制读取L1 Cache中，而且lfence之后的读操作不会被调度到之前，即lfence的读操作一定在lfence完成（并未规定全局可见性）；</li><li>sfence，是一种save Barrior 写屏障，会将store buffer中缓存的修改刷入L1 Cache中，使得其他cpu核可以观察到这些变化，而且之后的写操作不会被调度到之前，即sfence之前的写操作一定在sfence完成且全局可见</li><li>mfence，是一种全能型屏障，具备lfence和sfence的能力，同时刷新store buffer和invalidate queue，保证了mfence前后的读写操作的顺序，同时要求mfence之后写操作结果全局可见之前，mfence之前写操作全局可见</li></ol></li></ol><blockquote><p>cpu屏障也包含指令<b>lock前缀</b>，lock不是一种内存屏障，但是它能完成类似内存屏障的功能。lock会对cpu总线和高速缓存加锁，可以理解为cpu指令级的一种锁。会让指令操作原子化，而且自带mfence效果。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;<b>X86-64一般情况根本不会需要使用lfence与sfence这两个指令，除非操作Write-Through内存或使用 non-temporal 指令（NT指令，属于SSE指令集），比如movntdq, movnti, maskmovq，这些指令也使用Write-Through内存策略，通常使用在图形学或视频处理，Linux编程里就需要使用GNC提供的专门的函数，下面是GNU中的三种内存屏障定义方法，下面是结合编译器屏障和CPU指令屏障。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#define</span> <span class="selector-tag">lfence</span>() <span class="selector-tag">__asm__</span> <span class="selector-tag">__volatile__</span>(<span class="string">&quot;lfence&quot;</span>: : :<span class="string">&quot;memory&quot;</span>) </span><br><span class="line"><span class="selector-id">#define</span> <span class="selector-tag">sfence</span>() <span class="selector-tag">__asm__</span> <span class="selector-tag">__volatile__</span>(<span class="string">&quot;sfence&quot;</span>: : :<span class="string">&quot;memory&quot;</span>) </span><br><span class="line"><span class="selector-id">#define</span> <span class="selector-tag">mfence</span>() <span class="selector-tag">__asm__</span> <span class="selector-tag">__volatile__</span>(<span class="string">&quot;mfence&quot;</span>: : :<span class="string">&quot;memory&quot;</span>) </span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;代码中仍然使用lfence()与sfence()这两个内存屏障应该也是一种长远的考虑。按照Interface写代码是最保险的，万一Intel以后出一个采用弱一致模型的CPU，遗留代码出问题就不好了。目前在X86下面视为编译器屏障即可。</b></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># java通过魔术类来加内存屏障</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line">unsafe.loadFence();</span><br><span class="line">unsafe.storeFence();</span><br><span class="line">unsafe.fullFence();</span><br></pre></td></tr></table></figure><blockquote><p>下面这里有一个典型的使用内存屏障的例子（DCL）</p></blockquote><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> A a= <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function">A <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (双重检查锁.class)&#123;</span><br><span class="line">                a = <span class="keyword">new</span> A(); <span class="comment">// 多线程可能会出现问题的地方</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>为什么在多线程的场景下a = new A();会出现问题？<br>其实这里不是原子操作，有分为下面三步；</p><ol><li>分配对象内存空间 memory = allocate();</li><li>初始化对象     instance(memory);</li><li>设置instance的对象指向刚分配的内存空间instance = memory;</li></ol></blockquote><blockquote><p><font color='red'><b>由于第二步和第三步没有依赖关系，是可以重排的。重排后再单线程结果是没有改变的，所有这种重排是可以允许的。指令重排只会保证串行语义的执行的一致性(单线程)，但并不会关心多线程间的语义一致性。所以当一个线程访问instance对象不为null时，虽然是不为空的，但是执行方法时就会报错，对象没有实例化完成。解决重排通过加上<code>volatile</code>就可以解决。</b></font></p></blockquote><h4 id="volatile内存语义的实现"><a href="#volatile内存语义的实现" class="headerlink" title="volatile内存语义的实现"></a>volatile内存语义的实现</h4><p>编译器制定的volatile重排序规则表</p><table><thead><tr><th align="center"></th><th align="center">第二个操作：普通读写</th><th align="center">第二个操作：volatile读</th><th align="center"><font color='red'>第二个操作：volatile写</font></th></tr></thead><tbody><tr><td align="center">第一个操作：普通读写</td><td align="center">可以</td><td align="center">可以</td><td align="center">不可以</td></tr><tr><td align="center"><font color='red'><b>第一个操作：volatile读</b></font></td><td align="center">不可以</td><td align="center">不可以</td><td align="center">不可以</td></tr><tr><td align="center">第一个操作：volatile写</td><td align="center">可以</td><td align="center">不可以</td><td align="center">不可以</td></tr></tbody></table><ul><li>其中第一个操作：volatile读，都不可以重排</li><li>其中第二个操作：volatile写，都不可以重排</li><li>其中第一个操作：volatile写，第二个操作：volatile读，都不可以重排</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;为了实现volatile的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。对于编译器来说，发现一个最优布置来最小化插入屏障的总数几乎不可能。为此，JMM采取保守策略。下面是基于保守策略的JMM内存屏障插入策 略。</p><ul><li>在每个volatile写操作的前面插入一个StoreStore屏障。</li><li>在每个volatile写操作的后面插入一个StoreLoad屏障。 </li><li>在每个volatile读操作的后面插入一个LoadLoad屏障</li><li>在每个volatile读操作的后面插入一个LoadStore屏障</li></ul><p>这里举一个来说明</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a;</span><br><span class="line">   <span class="keyword">volatile</span> <span class="keyword">int</span> v1 = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">volatile</span> <span class="keyword">int</span> v2 = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">readAndWrite</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="keyword">int</span> i = v1; <span class="comment">// 第一个volatile读</span></span><br><span class="line">       <span class="keyword">int</span> j = v2; <span class="comment">// 第二个volatile读</span></span><br><span class="line">       a = i+j;    <span class="comment">// 普通写</span></span><br><span class="line">       v1 = i + <span class="number">1</span>; <span class="comment">// 第一个volatile写</span></span><br><span class="line">       v2 = j * <span class="number">2</span>; <span class="comment">// 第二个volatile写</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>针对readAndWrite方法，编译器在字节码会做如下的优化，见下面的解释就可以会很清楚了。<br><img src="/images/pasted-38.png" alt="内存屏障优化"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;什么是JMM&quot;&gt;&lt;a href=&quot;#什么是JMM&quot; class=&quot;headerlink&quot; title=&quot;什么是JMM?&quot;&gt;&lt;/a&gt;什么是JMM?&lt;/h1&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Java 内存模型（Java Mermory Model</summary>
      
    
    
    
    <category term="并发" scheme="http://example.com/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="并发" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>操作系统的底层认识</title>
    <link href="http://example.com/2021/04/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%BA%95%E5%B1%82%E8%AE%A4%E8%AF%86/"/>
    <id>http://example.com/2021/04/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%BA%95%E5%B1%82%E8%AE%A4%E8%AF%86/</id>
    <published>2021-04-20T04:31:00.000Z</published>
    <updated>2021-07-06T15:00:15.390Z</updated>
    
    <content type="html"><![CDATA[<h1 id="冯诺依曼计算机模型"><a href="#冯诺依曼计算机模型" class="headerlink" title="冯诺依曼计算机模型"></a>冯诺依曼计算机模型</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;现在计算机模型都是基于-<font color='red'><b>冯诺依曼计算机模型</b></font><br>&nbsp;&nbsp;&nbsp;&nbsp;计算机在运行时，先从内存中取出第一条指令，通过控制器的译码，按指令的要求，从存储器中取出数据进行指定的运算和逻辑操作等加工，然后再按地址把结果送到内存中。接下来，再取出第二条指令，在控制器的指挥下完成规定操作，依次进行下去。直至遇到停止指令。<br>&nbsp;&nbsp;&nbsp;&nbsp;程序与数据一样存储，按程序编排的顺序，一步一步的取出指令，自动完成指令规定的操作是计算机最基本的工作模型。这个就是冯.诺依曼计算机模型。</p><p><img src="/images/pasted-20.png" alt="冯诺依曼计算机模型"></p><h2 id="计算机五大核心组成部分"><a href="#计算机五大核心组成部分" class="headerlink" title="计算机五大核心组成部分"></a>计算机五大核心组成部分</h2><ol><li>控制器(control)：是整个计算机的中枢神经，其功能是对程序规定的控制信息进行解释，根据其要求进行控制，调度程序、数据、地址，协调计算机各部分工作及内存与外设的访问等。</li><li>运算器(Datapath)：对数据进行各种算数运算和逻辑运算，即对数据进行加工</li><li>存储器(Memory)：存储器的功能是存储程序、数据和各种信号、命令等信息，并在需要时提供这些信息。</li><li>输入(Input system)：输入设备是计算机的重要组成部分，输入设备与输出设备合你 为外部设备，简称外设，输入设备的作用是将程序、原始数据、文字、字符、控制命令或现 场采集的数据等信息输入到计算机。常见的输入设备有键盘、鼠标器、光电输入机、磁带 机、磁盘机、光盘机等。</li><li>输出(Output system)：输出设备与输入设备同样是计算机的重要组成部分，它把外 算机的中间结果或最后结果、机内的各种数据符号及文字或各种控制信号等信息输出出来。 微机常用的输出设备有显示终端CRT、打印机、激光印字机、绘图仪及磁带、光盘机等。</li></ol><h2 id="现代计算机模型"><a href="#现代计算机模型" class="headerlink" title="现代计算机模型"></a>现代计算机模型</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;现在的计算机就是通过冯诺依曼计算机模型来应用出来的，见下图。其中我们最主要是关心CPU和内存。</p><p><img src="/images/pasted-21.png" alt="现代计算机模型"></p><h2 id="cpu指令结构"><a href="#cpu指令结构" class="headerlink" title="cpu指令结构"></a>cpu指令结构</h2><p>cpu内部结构</p><ul><li>控制单元<ul><li>控制单元是整个CPU的指挥控制中心，由指令寄存器IR（Instruction Register）、指 令译码器ID（Instruction Decoder）和 操作控制器OC（Operation Controller） 等组 成，对协调整个电脑有序工作极为重要。它根据用户预先编好的程序，依次从存储器中取出 各条指令，放在指令寄存器IR中，通过指令译码（分析）确定应该进行什么操作，然后通过 操作控制器OC，按确定的时序，向相应的部件发出微操作控制信号。操作控制器OC中主要 包括：节拍脉冲发生器、控制矩阵、时钟脉冲发生器、复位电路和启停电路等控制逻辑。</li></ul></li><li>运算单元<ul><li>运算单元是运算器的核心。可以执行算术运算（包括加减乘数等基本运算及其附加运 算）和逻辑运算（包括移位、逻辑测试或两个值比较）。相对控制单元而言，运算器接受控 制单元的命令而进行动作，即运算单元所进行的全部操作都是由控制单元发出的控制信号来 指挥的，所以它是执行部件。</li></ul></li><li>数据单元<ul><li>存储单元包括 CPU 片内缓存Cache和寄存器组，是 CPU 中暂时存放数据的地方，里 面保存着那些等待处理的数据，或已经处理过的数据，CPU 访问寄存器所用的时间要比访 问内存的时间短。 寄存器是CPU内部的元件，寄存器拥有非常高的读写速度，所以在寄存 器之间的数据传送非常快。采用寄存器，可以减少 CPU 访问内存的次数，从而提高了 CPU 的工作速度。寄存器组可分为专用寄存器和通用寄存器。专用寄存器的作用是固定的，分别 寄存相应的数据；而通用寄存器用途广泛并可由程序员规定其用途。</li></ul></li></ul><p><img src="/images/pasted-22.png" alt="cpu内部结构"></p><h2 id="CPU缓存结构"><a href="#CPU缓存结构" class="headerlink" title="CPU缓存结构"></a>CPU缓存结构</h2><p>现在CPU为了提升执行效率，减少cpu与内存的交互，一般在CPU设置多级缓存</p><ul><li>L1 cache，分为指令缓存和数据缓存，逻辑核独占</li><li>L2 cache，物理核独占，逻辑核共享</li><li>L3 cache，所有物理核共享<blockquote><p>物理核：可以看的到的，真实的cpu核<br>逻辑核：在同一个物理核内，逻辑层面的核。<br>超线程：超线程可以在一个逻辑核等待指令执行的间隔(等待从cache或内存中获取下一条指令)，把时间片分配到另一个逻辑核。高速在这两个逻辑核之间切换，让应用程序感知不到这个间隔，误认为自己是独占了一个核。<br><font color='red'></b>一个CPU有多个物理核，如果开启了超线程，一个物理核可以分成n个逻辑核，n为超线程的数量。<br>其中一台机器可以有多个CPU，但是CPU之前的缓存是不共享的</b></font><br>Runtime.getRuntime().availableProcessors()是逻辑核数</p></blockquote></li></ul><p><img src="/images/pasted-23.png" alt="cpu缓存结构"></p><ul><li>存储器的大小：内存&gt;L3&gt;L2&gt;L1&gt;寄存器</li><li>存储器速度快慢排序：寄存器&gt;L1&gt;L2&gt;L3&gt;内存</li><li>缓存最小的存储单位是-缓存行(cache line)，缓存大小默认64Byte，如果对象大小大于64Byte，可以采用多个缓存行存储</li></ul><h3 id="CPU读取存储器数据的过程"><a href="#CPU读取存储器数据的过程" class="headerlink" title="CPU读取存储器数据的过程"></a>CPU读取存储器数据的过程</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">1</span>. CPU要取寄存器X的值，直接读取寄存器</span><br><span class="line"><span class="attribute">2</span>. CPU要取L<span class="number">1</span> cache的某个值，把cacheline锁住，把数据拿来，解锁。没有锁住就慢了</span><br><span class="line"><span class="attribute">3</span>. CPU要取L<span class="number">2</span> cache的某个值，L<span class="number">2</span>开始加锁，加锁以后把数据复制到L<span class="number">1</span>，执行上面的L<span class="number">1</span>的步骤，再解锁</span><br><span class="line"><span class="attribute">4</span>. CPU要取L<span class="number">3</span> cache的某个值，L<span class="number">3</span>复制到L<span class="number">2</span>，L<span class="number">2</span>复制到L<span class="number">1</span>，L<span class="number">1</span>复制寄存器</span><br><span class="line"><span class="attribute">5</span>. CPU要取内存中的数据，通知内存控制器占用总线带宽，通知内存加锁，发起内存读请求，等待回应，回应数据保存，复制到L<span class="number">3</span>，然后复制到L<span class="number">2</span>，然后复制到L<span class="number">1</span>，最后复制到寄存器，之后解除总线锁定</span><br></pre></td></tr></table></figure><h3 id="CPU为何有一个高速缓存"><a href="#CPU为何有一个高速缓存" class="headerlink" title="CPU为何有一个高速缓存"></a>CPU为何有一个高速缓存</h3><p>CPU在摩尔定律指导下，每18个月翻一番的速度，而内存和硬盘速度远不及CPU速度。为了解决这个问题，CPU中内置了少量的高速缓存以解决I/o速度和CPU运算速度之间的不匹配问题。在CPU访问存储设备时，无论是存储数据或者指令，都趋于一片连续的区域中，这就叫做局部性原则</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">时间局部性：如果一个信息正在被访问，那么近期它很有可能还会被访问。比如循环、递归、方法的反复调用等。</span><br><span class="line">空间局部性：如果一个存储器的位置被引用，那么将来它附近的位置也会被引用。比如顺序执行的代码、连续创建的两个对象、数组等。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>空间局部性的例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"># first 比 second方式快一点，是因为再引用数组位置时，它附近的位置也引用了，导致会快一点</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNS = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> rows = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> cols = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Long[][] data = <span class="keyword">new</span> Long[rows][cols];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++) &#123;</span><br><span class="line">                data[i][j] = <span class="number">1L</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;first&quot;</span>);</span><br><span class="line">        <span class="keyword">long</span> first = System.currentTimeMillis();</span><br><span class="line">        Long firstNum = <span class="number">0L</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; RUNS; r++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++) &#123;</span><br><span class="line">                    firstNum += data[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;firstNum=&quot;</span>+firstNum);</span><br><span class="line">        System.out.println(<span class="string">&quot;first =&quot;</span>+(System.currentTimeMillis()-first)); <span class="comment">//2700</span></span><br><span class="line">        System.out.println(<span class="string">&quot;second&quot;</span>);</span><br><span class="line">        <span class="keyword">long</span> second = System.currentTimeMillis();</span><br><span class="line">        Long secondNum = <span class="number">0L</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; RUNS; r++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cols; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; rows; j++) &#123;</span><br><span class="line">                    secondNum += data[j][i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;secondNum=&quot;</span>+secondNum);</span><br><span class="line">        System.out.println(<span class="string">&quot;second =&quot;</span>+(System.currentTimeMillis()-second));  <span class="comment">// 3249</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="CPU运行安全等级"><a href="#CPU运行安全等级" class="headerlink" title="CPU运行安全等级"></a>CPU运行安全等级</h3><ul><li>ring0<ul><li>操作系统内部的指令</li></ul></li><li>rong1<ul><li>没有使用</li></ul></li><li>rong2<ul><li>没有使用</li></ul></li><li>rong3<ul><li>用户程序的指令<blockquote><p>JVM创建线程，线程阻塞唤醒是重型操作了，因为CPU要切换运行状态</p></blockquote></li></ul></li></ul><p>例子：JVM创建线程CPU的过程</p><blockquote><ol><li>CPU从ring3切换到ring0，创建线程，调用p_thread库</li><li>线程创建完成后，CPU从ring0切换到ring3</li><li>执行java程序</li><li>CPU从ring3切换到ring0，销毁</li></ol></blockquote><h1 id="操作系统内存管理"><a href="#操作系统内存管理" class="headerlink" title="操作系统内存管理"></a>操作系统内存管理</h1><h2 id="执行空间保护"><a href="#执行空间保护" class="headerlink" title="执行空间保护"></a>执行空间保护</h2><p>操作系统有用户空间与系统空间两个概念，目的也是为了做到程序运行安全隔离与稳定，以32位4G大小内存的空间来说。它的寻址地址为2^32个地址。<br><img src="/images/pasted-24.png" alt="内容空间"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;Linux为内核代码和数据结构预留了几个页框，这些页永远不会被转出到磁盘上。从0x00000000到0xC0000000（PAGE_OFFSET）的线性地址可由用户代码和内核代码进行引用（<font color='red'><b>用户空间</b></font>），从0xC0000000（PAGE_OFFSET）到0xFFFFFFFF的线性地址只能由内核代码进行访问（<font color='red'><b>内核空间</b></font>）。内核空间及其数据结构都必须位于在1GB的地址空间中，但是对于此地址空间而言，更大的消费者是物理地址虚拟映射。而3GB可以用于用户应用程序。<br>&nbsp;&nbsp;&nbsp;&nbsp;进程与线程只能运行在用户模式（user mode）与内核模式(kernel mode)下。用户程序运行在用户模式下，而系统调用运行在内核模式下。这两种使用的堆栈是不一样的。用户方式下用的是 一般的堆栈(用户空间的堆栈)，而内核方式下用的是固定大小的堆栈（内核空间的堆栈，一般为一个内存页的大小），即每个进程与线程其实有两个堆栈，分别运行与用户态与内核态。</p><h3 id="用户线程模型-ULT"><a href="#用户线程模型-ULT" class="headerlink" title="用户线程模型(ULT)"></a>用户线程模型(ULT)</h3><p>用户程序实现，不依赖系统内核，应用提供创建、同步、调度和管理线程的函数来创建用户线程。不需要用户态/内核态切换，速度快。内核对ULT无感知，线程阻塞则进程（包括它所有的线程）阻塞。</p><p><img src="/images/pasted-26.png" alt="用户线程模型"></p><h3 id="内核线程模型-KLT"><a href="#内核线程模型-KLT" class="headerlink" title="内核线程模型(KLT)"></a>内核线程模型(KLT)</h3><p>内核保存线程的状态和上下文信息，线程阻塞不会引起进程阻塞。在多处理器系统上，多线程在多处理器上并行运行。线程的创建、调度和管理由内核完成，效率比ULT慢，比进程效率快。</p><p><img src="/images/pasted-25.png" alt="内核线程模型"></p><blockquote><p>那JVM是什么线程模型呢？其实JVM是采用KLT。</p></blockquote><h1 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h1><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>现代操作系统在运行一个程序时，会为其创造一个进程。进程是OS资源分配的最小单元。像启动一个java程序，计算机就会启动一个进程。</p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>线程是OS调度CPU的最小单元。也叫做轻量级进程。在一个进程里可以有多个线程，这些线程都拥有各自的计数器、堆栈和局部变量表等属性。并且能够访问共享的内存变量。CPU在这些线程上高速切换，让使用者感觉到这些线程在同时执行，即并发的概念。</p><p><img src="/images/pasted-28.png" alt="线程上下文切换过程"></p><p><code>vmstat 1，其中cs就是上下文切换，上下文存放在TSS（Task State Segment）</code><br><img src="/images/pasted-27.png" alt="线程上下文切换"></p><h1 id="虚拟机指令集架构"><a href="#虚拟机指令集架构" class="headerlink" title="虚拟机指令集架构"></a>虚拟机指令集架构</h1><p>虚拟机指令集架构主要分为两种：</p><ol><li>栈指令集架构</li><li>寄存器指令集架构</li></ol><h2 id="栈指令集架构"><a href="#栈指令集架构" class="headerlink" title="栈指令集架构"></a>栈指令集架构</h2><ol><li>设计和实现更简单,适用于资源受限的系统; </li><li>避开了寄存器的分配难题:使用零地址指令方式分配; </li><li>指令流中的指令大部分是零地址指令,其执行过程依赖与操作栈,指令集更小,编译器 容易实现; </li><li>不需要硬件支持,可移植性更好,更好实现跨平台。</li></ol><h2 id="寄存器指令集架构"><a href="#寄存器指令集架构" class="headerlink" title="寄存器指令集架构"></a>寄存器指令集架构</h2><ol><li>典型的应用是x86的二进制指令集:比如传统的PC以及Android的Davlik虚拟机。 </li><li>指令集架构则完全依赖硬件,可移植性差。 </li><li>性能优秀和执行更高效。 </li><li>花费更少的指令去完成一项操作。 </li><li>在大部分情况下,基于寄存器架构的指令集往往都以一地址指令、二地址指令和三 地址指令为主,而基于栈式架构的指令集却是以零地址指令为主。</li></ol><blockquote><p>jvm是栈指令集架构，可移植性好</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;冯诺依曼计算机模型&quot;&gt;&lt;a href=&quot;#冯诺依曼计算机模型&quot; class=&quot;headerlink&quot; title=&quot;冯诺依曼计算机模型&quot;&gt;&lt;/a&gt;冯诺依曼计算机模型&lt;/h1&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;现在计算机模型都是基于-&lt;font </summary>
      
    
    
    
    <category term="并发" scheme="http://example.com/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="并发" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>内存分配与垃圾回收</title>
    <link href="http://example.com/2021/03/09/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    <id>http://example.com/2021/03/09/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</id>
    <published>2021-03-09T11:31:00.000Z</published>
    <updated>2021-07-06T15:00:15.393Z</updated>
    
    <content type="html"><![CDATA[<h1 id="jvm内存区域"><a href="#jvm内存区域" class="headerlink" title="jvm内存区域"></a>jvm内存区域</h1><p>之所以会选中jvm的内存区域划分为多个不同的内存区，是因为每一个独立的内存区都拥有各自的用途。<br>其中一部分的内存区域和jvm生命周期保持一致<br>另外一部分的内存区域和线程的生命周期保持一致</p><p><img src="/images/pasted-17.png" alt="jvm内存区域"></p><h1 id="线程共享内存区"><a href="#线程共享内存区" class="headerlink" title="线程共享内存区"></a>线程共享内存区</h1><p>允许被所有线程共享访问的一类内存区，包括堆区、方法区和运行时常量池三个内存区。</p><h2 id="堆区"><a href="#堆区" class="headerlink" title="堆区"></a>堆区</h2><p>堆（heap）,Java堆区在JVM启动的时候被创建，并且它在实际的内存空间中可以是不连续的。<br>堆（heap）区是一块用于存储对象实例的内存区，同时也是GC执行垃圾回收的重点区域，正式因为java堆区是GC重点回收区域，那么GC极有可能在大内存的使用和回收上成为性能瓶颈。</p><blockquote><p>为了解决问题，考虑是否一定需要将对象实例存储到Java堆区中。其中逃逸分析与栈上分配等优化技术同样也是降低GC回收频率与提升GC回收效率的方式。</p></blockquote><p>堆还分为新生代（YoungGen）和老年代（OldGen）,其中新生代也可以分为Eden空间、From Survivor空间和To Survivor空间。</p><p><img src="/images/pasted-18.png" alt="堆区的分代"></p><p><code>-Xmx</code>表示堆区最大内存<br><code>-Xms</code>表示堆区起始内存<br>一旦堆中的内存大小大于最大内存，就会抛出OutOfMemoryError异常</p><h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><table><thead><tr><th>jdk版本</th><th>方法区实现</th><th>运行时常量池位置</th><th>存储信息</th></tr></thead><tbody><tr><td>&lt;1.6</td><td>PermGen space（永久代）</td><td>PermGen space（永久代）</td><td>运行时常量池、变量、字段和方法数据、构造函数和普通方法的字节码内容、类和实例和接口初始化需要用到的特殊方法等数据</td></tr><tr><td>1.7</td><td>PermGen space（永久代）</td><td>Heap（堆）</td><td>Heap（堆）</td></tr><tr><td>1.8</td><td>Metaspace（元空间）</td><td>Heap（堆）</td><td>Heap（堆）</td></tr></tbody></table><p>由于主流的jdk版本采用的是1.8版本，这里我们主要介绍jdk1.8版本方法区<br>元空间（Metaspace），是方法区的一种实现，其中元空间是属于本地内存中的，之前的方法区的实现是存储在堆中。然后元空间存储类的元信息，而静态变量和常量池都并入堆中。</p><h3 id="Jvm常量池"><a href="#Jvm常量池" class="headerlink" title="Jvm常量池"></a>Jvm常量池</h3><h4 id="Class文件常量池"><a href="#Class文件常量池" class="headerlink" title="Class文件常量池"></a>Class文件常量池</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JavaBean</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> value = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> String s = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> f = <span class="number">0x101</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> temp = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">this</span>.value = temp + v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>编写.java文件编译为.class文件格式的二进制数据存放在磁盘中</li><li>非运行时常量池，在编译阶段以及确定</li><li>Class文件常量池存放<b>字面量</b>和<b>符号引用</b><ul><li>字面量<ul><li>第一种存储是文本字符串<pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#<span class="number">9</span> = Utf8               s</span><br><span class="line">#<span class="number">3</span> = String             #<span class="number">31</span>            <span class="comment">// abc</span></span><br><span class="line">#<span class="number">31</span> = Utf8              abc</span><br></pre></td></tr></table></figure></code></pre></li><li>第二种存储用final修饰的成员变量，包括静态变量、实例变量和局部变量           <pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#<span class="number">11</span> = Utf8               f</span><br><span class="line">#<span class="number">12</span> = Utf8               ConstantValue</span><br><span class="line">#<span class="number">13</span> = Integer            <span class="number">257</span></span><br></pre></td></tr></table></figure></code></pre></li><li>这里说明下，存在常量池的字面量，指的是数据的值，也就是<code>abc</code>和<code>0x101(257)</code>，通过对常量池的观察可知这两个字面量是确实存在于常量池的。而对于基本数据类型，也就是上面的<code>private int value = 1</code>，常量池只保留他的字段描述符<code>I(1反编译出来的结果)</code>和字段的名称<code>value</code>，他们的字面量不会存在于常量池中</li></ul></li><li>符号引用<ul><li>类和接口的全限定名，也就是<code>Ljava/lang/String;</code>这样，主要用于在运行时解析得到类的直接引用</li><li>字段的名称和描述符，字段也就是类或者接口中声明的变量，包括类级别变量（static）和实例级的变量</li><li>方法的名称和修饰符，也就是参数类型+返回值类型        </li></ul></li></ul></li></ul><h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><p>运行时常量池是方法区的一部分，所以也是全局共享的。jvm在执行过程中，需要经过<b>加载、连接(验证、准备、解析)、初始化</b>，在第一步的<b>加载</b>，虚拟机需要做下面3件事</p><ul><li>通过一个类的“全限定名”来获取此类的二进制字节流</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li><li>在内存中生成一个类代表这类的java.lang.Class对象，作为方法区这个类的各种数据访问的入口</li></ul><blockquote><p>这个Class对象和实例对象是不同的，类对象是在类加载的时候生成的，实例对象是调用new之后创建的<br>上面第二条，将class字节流代表的静态存储结构转化为方法区的运行时数据结构，其中就包含class文件常量池进入运行时常量池的过程。不同的类公用一个运行时常量池，同时在进入运行时常量池的过程中，多个class文件中常量池中相同的字符串只会存在一份在运行时常量池中。</p></blockquote><p><font color='red'><b>运行时常量池的作用是存储class文件常量池中的符号信息。</b></font><br>运行时常量池中保存着一些class文件中描述的符号引用，同时在类加载的<b>“解析阶段”</b>还会将这些<b>符号引用</b>所翻译出来的<b>直接引用(直接指向实例对象的指针)</b>存储在运行时常量池中。</p><blockquote><p>运行时常量池相对于class常量池一大特性就是其具有<b>动态性</b>，<b>Java规范并不要求常量只能在运行时才产生</b>，也就是说运行时常量池中的内容并不全部来自class文件常量池，class文件常量池并非运行时常量池的唯一数据输入口；<b>在运行时可以通过代码生成常量并将其放入常量池中</b>，这种特性被用的较多的是String.intern()</p></blockquote><h4 id="全局字符串常量池"><a href="#全局字符串常量池" class="headerlink" title="全局字符串常量池"></a>全局字符串常量池</h4><ul><li>不同于基本数据类型，String类型是一个final对象，他的字面量存在于class文件常量池中，但是运行期行为却与普通变量常量不同</li><li>jdk1.7中，字符串常量池和类引用被移动到Java堆中(与运行时常量池分离)，因此不同版本的String行为也有差异</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s0 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li>第一种的方式声明的字面量<code>hello</code>是在<font color='red'><b>编译器</b></font>就确定的，它会直接进入到class文件常量池中，当运行期间在全局字符串常量池中会保存它的一个引用，实际上最终还是要在堆中创建一个<code>yellow</code>对象</li><li>第二种方式使用<code>new String()</code>，也就是调用了String类的构造函数，我们知道new指令是创建一个类的实例对象并完成加载初始化，因此这个字符串对象是在<font color='red'><b>运行期</b></font>确定的，创建的字符串对象是在堆内存上</li><li><code>s0 == s1</code>，返回是false，s0和s1都存在堆上，但是地址肯定不同</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">String s2 = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">String s3 = <span class="string">&quot;Hel&quot;</span> + <span class="string">&quot;lo&quot;</span>;</span><br><span class="line">String s4 = <span class="string">&quot;Hel&quot;</span> + <span class="keyword">new</span> String(<span class="string">&quot;lo&quot;</span>);</span><br><span class="line">String s5 = <span class="keyword">new</span> String(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">String s7 = <span class="string">&quot;H&quot;</span>;</span><br><span class="line">String s8 = <span class="string">&quot;ello&quot;</span>;</span><br><span class="line">String s9 = s7 + s8;</span><br><span class="line"></span><br><span class="line">System.out.println(s1 == s2);  <span class="comment">// true</span></span><br><span class="line">System.out.println(s1 == s3);  <span class="comment">// true</span></span><br><span class="line">System.out.println(s1 == s4);  <span class="comment">// false</span></span><br><span class="line">System.out.println(s1 == s9);  <span class="comment">// false</span></span><br></pre></td></tr></table></figure><ul><li>s1 == s2<ul><li>这个就很好理解了，因为字面量<code>Hello</code>在运行期间会进入到全局字符串常量池，同一份字面量只会保留一份，所有引用都指向这一份字符串，自然引用的地址也就相同了</li></ul></li><li>s1 == s3<ul><li>编译优化，编译器会直接在Class文件常量池存的是<code>Hello</code>，跟第一种是一样的</li></ul></li><li>s1 != s4<ul><li><code>new String(&quot;lo&quot;)</code>在堆中创建一个String对象，而<code>Hel</code>字面量是通过另一种操作在堆中创建对象，这两个在堆中不同的地方创建的对象是通过<code>StringBuilder.append</code>方法拼接出来的，并且最终会调用<code>StringBuilder.toString</code>方法输出，最终拼出来的String对象，地址肯定是不一样的<br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Create a copy, don&#x27;t share the array</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(value, <span class="number">0</span>, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li>s1 != s9<ul><li>字面量会存在<code>Hello</code>、<code>H</code>、<code>ello</code>，运行期间会创建<code>H</code>和<code>ello</code>对象，通过<code>StringBuilder.append</code>方法拼接出来的，最终还是会重新生成String对象，地址肯定是不一样的。</li></ul></li></ul><p>    </p><blockquote><p>字符串常量池的概率：字符串常量池是Jvm所维护的一个字符串实例的引用表，在Hotspot vm中，他是一个叫做String Table的全局表。在字符串常量池中维护的是字符串实例的引用，底层C++实现就是一个HashTable。这些被维护的引用所指的字符串实例，被称为”被驻留的字符串“或”interned String“或通常所说的”进入了字符串常量池的字符串“。<br>运行时常量池在方法区(Non-heap)，而JDK1.7后，字符串常量池被移到了heap区，因此两者根本就不是一个概念</p></blockquote><h4 id="基本类型包装类对象常量池"><a href="#基本类型包装类对象常量池" class="headerlink" title="基本类型包装类对象常量池"></a>基本类型包装类对象常量池</h4><p><code>java</code>中基本类型的包装类的大部分都实现了常量池技术，这些类是<code>Byte、Short、Integer、Long、Character、Boolean</code>，另外两种浮点数没有实现。另外上面这5种整型的包装类也只是在对应值小于等于127时才可使用对象池，也即对象不负责创建和管理大于127的这些类的对象。其中会包含自动拆箱和自动装箱。</p><h1 id="线程私有内存区"><a href="#线程私有内存区" class="headerlink" title="线程私有内存区"></a>线程私有内存区</h1><p>和线程共享内存区不同，线程私有内存区是不允许被所有线程共享访问的。线程私有内存区是只允许被所属的独立线程进行访问的一类内存区，包括PC寄存器、Java栈和本地方法栈。</p><h2 id="PC寄存器"><a href="#PC寄存器" class="headerlink" title="PC寄存器"></a>PC寄存器</h2><p>由于JVM是基于栈的架构，任何的操作都需要入栈和出栈来完成，其中PC寄存器并不是物理寄存器，实际上是PC计数器。以下是特性</p><ul><li>PC寄存器用来存储下一条指令的地址</li><li>每个线程都会有一个PC寄存器，线程私有的，生命周期和线程的生命周期保持一致。 </li><li>任何时间一个线程都只有一个方法在执行，如果当前线程所执行的方法是一个Java方法，那么PC寄存器就会存储正在执行的字节码指令地址；如果当前线程所执行的方法是一个native方法，那么pc寄存器的值就是空(undefined)。</li><li>它是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError的区域</li></ul><h2 id="Java栈"><a href="#Java栈" class="headerlink" title="Java栈"></a>Java栈</h2><p>Java栈也称Java虚拟机栈，是线程私有的。Java栈存储栈帧(Stack Frame)<br>栈帧</p><ul><li>局部变量表<ul><li>存储各类原始数据类型、对象引用(reference)、returnAddress类型</li><li>returnAddress类型被定义为Java虚拟机内部的原始数据类型，该类型用于表示一条字节码指令的操作码(opcode)。</li></ul></li><li>操作数栈</li><li>动态链接</li><li>方法出口<blockquote><p>Java 栈允许被实现成固定大小的内存或者可动态扩展的内存大小<br>如果超过固定大小的内存就会抛出StackOverflowError错误<br>如果超过可动态扩展的内存就会抛出OutOfMemoryError错误</p></blockquote></li></ul><h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>Native Method Stack，用于支持本地方法执行（native方法，比如c/c++代码）</p><h1 id="自动内存管理"><a href="#自动内存管理" class="headerlink" title="自动内存管理"></a>自动内存管理</h1><p>程序内存管理是一个非常敏感的话题，对于c/c++而言，可以再语法层面上随意控制程序中一个对象的生命周期，随意创建一个对象，也能随意杀死一个对象，这种方式称之为手动内存管理。<br>手动内存管理是一把双刃剑，不好的地方会影响内存泄漏和内存溢出</p><ul><li>内存泄漏<ul><li>比较一个常见的场景，就是释放一个链表所引用的所有空间时，却错误地释放链表的第一个元素，尽管剩下的元素不被引用，但是他们却离开了整个程序的控制范围。这样一来，链表中的元素所占用的内存空间永远不会被释放</li><li>内存泄漏不会立马引起程序崩溃，慢慢在消耗内存，然后会瓦解</li></ul></li><li>内存溢出<ul><li>当使用的对象超出内存限制，一直无法释放时，就会产生内存溢出</li></ul></li></ul><p>但是Jvm是使用的<font color='red'><b>自动内存管理机制</b></font>，这样会降低内存泄漏和内存溢出的风险，但是这样会影响到一旦出现问题后，不太容易定位问题，还是需要了解jvm如何管理内容</p><h2 id="内存分配原理"><a href="#内存分配原理" class="headerlink" title="内存分配原理"></a>内存分配原理</h2><p>Jvm包含三种引用类型，分别是类类型(class type)，数组类型(array type)和接口类型（interface type），这些引用类型的值则是由类实例、数组实例以及实现了某个接口的派生类实例负责动态创建，那么jvm中究竟是如何为这些类型创建对应的对象实例呢？</p><ol><li>语法层面使用new关键字创建一个Java对象</li><li>new 指令的参数能否在常量池中定位到一个类的符号引用</li><li>检查这个符号引用想对应的类是否已经成功经历过加载、解析和初始化</li><li>当类完成装载步骤之后，就已经完全可以确定出创建对象实例所需要的内存大小</li><li>jvm就会将其进行内存分配，以存储生成的对象实例</li></ol><p><img src="/images/pasted-19.png" alt="对象分配内存流程"></p><p>为新对象分配内存是一件非常严谨和复杂的任务，需要考虑下面三个问题</p><ol><li><p>内存如何分配？</p><p> 如果内存空间以规整和有序的方式分布，即已有和未用的内存都各自一边，彼此之间维系着一个记录下一次分配起始点的标记指针，当为新对象分配内存时，只需要通过修改指针的偏移量将新对象分配在第一个空闲内存位置上。这种分配叫做<font color='red'><b>指针碰撞（Bump the Pointer）</b></font>，否则只能使用<font color='red'><b>空闲列表（Free List）</b></font>执行内存分配。</p></li><li><p>分配到哪里？</p><p> Java堆区分为新生代（Young Gen）和老年代（Old Gen），其中新生代分为Eden、From Survivor、To Survivor，由于对象的创建在Jvm中非常频繁，因此在并发情况下从堆区中划分内存空间是非线程安全的，所以务必需要保证数据操作的原子性。基于线程安全的考虑，如果一个类在分配内存之前已经成功完成类装载步骤之后，Jvm优先选在在<font color='red'><b>TLAB（Thread Local Allocation Buffer，本地线程分配缓冲区）</b></font>中为对象实例分配内存空间。<br> TLAB在Java堆区中是一块线程私有区域，它包含在Eden空间中，除了可以避免一系列的非线程安全问题外，同时还能够提升内存分配的吞吐量，因此这种内存分配方式为<b>快速分配策略</b><br> 不是所有的对象实例都在TLAB成功分配，但Jvm确实是将TLAB作为内存分配的首选，在程序中，开发人员可以将<code>-XX:UseTLAB</code>是否开启TLAB空间。<br> <font color='red'><b>默认情况下，TLAB占Eden中的1%</b></font>，可以手动调整<code>-XX:TLABWasteTargetPercent</code>设置TLAB站Eden空间的百分比大小。<br> <font color='red'><b>一旦对象在TLAB空间分配内存失败时，Jvm就会尝试着通过使用加锁机制确保数据操作的原子性，从而直接在Eden空间中分配内存，如果Eden空间中也无法分配内存时，Jvm就会执行Mirror GC，直至最终可以在Eden空间分配内存为止。（如果是大对象直接在老年代中分配）</b></font>   </p></li><li><p>内存回收？</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;jvm内存区域&quot;&gt;&lt;a href=&quot;#jvm内存区域&quot; class=&quot;headerlink&quot; title=&quot;jvm内存区域&quot;&gt;&lt;/a&gt;jvm内存区域&lt;/h1&gt;&lt;p&gt;之所以会选中jvm的内存区域划分为多个不同的内存区，是因为每一个独立的内存区都拥有各自的用途。&lt;br</summary>
      
    
    
    
    <category term="jvm" scheme="http://example.com/categories/jvm/"/>
    
    
    <category term="jvm" scheme="http://example.com/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>jvm初始化启动</title>
    <link href="http://example.com/2021/03/02/jvm%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    <id>http://example.com/2021/03/02/jvm%E5%88%9D%E5%A7%8B%E5%8C%96/</id>
    <published>2021-03-02T03:21:00.000Z</published>
    <updated>2021-07-06T15:00:15.403Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Launcher简介"><a href="#Launcher简介" class="headerlink" title="Launcher简介"></a>Launcher简介</h3><p>Launcher是一种用于启动jvm进程的启动器，关于Launcher的具体使用方式和标准选项配置，输入命令“java -help”，见下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">Usage: java [-options] <span class="class"><span class="keyword">class</span> [<span class="title">args</span>...]</span></span><br><span class="line"><span class="class">           (<span class="title">to</span> <span class="title">execute</span> <span class="title">a</span> <span class="title">class</span>)</span></span><br><span class="line"><span class="class">   <span class="title">or</span>  <span class="title">java</span> [-<span class="title">options</span>] -<span class="title">jar</span> <span class="title">jarfile</span> [<span class="title">args</span>...]</span></span><br><span class="line"><span class="class">           (<span class="title">to</span> <span class="title">execute</span> <span class="title">a</span> <span class="title">jar</span> <span class="title">file</span>)</span></span><br><span class="line"><span class="class"><span class="title">where</span> <span class="title">options</span> <span class="title">include</span>:</span></span><br><span class="line"><span class="class">    -<span class="title">d32</span>  <span class="title">use</span> <span class="title">a</span> 32-<span class="title">bit</span> <span class="title">data</span> <span class="title">model</span> <span class="title">if</span> <span class="title">available</span></span></span><br><span class="line"><span class="class">    -<span class="title">d64</span>  <span class="title">use</span> <span class="title">a</span> 64-<span class="title">bit</span> <span class="title">data</span> <span class="title">model</span> <span class="title">if</span> <span class="title">available</span></span></span><br><span class="line"><span class="class">    -<span class="title">server</span>  <span class="title">to</span> <span class="title">select</span> <span class="title">the</span> &quot;<span class="title">server</span>&quot; <span class="title">VM</span></span></span><br><span class="line"><span class="class">                  <span class="title">The</span> <span class="title">default</span> <span class="title">VM</span> <span class="title">is</span> <span class="title">server</span>,</span></span><br><span class="line"><span class="class">                  <span class="title">because</span> <span class="title">you</span> <span class="title">are</span> <span class="title">running</span> <span class="title">on</span> <span class="title">a</span> <span class="title">server</span>-<span class="title">class</span> <span class="title">machine</span>.</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">    -<span class="title">cp</span> &lt;<span class="title">class</span> <span class="title">search</span> <span class="title">path</span> <span class="title">of</span> <span class="title">directories</span> <span class="title">and</span> <span class="title">zip</span>/<span class="title">jar</span> <span class="title">files</span>&gt;</span></span><br><span class="line"><span class="class">    -<span class="title">classpath</span> &lt;<span class="title">class</span> <span class="title">search</span> <span class="title">path</span> <span class="title">of</span> <span class="title">directories</span> <span class="title">and</span> <span class="title">zip</span>/<span class="title">jar</span> <span class="title">files</span>&gt;</span></span><br><span class="line"><span class="class">                  <span class="title">A</span> : <span class="title">separated</span> <span class="title">list</span> <span class="title">of</span> <span class="title">directories</span>, <span class="title">JAR</span> <span class="title">archives</span>,</span></span><br><span class="line"><span class="class">                  <span class="title">and</span> <span class="title">ZIP</span> <span class="title">archives</span> <span class="title">to</span> <span class="title">search</span> <span class="title">for</span> <span class="title">class</span> <span class="title">files</span>.</span></span><br><span class="line"><span class="class">    -<span class="title">D</span>&lt;<span class="title">name</span>&gt;</span>=&lt;value&gt;</span><br><span class="line">                  set a system property</span><br><span class="line">    -verbose:[<span class="class"><span class="keyword">class</span>|<span class="title">gc</span>|<span class="title">jni</span>]</span></span><br><span class="line"><span class="class">                  <span class="title">enable</span> <span class="title">verbose</span> <span class="title">output</span></span></span><br><span class="line"><span class="class">    -<span class="title">version</span>      <span class="title">print</span> <span class="title">product</span> <span class="title">version</span> <span class="title">and</span> <span class="title">exit</span></span></span><br><span class="line"><span class="class">    -<span class="title">version</span>:&lt;<span class="title">value</span>&gt;</span></span><br><span class="line"><span class="class">                  <span class="title">Warning</span>: <span class="title">this</span> <span class="title">feature</span> <span class="title">is</span> <span class="title">deprecated</span> <span class="title">and</span> <span class="title">will</span> <span class="title">be</span> <span class="title">removed</span></span></span><br><span class="line"><span class="class">                  <span class="title">in</span> <span class="title">a</span> <span class="title">future</span> <span class="title">release</span>.</span></span><br><span class="line"><span class="class">                  <span class="title">require</span> <span class="title">the</span> <span class="title">specified</span> <span class="title">version</span> <span class="title">to</span> <span class="title">run</span></span></span><br><span class="line"><span class="class">    -<span class="title">showversion</span>  <span class="title">print</span> <span class="title">product</span> <span class="title">version</span> <span class="title">and</span> <span class="title">continue</span></span></span><br><span class="line"><span class="class">    -<span class="title">jre</span>-<span class="title">restrict</span>-<span class="title">search</span> | -<span class="title">no</span>-<span class="title">jre</span>-<span class="title">restrict</span>-<span class="title">search</span></span></span><br><span class="line"><span class="class">                  <span class="title">Warning</span>: <span class="title">this</span> <span class="title">feature</span> <span class="title">is</span> <span class="title">deprecated</span> <span class="title">and</span> <span class="title">will</span> <span class="title">be</span> <span class="title">removed</span></span></span><br><span class="line"><span class="class">                  <span class="title">in</span> <span class="title">a</span> <span class="title">future</span> <span class="title">release</span>.</span></span><br><span class="line"><span class="class">                  <span class="title">include</span>/<span class="title">exclude</span> <span class="title">user</span> <span class="title">private</span> <span class="title">JREs</span> <span class="title">in</span> <span class="title">the</span> <span class="title">version</span> <span class="title">search</span></span></span><br><span class="line"><span class="class">    -? -<span class="title">help</span>      <span class="title">print</span> <span class="title">this</span> <span class="title">help</span> <span class="title">message</span></span></span><br><span class="line"><span class="class">    -<span class="title">X</span>            <span class="title">print</span> <span class="title">help</span> <span class="title">on</span> <span class="title">non</span>-<span class="title">standard</span> <span class="title">options</span></span></span><br><span class="line"><span class="class">    -<span class="title">ea</span>[:&lt;<span class="title">packagename</span>&gt;...|:&lt;<span class="title">classname</span>&gt;]</span></span><br><span class="line"><span class="class">    -<span class="title">enableassertions</span>[:&lt;<span class="title">packagename</span>&gt;...|:&lt;<span class="title">classname</span>&gt;]</span></span><br><span class="line"><span class="class">                  <span class="title">enable</span> <span class="title">assertions</span> <span class="title">with</span> <span class="title">specified</span> <span class="title">granularity</span></span></span><br><span class="line"><span class="class">    -<span class="title">da</span>[:&lt;<span class="title">packagename</span>&gt;...|:&lt;<span class="title">classname</span>&gt;]</span></span><br><span class="line"><span class="class">    -<span class="title">disableassertions</span>[:&lt;<span class="title">packagename</span>&gt;...|:&lt;<span class="title">classname</span>&gt;]</span></span><br><span class="line"><span class="class">                  <span class="title">disable</span> <span class="title">assertions</span> <span class="title">with</span> <span class="title">specified</span> <span class="title">granularity</span></span></span><br><span class="line"><span class="class">    -<span class="title">esa</span> | -<span class="title">enablesystemassertions</span></span></span><br><span class="line"><span class="class">                  <span class="title">enable</span> <span class="title">system</span> <span class="title">assertions</span></span></span><br><span class="line"><span class="class">    -<span class="title">dsa</span> | -<span class="title">disablesystemassertions</span></span></span><br><span class="line"><span class="class">                  <span class="title">disable</span> <span class="title">system</span> <span class="title">assertions</span></span></span><br><span class="line"><span class="class">    -<span class="title">agentlib</span>:&lt;<span class="title">libname</span>&gt;[</span>=&lt;options&gt;]</span><br><span class="line">                  load <span class="keyword">native</span> agent library &lt;libname&gt;, e.g. -agentlib:hprof</span><br><span class="line">                  see also, -agentlib:jdwp=help and -agentlib:hprof=help</span><br><span class="line">    -agentpath:&lt;pathname&gt;[=&lt;options&gt;]</span><br><span class="line">                  load <span class="keyword">native</span> agent library by full pathname</span><br><span class="line">    -javaagent:&lt;jarpath&gt;[=&lt;options&gt;]</span><br><span class="line">                  load Java programming language agent, see java.lang.instrument</span><br><span class="line">    -splash:&lt;imagepath&gt;</span><br><span class="line">                  show splash screen with specified image</span><br></pre></td></tr></table></figure><blockquote><p>这里一定要注意，Launcher不是虚拟机实现，从严格意义上讲，Launcher只是一个封装了虚拟机的执行外壳。由它负责装载jre环境和windows平台下的jvm.dll动态链接库（linux平台下则是装载libjvm.so）,它必须调用虚拟机中的函数来完毕运行java程序的功能。所以，你在Hotspot的源码找不到启动程序的main函数。<br><font color='red'>openjdk7是有一个启动器的，在openjdk/hotspot/src/share/tools/layncher/java.c中main函数<br>openjdk8后，启动器在openjdk/jdk/src/share/bin/main.c中</font></p></blockquote><h3 id="HotSpot源码目录结构"><a href="#HotSpot源码目录结构" class="headerlink" title="HotSpot源码目录结构"></a>HotSpot源码目录结构</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">├─agent                            Serviceability Agent的客户端实现</span><br><span class="line">├─make                             用来build出HotSpot的各种配置文件</span><br><span class="line">├─src                              HotSpot VM的源代码</span><br><span class="line">│  ├─cpu                            CPU相关代码（汇编器、模板解释器、ad文件、部分runtime函数在这里实现）</span><br><span class="line">│  ├─os                             操作系相关代码</span><br><span class="line">│  ├─os_cpu                         操作系统+CPU的组合相关的代码</span><br><span class="line">│  └─share                          平台无关的共通代码</span><br><span class="line">│      ├─tools                        工具</span><br><span class="line">│      │  ├─hsdis                      反汇编插件</span><br><span class="line">│      │  ├─IdealGraphVisualizer       将server编译器的中间代码可视化的工具</span><br><span class="line">│      │  ├─launcher                   openjdk1<span class="number">.7</span>之前存在launcher目录，这里存放启动程序“java”</span><br><span class="line">│      │  ├─LogCompilation             将-XX:+LogCompilation输出的日志（hotspot.log）整理成更容易阅读的格式的工具</span><br><span class="line">│      │  └─ProjectCreator             生成Visual Studio的project文件的工具</span><br><span class="line">│      └─vm                           HotSpot VM的核心代码</span><br><span class="line">│          ├─adlc                       平台描述文件（上面的cpu或os_cpu里的*.ad文件）的编译器</span><br><span class="line">│          ├─asm                        汇编器接口</span><br><span class="line">│          ├─c1                         client编译器（又称“C1”）</span><br><span class="line">│          ├─ci                         动态编译器的公共服务/从动态编译器到VM的接口</span><br><span class="line">│          ├─classfile                  类文件的处理（包括类加载和系统符号表等）</span><br><span class="line">│          ├─code                       动态生成的代码的管理</span><br><span class="line">│          ├─compiler                   从VM调用动态编译器的接口</span><br><span class="line">│          ├─gc_implementation          GC的实现</span><br><span class="line">│          │  ├─concurrentMarkSweep      Concurrent Mark Sweep GC的实现</span><br><span class="line">│          │  ├─g1                       Garbage-First GC的实现（不使用老的分代式GC框架）</span><br><span class="line">│          │  ├─parallelScavenge         ParallelScavenge GC的实现（server VM默认，不使用老的分代式GC框架）</span><br><span class="line">│          │  ├─parNew                   ParNew GC的实现</span><br><span class="line">│          │  └─shared                   GC的共通实现</span><br><span class="line">│          ├─gc_interface               GC的接口</span><br><span class="line">│          ├─interpreter                解释器，包括“模板解释器”（官方版在用）和“C++解释器”（官方版不在用）</span><br><span class="line">│          ├─libadt                     一些抽象数据结构</span><br><span class="line">│          ├─memory                     内存管理相关（老的分代式GC框架也在这里）</span><br><span class="line">│          ├─oops                       HotSpot VM的对象系统的实现</span><br><span class="line">│          ├─opto                       server编译器（又称“C2”或“Opto”）</span><br><span class="line">│          ├─prims                      HotSpot VM的对外接口，包括部分标准库的<span class="keyword">native</span>部分和JVMTI实现</span><br><span class="line">│          ├─runtime                    运行时支持库（包括线程管理、编译器调度、锁、反射等）</span><br><span class="line">│          ├─services                   主要是用来支持JMX之类的管理功能的接口</span><br><span class="line">│          ├─shark                      基于LLVM的JIT编译器（官方版里没有使用）</span><br><span class="line">│          └─utilities                  一些基本的工具类</span><br><span class="line">└─test                             单元测试</span><br></pre></td></tr></table></figure><h3 id="使用Launcher启动jvm"><a href="#使用Launcher启动jvm" class="headerlink" title="使用Launcher启动jvm"></a>使用Launcher启动jvm</h3><p>调用栈</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">openjdk/jdk/src/share/bin/main.c::WinMain/main</span><br><span class="line">  openjdk/jdk/src/share/bin/java.c::JLI_Launch</span><br><span class="line">    openjdk/jdk/src/solaris/bin/java_md_solinux.c::LoadJavaVM # Load JVM Library: libjvm.so</span><br><span class="line">    openjdk/jdk/src/solaris/bin/java_md_solinux.c::JVMInit # Create JVM</span><br><span class="line">      openjdk/jdk/src/share/bin/java.c::ContinueInNewThread</span><br><span class="line">        openjdk/jdk/src/solaris/bin/java_md_solinux.c::ContinueInNewThread0(JavaMain, threadStackSize, (<span class="keyword">void</span>*)&amp;args);</span><br><span class="line">          pthread_create(&amp;tid, &amp;attr, (<span class="keyword">void</span> *(*)(<span class="keyword">void</span>*))continuation, (<span class="keyword">void</span>*)args)</span><br><span class="line">            openjdk/jdk/src/share/bin/java.c::JavaMain</span><br><span class="line">              openjdk/jdk/src/share/bin/java.c::InitializeJVM</span><br><span class="line">                openjdk\hotspot\src\share\vm\prims\jni.cpp::JNI_CreateJavaVM</span><br></pre></td></tr></table></figure><p>调用过程</p><ol><li>main函数<br>启动函数</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> WINAPI</span></span><br><span class="line"><span class="function"><span class="title">WinMain</span><span class="params">(HINSTANCE inst, HINSTANCE previnst, LPSTR cmdline, <span class="keyword">int</span> cmdshow)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> margc;</span><br><span class="line">    <span class="keyword">char</span>** margv;</span><br><span class="line">    <span class="keyword">const</span> jboolean const_javaw = JNI_TRUE;</span><br><span class="line"></span><br><span class="line">    __initenv = _environ;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span> <span class="comment">/* JAVAW */</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> margc;</span><br><span class="line">    <span class="keyword">char</span>** margv;</span><br><span class="line">    <span class="keyword">const</span> jboolean const_javaw = JNI_FALSE;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* JAVAW */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _WIN32</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">getenv</span>(JLDEBUG_ENV_ENTRY) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Windows original main args:\n&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; __argc ; i++) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;wwwd_args[%d] = %s\n&quot;</span>, i, __argv[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">JLI_CmdToArgs</span>(<span class="built_in">GetCommandLine</span>());</span><br><span class="line">    margc = <span class="built_in">JLI_GetStdArgc</span>();</span><br><span class="line">    <span class="comment">// add one more to mark the end</span></span><br><span class="line">    margv = (<span class="keyword">char</span> **)<span class="built_in">JLI_MemAlloc</span>((margc + <span class="number">1</span>) * (<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">char</span> *)));</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        StdArg *stdargs = <span class="built_in">JLI_GetStdArgs</span>();</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; margc ; i++) &#123;</span><br><span class="line">            margv[i] = stdargs[i].arg;</span><br><span class="line">        &#125;</span><br><span class="line">        margv[i] = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span> <span class="comment">/* *NIXES */</span></span></span><br><span class="line">    margc = argc;</span><br><span class="line">    margv = argv;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* WIN32 */</span></span></span><br><span class="line"># 调用<span class="function">launcher</span></span><br><span class="line"><span class="function">    <span class="keyword">return</span> <span class="title">JLI_Launch</span><span class="params">(margc, margv,</span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="keyword">sizeof</span>(const_jargs) / <span class="keyword">sizeof</span>(<span class="keyword">char</span> *), const_jargs,</span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="keyword">sizeof</span>(const_appclasspath) / <span class="keyword">sizeof</span>(<span class="keyword">char</span> *), const_appclasspath,</span></span></span><br><span class="line"><span class="params"><span class="function">                   FULL_VERSION,</span></span></span><br><span class="line"><span class="params"><span class="function">                   DOT_VERSION,</span></span></span><br><span class="line"><span class="params"><span class="function">                   (const_progname != <span class="literal">NULL</span>) ? const_progname : *margv,</span></span></span><br><span class="line"><span class="params"><span class="function">                   (const_launcher != <span class="literal">NULL</span>) ? const_launcher : *margv,</span></span></span><br><span class="line"><span class="params"><span class="function">                   (const_jargs != <span class="literal">NULL</span>) ? JNI_TRUE : JNI_FALSE,</span></span></span><br><span class="line"><span class="params"><span class="function">                   const_cpwildcard, const_javaw, const_ergo_class)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="2"><li>JLI_Launch<br>创建运行环境</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Entry point.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">JLI_Launch</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> ** argv,              <span class="comment">/* main argc, argc */</span></span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">int</span> jargc, <span class="keyword">const</span> <span class="keyword">char</span>** jargv,          <span class="comment">/* java args */</span></span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">int</span> appclassc, <span class="keyword">const</span> <span class="keyword">char</span>** appclassv,  <span class="comment">/* app classpath */</span></span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">const</span> <span class="keyword">char</span>* fullversion,                <span class="comment">/* full version defined */</span></span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">const</span> <span class="keyword">char</span>* dotversion,                 <span class="comment">/* dot version defined */</span></span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">const</span> <span class="keyword">char</span>* pname,                      <span class="comment">/* program name */</span></span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">const</span> <span class="keyword">char</span>* lname,                      <span class="comment">/* launcher name */</span></span></span></span><br><span class="line"><span class="params"><span class="function">        jboolean javaargs,                      <span class="comment">/* JAVA_ARGS */</span></span></span></span><br><span class="line"><span class="params"><span class="function">        jboolean cpwildcard,                    <span class="comment">/* classpath wildcard*/</span></span></span></span><br><span class="line"><span class="params"><span class="function">        jboolean javaw,                         <span class="comment">/* windows-only javaw */</span></span></span></span><br><span class="line"><span class="params"><span class="function">        jint ergo                               <span class="comment">/* ergonomics class policy */</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mode = LM_UNKNOWN;</span><br><span class="line">    <span class="keyword">char</span> *what = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">char</span> *cpath = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> *main_class = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    InvocationFunctions ifn;</span><br><span class="line">    jlong start, end;</span><br><span class="line">    <span class="keyword">char</span> jvmpath[MAXPATHLEN];</span><br><span class="line">    <span class="keyword">char</span> jrepath[MAXPATHLEN];</span><br><span class="line">    <span class="keyword">char</span> jvmcfg[MAXPATHLEN];</span><br><span class="line"></span><br><span class="line">    _fVersion = fullversion;</span><br><span class="line">    _dVersion = dotversion;</span><br><span class="line">    _launcher_name = lname;</span><br><span class="line">    _program_name = pname;</span><br><span class="line">    _is_java_args = javaargs;</span><br><span class="line">    _wc_enabled = cpwildcard;</span><br><span class="line">    _ergo_policy = ergo;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">InitLauncher</span>(javaw);</span><br><span class="line">    <span class="built_in">DumpState</span>();</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">JLI_IsTraceLauncher</span>()) &#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Command line args:\n&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; argc ; i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;argv[%d] = %s\n&quot;</span>, i, argv[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">AddOption</span>(<span class="string">&quot;-Dsun.java.launcher.diag=true&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Make sure the specified version of the JRE is running.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * There are three things to note about the SelectVersion() routine:</span></span><br><span class="line"><span class="comment">     *  1) If the version running isn&#x27;t correct, this routine doesn&#x27;t</span></span><br><span class="line"><span class="comment">     *     return (either the correct version has been exec&#x27;d or an error</span></span><br><span class="line"><span class="comment">     *     was issued).</span></span><br><span class="line"><span class="comment">     *  2) Argc and Argv in this scope are *not* altered by this routine.</span></span><br><span class="line"><span class="comment">     *     It is the responsibility of subsequent code to ignore the</span></span><br><span class="line"><span class="comment">     *     arguments handled by this routine.</span></span><br><span class="line"><span class="comment">     *  3) As a side-effect, the variable &quot;main_class&quot; is guaranteed to</span></span><br><span class="line"><span class="comment">     *     be set (if it should ever be set).  This isn&#x27;t exactly the</span></span><br><span class="line"><span class="comment">     *     poster child for structured programming, but it is a small</span></span><br><span class="line"><span class="comment">     *     price to pay for not processing a jar file operand twice.</span></span><br><span class="line"><span class="comment">     *     (Note: This side effect has been disabled.  See comment on</span></span><br><span class="line"><span class="comment">     *     bugid 5030265 below.)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">SelectVersion</span>(argc, argv, &amp;main_class);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CreateExecutionEnvironment</span>(&amp;argc, &amp;argv,</span><br><span class="line">                               jrepath, <span class="built_in"><span class="keyword">sizeof</span></span>(jrepath),</span><br><span class="line">                               jvmpath, <span class="built_in"><span class="keyword">sizeof</span></span>(jvmpath),</span><br><span class="line">                               jvmcfg,  <span class="built_in"><span class="keyword">sizeof</span></span>(jvmcfg));</span><br><span class="line"></span><br><span class="line">    ifn.CreateJavaVM = <span class="number">0</span>;</span><br><span class="line">    ifn.GetDefaultJavaVMInitArgs = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">JLI_IsTraceLauncher</span>()) &#123;</span><br><span class="line">        start = <span class="built_in">CounterGet</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # 加载虚拟机动态链接库，并初始化ifn的函数指针</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">LoadJavaVM</span>(jvmpath, &amp;ifn)) &#123;</span><br><span class="line">        <span class="keyword">return</span>(<span class="number">6</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">JLI_IsTraceLauncher</span>()) &#123;</span><br><span class="line">        end   = <span class="built_in">CounterGet</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">JLI_TraceLauncher</span>(<span class="string">&quot;%ld micro seconds to LoadJavaVM\n&quot;</span>,</span><br><span class="line">             (<span class="keyword">long</span>)(jint)<span class="built_in">Counter2Micros</span>(end-start));</span><br><span class="line"></span><br><span class="line">    ++argv;</span><br><span class="line">    --argc;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">IsJavaArgs</span>()) &#123;</span><br><span class="line">        <span class="comment">/* Preprocess wrapper arguments */</span></span><br><span class="line">        <span class="built_in">TranslateApplicationArgs</span>(jargc, jargv, &amp;argc, &amp;argv);</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">AddApplicationOptions</span>(appclassc, appclassv)) &#123;</span><br><span class="line">            <span class="keyword">return</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Set default CLASSPATH */</span></span><br><span class="line">        cpath = <span class="built_in">getenv</span>(<span class="string">&quot;CLASSPATH&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (cpath == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            cpath = <span class="string">&quot;.&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">SetClassPath</span>(cpath);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Parse command line options; if the return value of</span></span><br><span class="line"><span class="comment">     * ParseArguments is false, the program should exit.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">ParseArguments</span>(&amp;argc, &amp;argv, &amp;mode, &amp;what, &amp;ret, jrepath))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>(ret);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Override class path if -jar flag was specified */</span></span><br><span class="line">    <span class="keyword">if</span> (mode == LM_JAR) &#123;</span><br><span class="line">        <span class="built_in">SetClassPath</span>(what);     <span class="comment">/* Override class path */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* set the -Dsun.java.command pseudo property */</span></span><br><span class="line">    <span class="built_in">SetJavaCommandLineProp</span>(what, argc, argv);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set the -Dsun.java.launcher pseudo property */</span></span><br><span class="line">    <span class="built_in">SetJavaLauncherProp</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* set the -Dsun.java.launcher.* platform properties */</span></span><br><span class="line">    <span class="built_in">SetJavaLauncherPlatformProps</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">JVMInit</span>(&amp;ifn, threadStackSize, argc, argv, mode, what, ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那对应的LoadJavaVM是什么?见下面代码<br>其中设置ifn函数的属性</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">jboolean</span></span><br><span class="line"><span class="function"><span class="title">LoadJavaVM</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *jvmpath, InvocationFunctions *ifn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *libjvm;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">JLI_TraceLauncher</span>(<span class="string">&quot;JVM path is %s\n&quot;</span>, jvmpath);</span><br><span class="line"></span><br><span class="line">    libjvm = <span class="built_in">dlopen</span>(jvmpath, RTLD_NOW + RTLD_GLOBAL);</span><br><span class="line">    <span class="keyword">if</span> (libjvm == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__solaris__) &amp;&amp; defined(__sparc) &amp;&amp; !defined(_LP64) <span class="comment">/* i.e. 32-bit sparc */</span></span></span><br><span class="line">      FILE * fp;</span><br><span class="line">      Elf32_Ehdr elf_head;</span><br><span class="line">      <span class="keyword">int</span> count;</span><br><span class="line">      <span class="keyword">int</span> location;</span><br><span class="line"></span><br><span class="line">      fp = <span class="built_in">fopen</span>(jvmpath, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">      <span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">JLI_ReportErrorMessage</span>(DLL_ERROR2, jvmpath, <span class="built_in">dlerror</span>());</span><br><span class="line">        <span class="keyword">return</span> JNI_FALSE;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* read in elf header */</span></span><br><span class="line">      count = <span class="built_in">fread</span>((<span class="keyword">void</span>*)(&amp;elf_head), <span class="built_in"><span class="keyword">sizeof</span></span>(Elf32_Ehdr), <span class="number">1</span>, fp);</span><br><span class="line">      <span class="built_in">fclose</span>(fp);</span><br><span class="line">      <span class="keyword">if</span> (count &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">JLI_ReportErrorMessage</span>(DLL_ERROR2, jvmpath, <span class="built_in">dlerror</span>());</span><br><span class="line">        <span class="keyword">return</span> JNI_FALSE;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">       * Check for running a server vm (compiled with -xarch=v8plus)</span></span><br><span class="line"><span class="comment">       * on a stock v8 processor.  In this case, the machine type in</span></span><br><span class="line"><span class="comment">       * the elf header would not be included the architecture list</span></span><br><span class="line"><span class="comment">       * provided by the isalist command, which is turn is gotten from</span></span><br><span class="line"><span class="comment">       * sysinfo.  This case cannot occur on 64-bit hardware and thus</span></span><br><span class="line"><span class="comment">       * does not have to be checked for in binaries with an LP64 data</span></span><br><span class="line"><span class="comment">       * model.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">if</span> (elf_head.e_machine == EM_SPARC32PLUS) &#123;</span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">257</span>];  <span class="comment">/* recommended buffer size from sysinfo man</span></span><br><span class="line"><span class="comment">                           page */</span></span><br><span class="line">        <span class="keyword">long</span> length;</span><br><span class="line">        <span class="keyword">char</span>* location;</span><br><span class="line"></span><br><span class="line">        length = <span class="built_in">sysinfo</span>(SI_ISALIST, buf, <span class="number">257</span>);</span><br><span class="line">        <span class="keyword">if</span> (length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            location = <span class="built_in">JLI_StrStr</span>(buf, <span class="string">&quot;sparcv8plus &quot;</span>);</span><br><span class="line">          <span class="keyword">if</span> (location == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">JLI_ReportErrorMessage</span>(JVM_ERROR3);</span><br><span class="line">            <span class="keyword">return</span> JNI_FALSE;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="built_in">JLI_ReportErrorMessage</span>(DLL_ERROR1, __LINE__);</span><br><span class="line">        <span class="built_in">JLI_ReportErrorMessage</span>(DLL_ERROR2, jvmpath, <span class="built_in">dlerror</span>());</span><br><span class="line">        <span class="keyword">return</span> JNI_FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"># 设置ifn函数引用</span><br><span class="line">    ifn-&gt;CreateJavaVM = (CreateJavaVM_t)</span><br><span class="line">        <span class="built_in">dlsym</span>(libjvm, <span class="string">&quot;JNI_CreateJavaVM&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (ifn-&gt;CreateJavaVM == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">JLI_ReportErrorMessage</span>(DLL_ERROR2, jvmpath, <span class="built_in">dlerror</span>());</span><br><span class="line">        <span class="keyword">return</span> JNI_FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ifn-&gt;GetDefaultJavaVMInitArgs = (GetDefaultJavaVMInitArgs_t)</span><br><span class="line">        <span class="built_in">dlsym</span>(libjvm, <span class="string">&quot;JNI_GetDefaultJavaVMInitArgs&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (ifn-&gt;GetDefaultJavaVMInitArgs == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">JLI_ReportErrorMessage</span>(DLL_ERROR2, jvmpath, <span class="built_in">dlerror</span>());</span><br><span class="line">        <span class="keyword">return</span> JNI_FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ifn-&gt;GetCreatedJavaVMs = (GetCreatedJavaVMs_t)</span><br><span class="line">        <span class="built_in">dlsym</span>(libjvm, <span class="string">&quot;JNI_GetCreatedJavaVMs&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (ifn-&gt;GetCreatedJavaVMs == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">JLI_ReportErrorMessage</span>(DLL_ERROR2, jvmpath, <span class="built_in">dlerror</span>());</span><br><span class="line">        <span class="keyword">return</span> JNI_FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> JNI_TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那对应JVMInit是什么？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">JVMInit</span><span class="params">(InvocationFunctions* ifn, jlong threadStackSize,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">int</span> argc, <span class="keyword">char</span> **argv,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">int</span> mode, <span class="keyword">char</span> *what, <span class="keyword">int</span> ret)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">ShowSplashScreen</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ContinueInNewThread</span>(ifn, threadStackSize, argc, argv, mode, what, ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>ContinueInNewThread函数</li></ol><p>调用ContinueInNewThread0函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">ContinueInNewThread</span><span class="params">(InvocationFunctions* ifn, jlong threadStackSize,</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="keyword">int</span> argc, <span class="keyword">char</span> **argv,</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="keyword">int</span> mode, <span class="keyword">char</span> *what, <span class="keyword">int</span> ret)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If user doesn&#x27;t specify stack size, check if VM has a preference.</span></span><br><span class="line"><span class="comment">     * Note that HotSpot no longer supports JNI_VERSION_1_1 but it will</span></span><br><span class="line"><span class="comment">     * return its default stack size through the init args structure.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (threadStackSize == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">JDK1_1InitArgs</span> <span class="title">args1_1</span>;</span></span><br><span class="line">      <span class="built_in">memset</span>((<span class="keyword">void</span>*)&amp;args1_1, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(args1_1));</span><br><span class="line">      args1_1.version = JNI_VERSION_1_1;</span><br><span class="line">      ifn-&gt;<span class="built_in">GetDefaultJavaVMInitArgs</span>(&amp;args1_1);  <span class="comment">/* ignore return value */</span></span><br><span class="line">      <span class="keyword">if</span> (args1_1.javaStackSize &gt; <span class="number">0</span>) &#123;</span><br><span class="line">         threadStackSize = args1_1.javaStackSize;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123; <span class="comment">/* Create a new thread to create JVM and invoke main method */</span></span><br><span class="line">      JavaMainArgs args;</span><br><span class="line">      <span class="keyword">int</span> rslt;</span><br><span class="line"></span><br><span class="line">      args.argc = argc;</span><br><span class="line">      args.argv = argv;</span><br><span class="line">      args.mode = mode;</span><br><span class="line">      args.what = what;</span><br><span class="line">      args.ifn = *ifn;</span><br><span class="line"></span><br><span class="line">      rslt = <span class="built_in">ContinueInNewThread0</span>(JavaMain, threadStackSize, (<span class="keyword">void</span>*)&amp;args);</span><br><span class="line">      <span class="comment">/* If the caller has deemed there is an error we</span></span><br><span class="line"><span class="comment">       * simply return that, otherwise we return the value of</span></span><br><span class="line"><span class="comment">       * the callee</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">return</span> (ret != <span class="number">0</span>) ? ret : rslt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="4"><li>ContinueInNewThread0函数</li></ol><p>创建一个新的线程，然后运行JavaMain函数。启动新的线程，Launcher就会阻塞原有线程，其中int (JNICALL *continuation)(void *)这个参数就是ContinueInNewThread参数中的JavaMain函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">ContinueInNewThread0</span><span class="params">(<span class="keyword">int</span> (JNICALL *continuation)(<span class="keyword">void</span> *), jlong stack_size, <span class="keyword">void</span> * args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rslt;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __linux__</span></span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">pthread_attr_t</span> attr;</span><br><span class="line">    <span class="built_in">pthread_attr_init</span>(&amp;attr);</span><br><span class="line">    <span class="built_in">pthread_attr_setdetachstate</span>(&amp;attr, PTHREAD_CREATE_JOINABLE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (stack_size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">pthread_attr_setstacksize</span>(&amp;attr, stack_size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">pthread_create</span>(&amp;tid, &amp;attr, (<span class="keyword">void</span> *(*)(<span class="keyword">void</span>*))continuation, (<span class="keyword">void</span>*)args) == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">void</span> * tmp;</span><br><span class="line">      <span class="built_in">pthread_join</span>(tid, &amp;tmp);</span><br><span class="line">      rslt = (<span class="keyword">int</span>)tmp;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">      * Continue execution in current thread if for some reason (e.g. out of</span></span><br><span class="line"><span class="comment">      * memory/LWP)  a new thread can&#x27;t be created. This will likely fail</span></span><br><span class="line"><span class="comment">      * later in continuation as JNI_CreateJavaVM needs to create quite a</span></span><br><span class="line"><span class="comment">      * few new threads, anyway, just give it a try..</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      rslt = <span class="built_in">continuation</span>(args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_attr_destroy</span>(&amp;attr);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span> <span class="comment">/* ! __linux__ */</span></span></span><br><span class="line">    <span class="keyword">thread_t</span> tid;</span><br><span class="line">    <span class="keyword">long</span> flags = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">thr_create</span>(<span class="literal">NULL</span>, stack_size, (<span class="keyword">void</span> *(*)(<span class="keyword">void</span> *))continuation, args, flags, &amp;tid) == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">void</span> * tmp;</span><br><span class="line">      <span class="built_in">thr_join</span>(tid, <span class="literal">NULL</span>, &amp;tmp);</span><br><span class="line">      rslt = (<span class="keyword">int</span>)tmp;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">/* See above. Continue in current thread if thr_create() failed */</span></span><br><span class="line">      rslt = <span class="built_in">continuation</span>(args);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __linux__ */</span></span></span><br><span class="line">    <span class="keyword">return</span> rslt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>JavaMain函数</li></ol><p>InitializeJVM就是初始化java虚拟机，然后LoadMainClass加载主类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> JNICALL</span></span><br><span class="line"><span class="function"><span class="title">JavaMain</span><span class="params">(<span class="keyword">void</span> * _args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    JavaMainArgs *args = (JavaMainArgs *)_args;</span><br><span class="line">    <span class="keyword">int</span> argc = args-&gt;argc;</span><br><span class="line">    <span class="keyword">char</span> **argv = args-&gt;argv;</span><br><span class="line">    <span class="keyword">int</span> mode = args-&gt;mode;</span><br><span class="line">    <span class="keyword">char</span> *what = args-&gt;what;</span><br><span class="line">    InvocationFunctions ifn = args-&gt;ifn;</span><br><span class="line"></span><br><span class="line">    JavaVM *vm = <span class="number">0</span>;</span><br><span class="line">    JNIEnv *env = <span class="number">0</span>;</span><br><span class="line">    jclass mainClass = <span class="literal">NULL</span>;</span><br><span class="line">    jclass appClass = <span class="literal">NULL</span>; <span class="comment">// actual application class being launched</span></span><br><span class="line">    jmethodID mainID;</span><br><span class="line">    jobjectArray mainArgs;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    jlong start, end;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">RegisterThread</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Initialize the virtual machine */</span></span><br><span class="line">    start = <span class="built_in">CounterGet</span>();</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">InitializeJVM</span>(&amp;vm, &amp;env, &amp;ifn)) &#123;</span><br><span class="line">        <span class="built_in">JLI_ReportErrorMessage</span>(JVM_ERROR1);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (showSettings != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">ShowSettings</span>(env, showSettings);</span><br><span class="line">        <span class="built_in">CHECK_EXCEPTION_LEAVE</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (printVersion || showVersion) &#123;</span><br><span class="line">        <span class="built_in">PrintJavaVersion</span>(env, showVersion);</span><br><span class="line">        <span class="built_in">CHECK_EXCEPTION_LEAVE</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (printVersion) &#123;</span><br><span class="line">            <span class="built_in">LEAVE</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If the user specified neither a class name nor a JAR file */</span></span><br><span class="line">    <span class="keyword">if</span> (printXUsage || printUsage || what == <span class="number">0</span> || mode == LM_UNKNOWN) &#123;</span><br><span class="line">        <span class="built_in">PrintUsage</span>(env, printXUsage);</span><br><span class="line">        <span class="built_in">CHECK_EXCEPTION_LEAVE</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">LEAVE</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FreeKnownVMs</span>();  <span class="comment">/* after last possible PrintUsage() */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">JLI_IsTraceLauncher</span>()) &#123;</span><br><span class="line">        end = <span class="built_in">CounterGet</span>();</span><br><span class="line">        <span class="built_in">JLI_TraceLauncher</span>(<span class="string">&quot;%ld micro seconds to InitializeJVM\n&quot;</span>,</span><br><span class="line">               (<span class="keyword">long</span>)(jint)<span class="built_in">Counter2Micros</span>(end-start));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* At this stage, argc/argv have the application&#x27;s arguments */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">JLI_IsTraceLauncher</span>())&#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s is &#x27;%s&#x27;\n&quot;</span>, launchModeNames[mode], what);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;App&#x27;s argc is %d\n&quot;</span>, argc);</span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>; i &lt; argc; i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;    argv[%2d] = &#x27;%s&#x27;\n&quot;</span>, i, argv[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Get the application&#x27;s main class.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * See bugid 5030265.  The Main-Class name has already been parsed</span></span><br><span class="line"><span class="comment">     * from the manifest, but not parsed properly for UTF-8 support.</span></span><br><span class="line"><span class="comment">     * Hence the code here ignores the value previously extracted and</span></span><br><span class="line"><span class="comment">     * uses the pre-existing code to reextract the value.  This is</span></span><br><span class="line"><span class="comment">     * possibly an end of release cycle expedient.  However, it has</span></span><br><span class="line"><span class="comment">     * also been discovered that passing some character sets through</span></span><br><span class="line"><span class="comment">     * the environment has &quot;strange&quot; behavior on some variants of</span></span><br><span class="line"><span class="comment">     * Windows.  Hence, maybe the manifest parsing code local to the</span></span><br><span class="line"><span class="comment">     * launcher should never be enhanced.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Hence, future work should either:</span></span><br><span class="line"><span class="comment">     *     1)   Correct the local parsing code and verify that the</span></span><br><span class="line"><span class="comment">     *          Main-Class attribute gets properly passed through</span></span><br><span class="line"><span class="comment">     *          all environments,</span></span><br><span class="line"><span class="comment">     *     2)   Remove the vestages of maintaining main_class through</span></span><br><span class="line"><span class="comment">     *          the environment (and remove these comments).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * This method also correctly handles launching existing JavaFX</span></span><br><span class="line"><span class="comment">     * applications that may or may not have a Main-Class manifest entry.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    mainClass = <span class="built_in">LoadMainClass</span>(env, mode, what);</span><br><span class="line">    <span class="built_in">CHECK_EXCEPTION_NULL_LEAVE</span>(mainClass);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * In some cases when launching an application that needs a helper, e.g., a</span></span><br><span class="line"><span class="comment">     * JavaFX application with no main method, the mainClass will not be the</span></span><br><span class="line"><span class="comment">     * applications own main class but rather a helper class. To keep things</span></span><br><span class="line"><span class="comment">     * consistent in the UI we need to track and report the application main class.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    appClass = <span class="built_in">GetApplicationClass</span>(env);</span><br><span class="line">    <span class="built_in">NULL_CHECK_RETURN_VALUE</span>(appClass, <span class="number">-1</span>);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * PostJVMInit uses the class name as the application name for GUI purposes,</span></span><br><span class="line"><span class="comment">     * for example, on OSX this sets the application name in the menu bar for</span></span><br><span class="line"><span class="comment">     * both SWT and JavaFX. So we&#x27;ll pass the actual application class here</span></span><br><span class="line"><span class="comment">     * instead of mainClass as that may be a launcher or helper class instead</span></span><br><span class="line"><span class="comment">     * of the application class.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">PostJVMInit</span>(env, appClass, vm);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * The LoadMainClass not only loads the main class, it will also ensure</span></span><br><span class="line"><span class="comment">     * that the main method&#x27;s signature is correct, therefore further checking</span></span><br><span class="line"><span class="comment">     * is not required. The main method is invoked here so that extraneous java</span></span><br><span class="line"><span class="comment">     * stacks are not in the application stack trace.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    mainID = (*env)-&gt;<span class="built_in">GetStaticMethodID</span>(env, mainClass, <span class="string">&quot;main&quot;</span>,</span><br><span class="line">                                       <span class="string">&quot;([Ljava/lang/String;)V&quot;</span>);</span><br><span class="line">    <span class="built_in">CHECK_EXCEPTION_NULL_LEAVE</span>(mainID);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Build platform specific argument array */</span></span><br><span class="line">    mainArgs = <span class="built_in">CreateApplicationArgs</span>(env, argv, argc);</span><br><span class="line">    <span class="built_in">CHECK_EXCEPTION_NULL_LEAVE</span>(mainArgs);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Invoke main method. */</span></span><br><span class="line">    (*env)-&gt;<span class="built_in">CallStaticVoidMethod</span>(env, mainClass, mainID, mainArgs);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * The launcher&#x27;s exit code (in the absence of calls to</span></span><br><span class="line"><span class="comment">     * System.exit) will be non-zero if main threw an exception.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ret = (*env)-&gt;<span class="built_in">ExceptionOccurred</span>(env) == <span class="literal">NULL</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">LEAVE</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>CHECK_EXCEPTION_NULL_LEAVE() &amp; CHECK_EXCEPTION_LEAVE() &amp; LEAVE()<br>其中这些方法会调用下面代码</p><blockquote><p>逻辑是当java程序执行完，Launcher会调用DetachCurrentThread断开与主程序之间的连接。当成功断开与主程序之间的连接，Launcher就会等待程序中所有的非守护线程（non-daemon）全部执行结束，然后对jvm进行销毁，调用DestroyJavaVM</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Always detach the main thread so that it appears to have ended when</span></span><br><span class="line"><span class="comment"> * the application&#x27;s main method exits.  This will invoke the</span></span><br><span class="line"><span class="comment"> * uncaught exception handler machinery if main threw an</span></span><br><span class="line"><span class="comment"> * exception.  An uncaught exception handler cannot change the</span></span><br><span class="line"><span class="comment"> * launcher&#x27;s return code except by calling System.exit.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Wait for all non-daemon threads to end, then destroy the VM.</span></span><br><span class="line"><span class="comment"> * This will actually create a trivial new Java waiter thread</span></span><br><span class="line"><span class="comment"> * named &quot;DestroyJavaVM&quot;, but this will be seen as a different</span></span><br><span class="line"><span class="comment"> * thread from the one that executed main, even though they are</span></span><br><span class="line"><span class="comment"> * the same C thread.  This allows mainThread.join() and</span></span><br><span class="line"><span class="comment"> * mainThread.isAlive() to work as expected.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEAVE() \</span></span><br><span class="line"><span class="meta">    do &#123; \</span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">if</span> ((*vm)-&gt;DetachCurrentThread(vm) != JNI_OK) &#123; \</span></span><br><span class="line"><span class="meta">            JLI_ReportErrorMessage(JVM_ERROR2); \</span></span><br><span class="line"><span class="meta">            ret = 1; \</span></span><br><span class="line"><span class="meta">        &#125; \</span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">if</span> (JNI_TRUE) &#123; \</span></span><br><span class="line"><span class="meta">            (*vm)-&gt;DestroyJavaVM(vm); \</span></span><br><span class="line"><span class="meta">            return ret; \</span></span><br><span class="line"><span class="meta">        &#125; \</span></span><br><span class="line"><span class="meta">    &#125; while (JNI_FALSE)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHECK_EXCEPTION_NULL_LEAVE(CENL_exception) \</span></span><br><span class="line"><span class="meta">    do &#123; \</span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">if</span> ((*env)-&gt;ExceptionOccurred(env)) &#123; \</span></span><br><span class="line"><span class="meta">            JLI_ReportExceptionDescription(env); \</span></span><br><span class="line"><span class="meta">            LEAVE(); \</span></span><br><span class="line"><span class="meta">        &#125; \</span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">if</span> ((CENL_exception) == NULL) &#123; \</span></span><br><span class="line"><span class="meta">            JLI_ReportErrorMessage(JNI_ERROR); \</span></span><br><span class="line"><span class="meta">            LEAVE(); \</span></span><br><span class="line"><span class="meta">        &#125; \</span></span><br><span class="line"><span class="meta">    &#125; while (JNI_FALSE)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHECK_EXCEPTION_LEAVE(CEL_return_value) \</span></span><br><span class="line"><span class="meta">    do &#123; \</span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">if</span> ((*env)-&gt;ExceptionOccurred(env)) &#123; \</span></span><br><span class="line"><span class="meta">            JLI_ReportExceptionDescription(env); \</span></span><br><span class="line"><span class="meta">            ret = (CEL_return_value); \</span></span><br><span class="line"><span class="meta">            LEAVE(); \</span></span><br><span class="line"><span class="meta">        &#125; \</span></span><br><span class="line"><span class="meta">    &#125; while (JNI_FALSE)</span></span><br></pre></td></tr></table></figure><ol start="6"><li>InitializeJVM函数</li></ol><p>初始化java虚拟机<br>这里需要看下InvocationFunctions ifn函数的结构，然后就比较好理解了。之前对函数的赋值，然后创建虚拟机时调用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    CreateJavaVM_t CreateJavaVM;</span><br><span class="line">    GetDefaultJavaVMInitArgs_t GetDefaultJavaVMInitArgs;</span><br><span class="line">    GetCreatedJavaVMs_t GetCreatedJavaVMs;</span><br><span class="line">&#125; InvocationFunctions;</span><br></pre></td></tr></table></figure><p>见InitializeJVM函数主代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Initializes the Java Virtual Machine. Also frees options array when</span></span><br><span class="line"><span class="comment"> * finished.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> jboolean</span></span><br><span class="line"><span class="function"><span class="title">InitializeJVM</span><span class="params">(JavaVM **pvm, JNIEnv **penv, InvocationFunctions *ifn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    JavaVMInitArgs args;</span><br><span class="line">    jint r;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;args, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(args));</span><br><span class="line">    args.version  = JNI_VERSION_1_2;</span><br><span class="line">    args.nOptions = numOptions;</span><br><span class="line">    args.options  = options;</span><br><span class="line">    args.ignoreUnrecognized = JNI_FALSE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">JLI_IsTraceLauncher</span>()) &#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;JavaVM args:\n    &quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;version 0x%08lx, &quot;</span>, (<span class="keyword">long</span>)args.version);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ignoreUnrecognized is %s, &quot;</span>,</span><br><span class="line">               args.ignoreUnrecognized ? <span class="string">&quot;JNI_TRUE&quot;</span> : <span class="string">&quot;JNI_FALSE&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;nOptions is %ld\n&quot;</span>, (<span class="keyword">long</span>)args.nOptions);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; numOptions; i++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;    option[%2d] = &#x27;%s&#x27;\n&quot;</span>,</span><br><span class="line">                   i, args.options[i].optionString);</span><br><span class="line">    &#125;</span><br><span class="line"># 调用InvocationFunctions函数创建java虚拟机</span><br><span class="line">    r = ifn-&gt;<span class="built_in">CreateJavaVM</span>(pvm, (<span class="keyword">void</span> **)penv, &amp;args);</span><br><span class="line">    <span class="built_in">JLI_MemFree</span>(options);</span><br><span class="line">    <span class="keyword">return</span> r == JNI_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="7"><li>LoadMainClass函数</li></ol><p>获取java程序启动类和方法，然后调用CallStaticObjectMethod方法，该函数会调用到jni_invoke_static方法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Loads a class and verifies that the main class is present and it is ok to</span></span><br><span class="line"><span class="comment"> * call it for more details refer to the java implementation.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> jclass</span></span><br><span class="line"><span class="function"><span class="title">LoadMainClass</span><span class="params">(JNIEnv *env, <span class="keyword">int</span> mode, <span class="keyword">char</span> *name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    jmethodID mid;</span><br><span class="line">    jstring str;</span><br><span class="line">    jobject result;</span><br><span class="line">    jlong start, end;</span><br><span class="line">    jclass cls = <span class="built_in">GetLauncherHelperClass</span>(env);</span><br><span class="line">    <span class="built_in">NULL_CHECK0</span>(cls);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">JLI_IsTraceLauncher</span>()) &#123;</span><br><span class="line">        start = <span class="built_in">CounterGet</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NULL_CHECK0</span>(mid = (*env)-&gt;<span class="built_in">GetStaticMethodID</span>(env, cls,</span><br><span class="line">                <span class="string">&quot;checkAndLoadMain&quot;</span>,</span><br><span class="line">                <span class="string">&quot;(ZILjava/lang/String;)Ljava/lang/Class;&quot;</span>));</span><br><span class="line"></span><br><span class="line">    str = <span class="built_in">NewPlatformString</span>(env, name);</span><br><span class="line">    result = (*env)-&gt;<span class="built_in">CallStaticObjectMethod</span>(env, cls, mid, USE_STDERR, mode, str);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">JLI_IsTraceLauncher</span>()) &#123;</span><br><span class="line">        end   = <span class="built_in">CounterGet</span>();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%ld micro seconds to load main class\n&quot;</span>,</span><br><span class="line">               (<span class="keyword">long</span>)(jint)<span class="built_in">Counter2Micros</span>(end-start));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;----%s----\n&quot;</span>, JLDEBUG_ENV_ENTRY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (jclass)result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="8"><li>jni.cpp</li></ol><p>这里会调用JavaCalls::call，会调用到java主类。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">jni_invoke_static</span><span class="params">(JNIEnv *env, JavaValue* result, jobject receiver, JNICallType call_type, jmethodID method_id, JNI_ArgumentPusher *args, TRAPS)</span> </span>&#123;</span><br><span class="line">  <span class="function">methodHandle <span class="title">method</span><span class="params">(THREAD, Method::resolve_jmethod_id(method_id))</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create object to hold arguments for the JavaCall, and associate it with</span></span><br><span class="line">  <span class="comment">// the jni parser</span></span><br><span class="line">  <span class="function">ResourceMark <span class="title">rm</span><span class="params">(THREAD)</span></span>;</span><br><span class="line">  <span class="keyword">int</span> number_of_parameters = method-&gt;<span class="built_in">size_of_parameters</span>();</span><br><span class="line">  <span class="function">JavaCallArguments <span class="title">java_args</span><span class="params">(number_of_parameters)</span></span>;</span><br><span class="line">  args-&gt;<span class="built_in">set_java_argument_object</span>(&amp;java_args);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">assert</span>(method-&gt;<span class="built_in">is_static</span>(), <span class="string">&quot;method should be static&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Fill out JavaCallArguments object</span></span><br><span class="line">  args-&gt;<span class="built_in">iterate</span>( <span class="built_in">Fingerprinter</span>(method).<span class="built_in">fingerprint</span>() );</span><br><span class="line">  <span class="comment">// Initialize result type</span></span><br><span class="line">  result-&gt;<span class="built_in">set_type</span>(args-&gt;<span class="built_in">get_ret_type</span>());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Invoke the method. Result is returned as oop.</span></span><br><span class="line">  JavaCalls::<span class="built_in">call</span>(result, method, &amp;java_args, CHECK);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Convert result</span></span><br><span class="line">  <span class="keyword">if</span> (result-&gt;<span class="built_in">get_type</span>() == T_OBJECT || result-&gt;<span class="built_in">get_type</span>() == T_ARRAY) &#123;</span><br><span class="line">    result-&gt;<span class="built_in">set_jobject</span>(JNIHandles::<span class="built_in">make_local</span>(env, (oop) result-&gt;<span class="built_in">get_jobject</span>()));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>具体细节不用多扣，掌握流程和算法即可。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Launcher简介&quot;&gt;&lt;a href=&quot;#Launcher简介&quot; class=&quot;headerlink&quot; title=&quot;Launcher简介&quot;&gt;&lt;/a&gt;Launcher简介&lt;/h3&gt;&lt;p&gt;Launcher是一种用于启动jvm进程的启动器，关于Launcher的具体</summary>
      
    
    
    
    <category term="jvm" scheme="http://example.com/categories/jvm/"/>
    
    
    <category term="jvm" scheme="http://example.com/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>字节码文件</title>
    <link href="http://example.com/2021/03/01/%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6/"/>
    <id>http://example.com/2021/03/01/%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6/</id>
    <published>2021-03-01T08:22:00.000Z</published>
    <updated>2021-07-06T15:00:15.398Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>每一个字节码文件其实都对应着全局唯一的一个类或者接口的定义信息。<br>结构体中只有两种类型结构，分别是<font color='red'>无符号数</font>和<font color='red'>表</font>。</p><ol><li>无符号数<br>字节码文件中的“基本类型”，u1表示一个字节，无符号类型。u2表示二个字节，无符号类型。<br>u4表示四个字节，无符号类型。u8表示八个字节，无符号类型。</li><li>表<br>有多个无符号数或者其他表作为数据项构成的复合数据类型，所有表的后缀都是使用“_info”进行结尾</li></ol><h4 id="classFile"><a href="#classFile" class="headerlink" title="classFile"></a>classFile</h4><p>每个字节码文件都对应一个ClassFile的结构。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">ClassFile</span> &#123;</span><br><span class="line">        <span class="attribute">u4</span>               magic;</span><br><span class="line">        <span class="attribute">u2</span>               minor_version;</span><br><span class="line">       <span class="attribute">u2</span>                major_version;</span><br><span class="line">       <span class="attribute">u2</span>                constant_pool_count;</span><br><span class="line">       <span class="attribute">cp_info</span>           constant_pool[constant_pool_count-<span class="number">1</span>];</span><br><span class="line">       <span class="attribute">u2</span>                access_flags;</span><br><span class="line">       <span class="attribute">u2</span>                this_class;</span><br><span class="line">       <span class="attribute">u2</span>                super_class;</span><br><span class="line">       <span class="attribute">u2</span>                interfaces_count;</span><br><span class="line">       <span class="attribute">u2</span>                interfaces[interfaces_count];</span><br><span class="line">       <span class="attribute">u2</span>                fields_count;</span><br><span class="line">       <span class="attribute">field_info</span>        fields[fields_count];</span><br><span class="line">       <span class="attribute">u2</span>                methods_count;</span><br><span class="line">       <span class="attribute">method_info</span>       methods[methods_count];</span><br><span class="line">       <span class="attribute">u2</span>                attributes_count;</span><br><span class="line">       <span class="attribute">attribute_info</span>    attributes[attributes_count];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="magic-魔术"><a href="#magic-魔术" class="headerlink" title="magic(魔术)"></a>magic(魔术)</h4><p>一个有效的字节码文件的前4个自己为0xCAFEBABE。魔术就是jvm用于校验所读取的目标文件是一个有效且合法的字节码文件。</p><h4 id="minor-version-次版本号-和major-version-主版本号"><a href="#minor-version-次版本号-和major-version-主版本号" class="headerlink" title="minor_version(次版本号)和major_version(主版本号)"></a>minor_version(次版本号)和major_version(主版本号)</h4><p>紧跟在magic之后的4个字节就是编译的此版本号和主版本号，它们共同构成了字节码文件的版本号。比如主板号为M，次版本号m，那版本号为M.m。</p><blockquote><p>如果字节码文件的版本号超出jvm所能够处理的有效范围，那么java虚拟机将不会处理这个字节码文件</p></blockquote><h4 id="constant-pool-count-常量池数量-和constant-pool-常量池"><a href="#constant-pool-count-常量池数量-和constant-pool-常量池" class="headerlink" title="constant_pool_count(常量池数量)和constant_pool(常量池)"></a>constant_pool_count(常量池数量)和constant_pool(常量池)</h4><p>常量池是字节码文件中非常重要的数据结构，同时也是字节码文件中与其他结构关联最多和占用字节码空间最大的数据结构。<br>常量池主要用于存放字面量（Literal）和符号引用（Symbolic References）两大类数据常量，其访问方式是通过索引来访问的。</p><blockquote><p>常量池数量中的计数器并非是从0开始计数的，是从1开始计数的，这么做的目的就是为了满足后续其他数据结构在不引用常量池中的任何常量结构时，默认可以把常量池中的访问索引设置为0来表示</p></blockquote><p><b>字面量</b></p><ul><li>文字字符串</li><li>final常量值</li></ul><p><b>符号引用</b></p><ul><li>类和接口的全限定名</li><li>字段的名称和描述符</li><li>方法的名称和描述符</li></ul><blockquote><p>在C语言中，如果一个程序需要调用其他库中的函数，那么在链接时，该函数在库中的位置（即相对于库文件开头的偏移量）会被写在程序中，运行时直接去这个地址调用函数即可。但在java虚拟机在运行时，从常量池中获取出对应的符号引用，并经过解析阶段将这些符号引用全部转换为直接引用，java虚拟机才能正常使用。</p></blockquote><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">cp_info</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attribute">u1</span> tag;</span><br><span class="line">        <span class="attribute">u1</span> <span class="literal">info</span>[];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="access-flags-访问标志"><a href="#access-flags-访问标志" class="headerlink" title="access_flags(访问标志)"></a>access_flags(访问标志)</h4><p>访问标志主要就是用于表示某个类或者接口的访问权限</p><ul><li>文件时类还是接口</li><li>访问的修饰符是哪一种</li><li>是否有abstract关键字修饰的抽象类</li></ul><h4 id="this-class-类索引-和super-class-超类索引"><a href="#this-class-类索引-和super-class-超类索引" class="headerlink" title="this_class(类索引)和super_class(超类索引)"></a>this_class(类索引)和super_class(超类索引)</h4><p>类索引和超类索引各自会通过索引指向常量池列表中一个类型为CONSTANT_Class_info的常量结构。CONSTANT_Class_info由tag和name_index两部分构成。tag是一个具有CONSTANT_Class_info值的常量，而name_index则是一个指向常量池列表中类型为CONSTANT_Utf8_info常量结构的索引，通过这个索引值即可成功获取到CONSTANT_Utf8_info常量结构中的全限定名字符串。类索引用于确定当前类的全限定名，而超类索引则用于确定当前类的超类全限定名。</p><blockquote><p>由于java.lang.Object是所有类型的超类，那么如果一个类缺省并没有显示地继承任何超类，那么它的直接超类就应该是Object，其父类索引的值就为0</p></blockquote><h4 id="interfaces-count-接口数量-和interfaces-接口表"><a href="#interfaces-count-接口数量-和interfaces-接口表" class="headerlink" title="interfaces_count(接口数量)和interfaces(接口表)"></a>interfaces_count(接口数量)和interfaces(接口表)</h4><p>接口数量：用于表示当前类或者接口的直接超类接口数量</p><p>接口表：实际上则是一个数组集合，它包含了当前类或者接口在常量池列表中直接超类接口的索引集合，通过这个索引即可确定当前类或者接口的超类接口的全限定名</p><blockquote><p>字节码文件中，除了常量池计数器中的计数值从1开始，其余的数组集合类型都是从0开始</p></blockquote><h4 id="fields-count-字段数量-和fields-字段表"><a href="#fields-count-字段数量-和fields-字段表" class="headerlink" title="fields_count(字段数量)和fields(字段表)"></a>fields_count(字段数量)和fields(字段表)</h4><p>字段数量：表示一个字节码文件中的field_info表总数，也就是一个类中类变量和实例变量的数量总和<br>字段表：一个数组集合，字段表中的每一个成员都必须是一个field_info数据结构<br>field_info：用于表示一个字段的完整信息</p><ul><li>字段标识符</li><li>访问修饰符</li><li>是类变量还是实例变量(static)</li><li>是否是常量(final修饰符)<blockquote><p>字段表中所包含的字段信息仅限于当前类或者当前接口的所属字段，并不包含继承超类的字段信息</p></blockquote><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">field_info</span> &#123;</span><br><span class="line">        <span class="attribute">u2</span> access_flags;</span><br><span class="line">        <span class="attribute">u2</span> name_index;</span><br><span class="line">        <span class="attribute">u2</span> descriptor_index;</span><br><span class="line">        <span class="attribute">u2</span> attributes_count;</span><br><span class="line">        <span class="attribute">attribute_info</span> attributes[attributes_count];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="methods-count-方法数量-和methods-方法表"><a href="#methods-count-方法数量-和methods-方法表" class="headerlink" title="methods_count(方法数量)和methods(方法表)"></a>methods_count(方法数量)和methods(方法表)</h4><p>方法数量：一个字节码文件中的method_info表总数<br>方法表：是一个数组集合，方法表中的每一个成员都必须是一个method_info数据结构。<br>method_info：表示当前类或者接口中某个方法的完整描述</p><ul><li>方法标示符</li><li>方法的访问修饰符</li><li>方法的返回值类型</li><li>方法的参数信息<blockquote><p>方法表所包含的方法信息仅限于当前类或者接口中的所属方法，并不包含继承超类的方法信息</p></blockquote><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">method_info</span> &#123;</span><br><span class="line">        <span class="attribute">u2</span> access_flags;</span><br><span class="line">        <span class="attribute">u2</span> name_index;</span><br><span class="line">        <span class="attribute">u2</span> descriptor_index;</span><br><span class="line">        <span class="attribute">u2</span> attributes_count;</span><br><span class="line">        <span class="attribute">attribute_info</span> attributes[attributes_count];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="attributes-count-属性数量-和attributes-属性表"><a href="#attributes-count-属性数量-和attributes-属性表" class="headerlink" title="attributes_count(属性数量)和attributes(属性表)"></a>attributes_count(属性数量)和attributes(属性表)</h4>属性数量：标示当前字节码文件中的attribute_info表总数<br>属性表：一个数组集合，属性表中的每一个成员都必须是一个attribute_info数据结构。<br>每一个attribute_info表的第一项都是指向常量池列表中CONSTANT_Utf8_info的，该表给出了属性的名称<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">attribute_info</span> &#123;</span><br><span class="line">        <span class="attribute">u2</span> attribute_name_index;</span><br><span class="line">        <span class="attribute">u4</span> attribute_length;</span><br><span class="line">        <span class="attribute">u1</span> <span class="literal">info</span>[attribute_length];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;p&gt;每一个字节码文件其实都对应着全局唯一的一个类或者接口的定义信息。&lt;br&gt;结构体中只有两种类型结构，分别是&lt;font color=&#39;red&#39;&gt;</summary>
      
    
    
    
    <category term="jvm" scheme="http://example.com/categories/jvm/"/>
    
    
    <category term="jvm" scheme="http://example.com/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>字节码编译原理</title>
    <link href="http://example.com/2021/01/29/%E5%AD%97%E8%8A%82%E7%A0%81%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    <id>http://example.com/2021/01/29/%E5%AD%97%E8%8A%82%E7%A0%81%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/</id>
    <published>2021-01-29T08:44:00.000Z</published>
    <updated>2021-07-06T15:00:15.401Z</updated>
    
    <content type="html"><![CDATA[<h3 id="字节码"><a href="#字节码" class="headerlink" title="字节码"></a>字节码</h3><blockquote><p>一次编译，处处运行(write once,run anywhere)</p></blockquote><h3 id="1-前端编译器"><a href="#1-前端编译器" class="headerlink" title="1. 前端编译器"></a>1. 前端编译器</h3><blockquote><p>将java源码编译为字节码，前端编译器不会直接涉及编译优化等方面的技术，而是将这些具体的细节移交给Hotspot的Jit编译器负责。</p></blockquote><ul><li>javac<ul><li>配置在“PATH”环境变量中的javac编译器</li><li>全量式编译</li></ul></li><li>ECJ（eclipse compiler for java）<ul><li>eclipse使用的前端编译器是自主研发的</li><li>增量式编译，每次保存时编译方案是把未编译部分的源码逐行进行编译，效率高效，编译的质量也和javac相比大致还是一致的</li><li>其中tomcat编译jsp也是通过ECJ方式来编译，ECJ编译器也是开源的</li></ul></li></ul><h3 id="2-编译原理"><a href="#2-编译原理" class="headerlink" title="2. 编译原理"></a>2. 编译原理</h3><blockquote><p>javac编译器在将java源码编译为一个有效的字节码文件<br>主要的步骤：词法解析-&gt;语法解析-&gt;语义解析-&gt;生成字节码</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> javac 命令编译文件成字节码</span></span><br><span class="line">Usage: javac &lt;options&gt; &lt;source files&gt;</span><br><span class="line">where possible options include:</span><br><span class="line">  -g                         Generate all debugging info</span><br><span class="line">  -g:none                    Generate no debugging info</span><br><span class="line">  -g:&#123;lines,vars,source&#125;     Generate only some debugging info</span><br><span class="line">  -nowarn                    Generate no warnings</span><br><span class="line">  -verbose                   Output messages about what the compiler is doing</span><br><span class="line">  -deprecation               Output source locations where deprecated APIs are used</span><br><span class="line">  -classpath &lt;path&gt;          Specify where to find user class files and annotation processors</span><br><span class="line">  -cp &lt;path&gt;                 Specify where to find user class files and annotation processors</span><br><span class="line">  -sourcepath &lt;path&gt;         Specify where to find input source files</span><br><span class="line">  -bootclasspath &lt;path&gt;      Override location of bootstrap class files</span><br><span class="line">  -extdirs &lt;dirs&gt;            Override location of installed extensions</span><br><span class="line">  -endorseddirs &lt;dirs&gt;       Override location of endorsed standards path</span><br><span class="line">  -proc:&#123;none,only&#125;          Control whether annotation processing and/or compilation is done.</span><br><span class="line">  -processor &lt;class1&gt;[,&lt;class2&gt;,&lt;class3&gt;...] Names of the annotation processors to run; bypasses default discovery process</span><br><span class="line">  -processorpath &lt;path&gt;      Specify where to find annotation processors</span><br><span class="line">  -parameters                Generate metadata for reflection on method parameters</span><br><span class="line">  -d &lt;directory&gt;             Specify where to place generated class files</span><br><span class="line">  -s &lt;directory&gt;             Specify where to place generated source files</span><br><span class="line">  -h &lt;directory&gt;             Specify where to place generated native header files</span><br><span class="line">  -implicit:&#123;none,class&#125;     Specify whether or not to generate class files for implicitly referenced files</span><br><span class="line">  -encoding &lt;encoding&gt;       Specify character encoding used by source files</span><br><span class="line">  -source &lt;release&gt;          Provide source compatibility with specified release</span><br><span class="line">  -target &lt;release&gt;          Generate class files for specific VM version</span><br><span class="line">  -profile &lt;profile&gt;         Check that API used is available in the specified profile</span><br><span class="line">  -version                   Version information</span><br><span class="line">  -help                      Print a synopsis of standard options</span><br><span class="line">  -Akey[=value]              Options to pass to annotation processors</span><br><span class="line">  -X                         Print a synopsis of nonstandard options</span><br><span class="line">  -J&lt;flag&gt;                   Pass &lt;flag&gt; directly to the runtime system</span><br><span class="line">  -Werror                    Terminate compilation if warnings occur</span><br><span class="line">  @&lt;filename&gt;                Read options and filenames from file</span><br></pre></td></tr></table></figure><p><img src="/images/pasted-10.png" alt="字节码整体图"></p><h4 id="2-0-前提"><a href="#2-0-前提" class="headerlink" title="2.0 前提"></a>2.0 前提</h4><p>javac 代码在langtools/src/share/classes/com/sun/tools/javac目录下,见下图。<br>其中主要的是Main.java。这里解释下，hotspot最核心的还是c++以及混合少量的c和汇编语言编写，“外围”还是采用java语言编写。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Main entry point for the launcher.</span></span><br><span class="line"><span class="comment">     *  Note: This method calls System.exit.</span></span><br><span class="line"><span class="comment">     *  <span class="doctag">@param</span> args command line arguments</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.exit(compile(args));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Programmatic interface to the Java Programming Language</span></span><br><span class="line"><span class="comment">     * compiler, javac.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args The command line arguments that would normally be</span></span><br><span class="line"><span class="comment">     * passed to the javac program as described in the man page.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> an integer equivalent to the exit value from invoking</span></span><br><span class="line"><span class="comment">     * javac, see the man page for details.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">compile</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        com.sun.tools.javac.main.Main compiler =</span><br><span class="line">            <span class="keyword">new</span> com.sun.tools.javac.main.Main(<span class="string">&quot;javac&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> compiler.compile(args).exitCode;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    # 该类是com.sun.tools.javac.main.Main，其中的compile方法</span><br><span class="line">    <span class="comment">/** Programmatic interface for main function.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args    The command line parameters.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">compile</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Context context = <span class="keyword">new</span> Context();</span><br><span class="line">        JavacFileManager.preRegister(context); <span class="comment">// can&#x27;t create it until Log has been set up</span></span><br><span class="line">        Result result = compile(args, context);</span><br><span class="line">        <span class="keyword">if</span> (fileManager <span class="keyword">instanceof</span> JavacFileManager) &#123;</span><br><span class="line">            <span class="comment">// A fresh context was created above, so jfm must be a JavacFileManager</span></span><br><span class="line">            ((JavacFileManager)fileManager).close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="/images/pasted-12.png" alt="javac代码目录"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Parse contents of input stream.</span></span><br><span class="line"><span class="comment">     *  <span class="doctag">@param</span> filename     The name of the file from which input stream comes.</span></span><br><span class="line"><span class="comment">     *  <span class="doctag">@param</span> content      The characters to be parsed.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> JCCompilationUnit <span class="title">parse</span><span class="params">(JavaFileObject filename, CharSequence content)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> msec = now();</span><br><span class="line">        JCCompilationUnit tree = make.TopLevel(List.&lt;JCTree.JCAnnotation&gt;nil(),</span><br><span class="line">                                      <span class="keyword">null</span>, List.&lt;JCTree&gt;nil());</span><br><span class="line">        <span class="keyword">if</span> (content != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (verbose) &#123;</span><br><span class="line">                log.printVerbose(<span class="string">&quot;parsing.started&quot;</span>, filename);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!taskListener.isEmpty()) &#123;</span><br><span class="line">                TaskEvent e = <span class="keyword">new</span> TaskEvent(TaskEvent.Kind.PARSE, filename);</span><br><span class="line">                taskListener.started(e);</span><br><span class="line">                keepComments = <span class="keyword">true</span>;</span><br><span class="line">                genEndPos = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 获取JavacParser解析器</span></span><br><span class="line">            Parser parser = parserFactory.newParser(content, keepComments(), genEndPos, lineDebugInfo);</span><br><span class="line">            <span class="comment">// 词法分析&amp;语法分析</span></span><br><span class="line">            tree = parser.parseCompilationUnit();</span><br><span class="line">            <span class="keyword">if</span> (verbose) &#123;</span><br><span class="line">                log.printVerbose(<span class="string">&quot;parsing.done&quot;</span>, Long.toString(elapsed(msec)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        tree.sourcefile = filename;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (content != <span class="keyword">null</span> &amp;&amp; !taskListener.isEmpty()) &#123;</span><br><span class="line">            TaskEvent e = <span class="keyword">new</span> TaskEvent(TaskEvent.Kind.PARSE, tree);</span><br><span class="line">            taskListener.finished(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> tree;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**parserFactory.newParser 方法，其实内部包含了个Lexer接口，实现类为Scanner，而Scanner类主要任务就是按照单个字符的方式读取java源文件中的关键字和标示符，将其转换为符合java语法规范的Token序列 **/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> JavacParser <span class="title">newParser</span><span class="params">(CharSequence input, <span class="keyword">boolean</span> keepDocComments, <span class="keyword">boolean</span> keepEndPos, <span class="keyword">boolean</span> keepLineMap)</span> </span>&#123;</span><br><span class="line">        Lexer lexer = scannerFactory.newScanner(input, keepDocComments);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JavacParser(<span class="keyword">this</span>, lexer, keepDocComments, keepLineMap, keepEndPos);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** scannerFactory.newScanner方法 **/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Scanner <span class="title">newScanner</span><span class="params">(CharSequence input, <span class="keyword">boolean</span> keepDocComments)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (input <span class="keyword">instanceof</span> CharBuffer) &#123;</span><br><span class="line">            CharBuffer buf = (CharBuffer) input;</span><br><span class="line">            <span class="keyword">if</span> (keepDocComments)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Scanner(<span class="keyword">this</span>, <span class="keyword">new</span> JavadocTokenizer(<span class="keyword">this</span>, buf));</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Scanner(<span class="keyword">this</span>, buf);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">char</span>[] array = input.toString().toCharArray();</span><br><span class="line">            <span class="keyword">return</span> newScanner(array, array.length, keepDocComments);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Scanner <span class="title">newScanner</span><span class="params">(<span class="keyword">char</span>[] input, <span class="keyword">int</span> inputLength, <span class="keyword">boolean</span> keepDocComments)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (keepDocComments)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Scanner(<span class="keyword">this</span>, <span class="keyword">new</span> JavadocTokenizer(<span class="keyword">this</span>, input, inputLength));</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Scanner(<span class="keyword">this</span>, input, inputLength);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>看了上述代码，我们可以发现词法分析主要是在parser.parseCompilationUnit进行的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** CompilationUnit = [ &#123; &quot;@&quot; Annotation &#125; PACKAGE Qualident &quot;;&quot;] &#123;ImportDeclaration&#125; &#123;TypeDeclaration&#125;</span></span><br><span class="line"><span class="comment">     * 词法解析&amp;语法解析</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> JCTree.<span class="function">JCCompilationUnit <span class="title">parseCompilationUnit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Token firstToken = token;</span><br><span class="line">        JCExpression pid = <span class="keyword">null</span>;</span><br><span class="line">        JCModifiers mods = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">boolean</span> consumedToplevelDoc = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span> seenImport = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span> seenPackage = <span class="keyword">false</span>;</span><br><span class="line">        List&lt;JCAnnotation&gt; packageAnnotations = List.nil();</span><br><span class="line">        <span class="keyword">if</span> (token.kind == MONKEYS_AT)</span><br><span class="line">            mods = modifiersOpt();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// package 解析，词法分析token和语法分析</span></span><br><span class="line">        <span class="keyword">if</span> (token.kind == PACKAGE) &#123;</span><br><span class="line">            seenPackage = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (mods != <span class="keyword">null</span>) &#123;</span><br><span class="line">                checkNoMods(mods.flags);</span><br><span class="line">                packageAnnotations = mods.annotations;</span><br><span class="line">                mods = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 获取token</span></span><br><span class="line">            nextToken();</span><br><span class="line">            <span class="comment">// 解析package语法节点</span></span><br><span class="line">            pid = qualident(<span class="keyword">false</span>);</span><br><span class="line">            accept(SEMI);</span><br><span class="line">        &#125;</span><br><span class="line">        ListBuffer&lt;JCTree&gt; defs = <span class="keyword">new</span> ListBuffer&lt;JCTree&gt;();</span><br><span class="line">        <span class="keyword">boolean</span> checkForImports = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">boolean</span> firstTypeDecl = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (token.kind != EOF) &#123;</span><br><span class="line">            <span class="keyword">if</span> (token.pos &gt; <span class="number">0</span> &amp;&amp; token.pos &lt;= endPosTable.errorEndPos) &#123;</span><br><span class="line">                <span class="comment">// error recovery</span></span><br><span class="line">                skip(checkForImports, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">                <span class="keyword">if</span> (token.kind == EOF)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// import 解析，有可能会有多个import，循环</span></span><br><span class="line">            <span class="keyword">if</span> (checkForImports &amp;&amp; mods == <span class="keyword">null</span> &amp;&amp; token.kind == IMPORT) &#123;</span><br><span class="line">                seenImport = <span class="keyword">true</span>;</span><br><span class="line">                defs.append(importDeclaration());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// class主体解析</span></span><br><span class="line">                Comment docComment = token.comment(CommentStyle.JAVADOC);</span><br><span class="line">                <span class="keyword">if</span> (firstTypeDecl &amp;&amp; !seenImport &amp;&amp; !seenPackage) &#123;</span><br><span class="line">                    docComment = firstToken.comment(CommentStyle.JAVADOC);</span><br><span class="line">                    consumedToplevelDoc = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">/*解析类主体信息并转化为语法树*/</span></span><br><span class="line">                JCTree def = typeDeclaration(mods, docComment);</span><br><span class="line">                <span class="keyword">if</span> (def <span class="keyword">instanceof</span> JCExpressionStatement)</span><br><span class="line">                    def = ((JCExpressionStatement)def).expr;</span><br><span class="line">                defs.append(def);</span><br><span class="line">                <span class="keyword">if</span> (def <span class="keyword">instanceof</span> JCClassDecl)</span><br><span class="line">                    checkForImports = <span class="keyword">false</span>;</span><br><span class="line">                mods = <span class="keyword">null</span>;</span><br><span class="line">                firstTypeDecl = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 生成抽象语法树，每个语法节点都直接或间接地继承JCTree</span></span><br><span class="line">        JCTree.JCCompilationUnit toplevel = F.at(firstToken.pos).TopLevel(packageAnnotations, pid, defs.toList());</span><br><span class="line">        <span class="keyword">if</span> (!consumedToplevelDoc)</span><br><span class="line">            attach(toplevel, firstToken.comment(CommentStyle.JAVADOC));</span><br><span class="line">        <span class="keyword">if</span> (defs.isEmpty())</span><br><span class="line">            storeEnd(toplevel, S.prevToken().endPos);</span><br><span class="line">        <span class="keyword">if</span> (keepDocComments)</span><br><span class="line">            toplevel.docComments = docComments;</span><br><span class="line">        <span class="keyword">if</span> (keepLineMap)</span><br><span class="line">            toplevel.lineMap = S.getLineMap();</span><br><span class="line">        <span class="keyword">this</span>.endPosTable.setParser(<span class="keyword">null</span>); <span class="comment">// remove reference to parser</span></span><br><span class="line">        toplevel.endPositions = <span class="keyword">this</span>.endPosTable;</span><br><span class="line">        <span class="keyword">return</span> toplevel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>那哪里是词法分析具体代码呢？其实是在nextToken()进行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br></pre></td><td class="code"><pre><span class="line"># 当前是Scanner类</span><br><span class="line">   # S是Lexer接口，其实就是Scanner类</span><br><span class="line"></span><br><span class="line">   <span class="comment">/** Buffer of saved tokens (used during lookahead)</span></span><br><span class="line"><span class="comment">* list是顺序的</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   <span class="keyword">private</span> List&lt;Token&gt; savedTokens = <span class="keyword">new</span> ArrayList&lt;Token&gt;();</span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">public</span> Token <span class="title">token</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> token(<span class="number">0</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Token <span class="title">token</span><span class="params">(<span class="keyword">int</span> lookahead)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (lookahead == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> token;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           ensureLookahead(lookahead);</span><br><span class="line">           <span class="keyword">return</span> savedTokens.get(lookahead - <span class="number">1</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//where</span></span><br><span class="line">       <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureLookahead</span><span class="params">(<span class="keyword">int</span> lookahead)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = savedTokens.size() ; i &lt; lookahead ; i ++) &#123;</span><br><span class="line">               savedTokens.add(tokenizer.readToken());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nextToken</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       S.nextToken();</span><br><span class="line">       token = S.token();</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   # tokenizer 是 JavaTokenizer类，JavaTokenizer类是在Scanner中属性，创建实例的时候创建的的。</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nextToken</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       prevToken = token;</span><br><span class="line">       <span class="keyword">if</span> (!savedTokens.isEmpty()) &#123;</span><br><span class="line">           token = savedTokens.remove(<span class="number">0</span>);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">// 获取token</span></span><br><span class="line">           token = tokenizer.readToken();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">   # tokenizer.readToken() 方法，实际是在这里生成词法token</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Read token.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Token <span class="title">readToken</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       reader.sp = <span class="number">0</span>;</span><br><span class="line">       name = <span class="keyword">null</span>;</span><br><span class="line">       radix = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> endPos = <span class="number">0</span>;</span><br><span class="line">       List&lt;Comment&gt; comments = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           loop: <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">               pos = reader.bp;</span><br><span class="line">               <span class="keyword">switch</span> (reader.ch) &#123;</span><br><span class="line">               <span class="keyword">case</span> <span class="string">&#x27; &#x27;</span>: <span class="comment">// (Spec 3.6)</span></span><br><span class="line">               <span class="keyword">case</span> <span class="string">&#x27;\t&#x27;</span>: <span class="comment">// (Spec 3.6)</span></span><br><span class="line">               <span class="keyword">case</span> FF: <span class="comment">// (Spec 3.6)</span></span><br><span class="line">                   <span class="keyword">do</span> &#123;</span><br><span class="line">                       reader.scanChar();</span><br><span class="line">                   &#125; <span class="keyword">while</span> (reader.ch == <span class="string">&#x27; &#x27;</span> || reader.ch == <span class="string">&#x27;\t&#x27;</span> || reader.ch == FF);</span><br><span class="line">                   processWhiteSpace(pos, reader.bp);</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               <span class="keyword">case</span> LF: <span class="comment">// (Spec 3.4)</span></span><br><span class="line">                   reader.scanChar();</span><br><span class="line">                   processLineTerminator(pos, reader.bp);</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               <span class="keyword">case</span> CR: <span class="comment">// (Spec 3.4)</span></span><br><span class="line">                   reader.scanChar();</span><br><span class="line">                   <span class="keyword">if</span> (reader.ch == LF) &#123;</span><br><span class="line">                       reader.scanChar();</span><br><span class="line">                   &#125;</span><br><span class="line">                   processLineTerminator(pos, reader.bp);</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               <span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;B&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;C&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;D&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;E&#x27;</span>:</span><br><span class="line">               <span class="keyword">case</span> <span class="string">&#x27;F&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;G&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;H&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;I&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;J&#x27;</span>:</span><br><span class="line">               <span class="keyword">case</span> <span class="string">&#x27;K&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;L&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;M&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;N&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;O&#x27;</span>:</span><br><span class="line">               <span class="keyword">case</span> <span class="string">&#x27;P&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;Q&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;R&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;S&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;T&#x27;</span>:</span><br><span class="line">               <span class="keyword">case</span> <span class="string">&#x27;U&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;V&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;W&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;X&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;Y&#x27;</span>:</span><br><span class="line">               <span class="keyword">case</span> <span class="string">&#x27;Z&#x27;</span>:</span><br><span class="line">               <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;c&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;e&#x27;</span>:</span><br><span class="line">               <span class="keyword">case</span> <span class="string">&#x27;f&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;g&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;h&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;i&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;j&#x27;</span>:</span><br><span class="line">               <span class="keyword">case</span> <span class="string">&#x27;k&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;l&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;m&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;n&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;o&#x27;</span>:</span><br><span class="line">               <span class="keyword">case</span> <span class="string">&#x27;p&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;q&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;r&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;t&#x27;</span>:</span><br><span class="line">               <span class="keyword">case</span> <span class="string">&#x27;u&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;v&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;w&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;x&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;y&#x27;</span>:</span><br><span class="line">               <span class="keyword">case</span> <span class="string">&#x27;z&#x27;</span>:</span><br><span class="line">               <span class="keyword">case</span> <span class="string">&#x27;$&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;_&#x27;</span>:</span><br><span class="line">                   <span class="comment">// 设置Name</span></span><br><span class="line">                   scanIdent();</span><br><span class="line">                   <span class="keyword">break</span> loop;</span><br><span class="line">               <span class="keyword">case</span> <span class="string">&#x27;0&#x27;</span>:</span><br><span class="line">                   reader.scanChar();</span><br><span class="line">                   <span class="keyword">if</span> (reader.ch == <span class="string">&#x27;x&#x27;</span> || reader.ch == <span class="string">&#x27;X&#x27;</span>) &#123;</span><br><span class="line">                       reader.scanChar();</span><br><span class="line">                       skipIllegalUnderscores();</span><br><span class="line">                       <span class="keyword">if</span> (reader.ch == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                           scanHexFractionAndSuffix(pos, <span class="keyword">false</span>);</span><br><span class="line">                       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (reader.digit(pos, <span class="number">16</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                           lexError(pos, <span class="string">&quot;invalid.hex.number&quot;</span>);</span><br><span class="line">                       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                           scanNumber(pos, <span class="number">16</span>);</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (reader.ch == <span class="string">&#x27;b&#x27;</span> || reader.ch == <span class="string">&#x27;B&#x27;</span>) &#123;</span><br><span class="line">                       <span class="keyword">if</span> (!allowBinaryLiterals) &#123;</span><br><span class="line">                           lexError(pos, <span class="string">&quot;unsupported.binary.lit&quot;</span>, source.name);</span><br><span class="line">                           allowBinaryLiterals = <span class="keyword">true</span>;</span><br><span class="line">                       &#125;</span><br><span class="line">                       reader.scanChar();</span><br><span class="line">                       skipIllegalUnderscores();</span><br><span class="line">                       <span class="keyword">if</span> (reader.digit(pos, <span class="number">2</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                           lexError(pos, <span class="string">&quot;invalid.binary.number&quot;</span>);</span><br><span class="line">                       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                           scanNumber(pos, <span class="number">2</span>);</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                       reader.putChar(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                       <span class="keyword">if</span> (reader.ch == <span class="string">&#x27;_&#x27;</span>) &#123;</span><br><span class="line">                           <span class="keyword">int</span> savePos = reader.bp;</span><br><span class="line">                           <span class="keyword">do</span> &#123;</span><br><span class="line">                               reader.scanChar();</span><br><span class="line">                           &#125; <span class="keyword">while</span> (reader.ch == <span class="string">&#x27;_&#x27;</span>);</span><br><span class="line">                           <span class="keyword">if</span> (reader.digit(pos, <span class="number">10</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                               lexError(savePos, <span class="string">&quot;illegal.underscore&quot;</span>);</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                       scanNumber(pos, <span class="number">8</span>);</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="keyword">break</span> loop;</span><br><span class="line">               <span class="keyword">case</span> <span class="string">&#x27;1&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;2&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;3&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;4&#x27;</span>:</span><br><span class="line">               <span class="keyword">case</span> <span class="string">&#x27;5&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;6&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;7&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;8&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;9&#x27;</span>:</span><br><span class="line">                   scanNumber(pos, <span class="number">10</span>);</span><br><span class="line">                   <span class="keyword">break</span> loop;</span><br><span class="line">               <span class="keyword">case</span> <span class="string">&#x27;.&#x27;</span>:</span><br><span class="line">                   reader.scanChar();</span><br><span class="line">                   <span class="keyword">if</span> (<span class="string">&#x27;0&#x27;</span> &lt;= reader.ch &amp;&amp; reader.ch &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">                       reader.putChar(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">                       scanFractionAndSuffix(pos);</span><br><span class="line">                   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (reader.ch == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                       <span class="keyword">int</span> savePos = reader.bp;</span><br><span class="line">                       reader.putChar(<span class="string">&#x27;.&#x27;</span>); reader.putChar(<span class="string">&#x27;.&#x27;</span>, <span class="keyword">true</span>);</span><br><span class="line">                       <span class="keyword">if</span> (reader.ch == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                           reader.scanChar();</span><br><span class="line">                           reader.putChar(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">                           tk = TokenKind.ELLIPSIS;</span><br><span class="line">                       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                           lexError(savePos, <span class="string">&quot;illegal.dot&quot;</span>);</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                       tk = TokenKind.DOT;</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="keyword">break</span> loop;</span><br><span class="line">               <span class="keyword">case</span> <span class="string">&#x27;,&#x27;</span>:</span><br><span class="line">                   reader.scanChar(); tk = TokenKind.COMMA; <span class="keyword">break</span> loop;</span><br><span class="line">               <span class="keyword">case</span> <span class="string">&#x27;;&#x27;</span>:</span><br><span class="line">                   reader.scanChar(); tk = TokenKind.SEMI; <span class="keyword">break</span> loop;</span><br><span class="line">               <span class="keyword">case</span> <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">                   reader.scanChar(); tk = TokenKind.LPAREN; <span class="keyword">break</span> loop;</span><br><span class="line">               <span class="keyword">case</span> <span class="string">&#x27;)&#x27;</span>:</span><br><span class="line">                   reader.scanChar(); tk = TokenKind.RPAREN; <span class="keyword">break</span> loop;</span><br><span class="line">               <span class="keyword">case</span> <span class="string">&#x27;[&#x27;</span>:</span><br><span class="line">                   reader.scanChar(); tk = TokenKind.LBRACKET; <span class="keyword">break</span> loop;</span><br><span class="line">               <span class="keyword">case</span> <span class="string">&#x27;]&#x27;</span>:</span><br><span class="line">                   reader.scanChar(); tk = TokenKind.RBRACKET; <span class="keyword">break</span> loop;</span><br><span class="line">               <span class="keyword">case</span> <span class="string">&#x27;&#123;&#x27;</span>:</span><br><span class="line">                   reader.scanChar(); tk = TokenKind.LBRACE; <span class="keyword">break</span> loop;</span><br><span class="line">               <span class="keyword">case</span> <span class="string">&#x27;&#125;&#x27;</span>:</span><br><span class="line">                   reader.scanChar(); tk = TokenKind.RBRACE; <span class="keyword">break</span> loop;</span><br><span class="line">               <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">                   reader.scanChar();</span><br><span class="line">                   <span class="keyword">if</span> (reader.ch == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">                       <span class="keyword">do</span> &#123;</span><br><span class="line">                           reader.scanCommentChar();</span><br><span class="line">                       &#125; <span class="keyword">while</span> (reader.ch != CR &amp;&amp; reader.ch != LF &amp;&amp; reader.bp &lt; reader.buflen);</span><br><span class="line">                       <span class="keyword">if</span> (reader.bp &lt; reader.buflen) &#123;</span><br><span class="line">                           comments = addComment(comments, processComment(pos, reader.bp, CommentStyle.LINE));</span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (reader.ch == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                       <span class="keyword">boolean</span> isEmpty = <span class="keyword">false</span>;</span><br><span class="line">                       reader.scanChar();</span><br><span class="line">                       CommentStyle style;</span><br><span class="line">                       <span class="keyword">if</span> (reader.ch == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                           style = CommentStyle.JAVADOC;</span><br><span class="line">                           reader.scanCommentChar();</span><br><span class="line">                           <span class="keyword">if</span> (reader.ch == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">                               isEmpty = <span class="keyword">true</span>;</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                           style = CommentStyle.BLOCK;</span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="keyword">while</span> (!isEmpty &amp;&amp; reader.bp &lt; reader.buflen) &#123;</span><br><span class="line">                           <span class="keyword">if</span> (reader.ch == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                               reader.scanChar();</span><br><span class="line">                               <span class="keyword">if</span> (reader.ch == <span class="string">&#x27;/&#x27;</span>) <span class="keyword">break</span>;</span><br><span class="line">                           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                               reader.scanCommentChar();</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="keyword">if</span> (reader.ch == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">                           reader.scanChar();</span><br><span class="line">                           comments = addComment(comments, processComment(pos, reader.bp, style));</span><br><span class="line">                           <span class="keyword">break</span>;</span><br><span class="line">                       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                           lexError(pos, <span class="string">&quot;unclosed.comment&quot;</span>);</span><br><span class="line">                           <span class="keyword">break</span> loop;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (reader.ch == <span class="string">&#x27;=&#x27;</span>) &#123;</span><br><span class="line">                       tk = TokenKind.SLASHEQ;</span><br><span class="line">                       reader.scanChar();</span><br><span class="line">                   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                       tk = TokenKind.SLASH;</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="keyword">break</span> loop;</span><br><span class="line">               <span class="keyword">case</span> <span class="string">&#x27;\&#x27;&#x27;</span>:</span><br><span class="line">                   reader.scanChar();</span><br><span class="line">                   <span class="keyword">if</span> (reader.ch == <span class="string">&#x27;\&#x27;&#x27;</span>) &#123;</span><br><span class="line">                       lexError(pos, <span class="string">&quot;empty.char.lit&quot;</span>);</span><br><span class="line">                   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                       <span class="keyword">if</span> (reader.ch == CR || reader.ch == LF)</span><br><span class="line">                           lexError(pos, <span class="string">&quot;illegal.line.end.in.char.lit&quot;</span>);</span><br><span class="line">                       scanLitChar(pos);</span><br><span class="line">                       <span class="keyword">char</span> ch2 = reader.ch;</span><br><span class="line">                       <span class="keyword">if</span> (reader.ch == <span class="string">&#x27;\&#x27;&#x27;</span>) &#123;</span><br><span class="line">                           reader.scanChar();</span><br><span class="line">                           tk = TokenKind.CHARLITERAL;</span><br><span class="line">                       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                           lexError(pos, <span class="string">&quot;unclosed.char.lit&quot;</span>);</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="keyword">break</span> loop;</span><br><span class="line">               <span class="keyword">case</span> <span class="string">&#x27;\&quot;&#x27;</span>:</span><br><span class="line">                   reader.scanChar();</span><br><span class="line">                   <span class="keyword">while</span> (reader.ch != <span class="string">&#x27;\&quot;&#x27;</span> &amp;&amp; reader.ch != CR &amp;&amp; reader.ch != LF &amp;&amp; reader.bp &lt; reader.buflen)</span><br><span class="line">                       scanLitChar(pos);</span><br><span class="line">                   <span class="keyword">if</span> (reader.ch == <span class="string">&#x27;\&quot;&#x27;</span>) &#123;</span><br><span class="line">                       tk = TokenKind.STRINGLITERAL;</span><br><span class="line">                       reader.scanChar();</span><br><span class="line">                   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                       lexError(pos, <span class="string">&quot;unclosed.str.lit&quot;</span>);</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="keyword">break</span> loop;</span><br><span class="line">               <span class="keyword">default</span>:</span><br><span class="line">                   <span class="keyword">if</span> (isSpecial(reader.ch)) &#123;</span><br><span class="line">                       scanOperator();</span><br><span class="line">                   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                       <span class="keyword">boolean</span> isJavaIdentifierStart;</span><br><span class="line">                       <span class="keyword">if</span> (reader.ch &lt; <span class="string">&#x27;\u0080&#x27;</span>) &#123;</span><br><span class="line">                           <span class="comment">// all ASCII range chars already handled, above</span></span><br><span class="line">                           isJavaIdentifierStart = <span class="keyword">false</span>;</span><br><span class="line">                       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                           <span class="keyword">char</span> high = reader.scanSurrogates();</span><br><span class="line">                           <span class="keyword">if</span> (high != <span class="number">0</span>) &#123;</span><br><span class="line">                               reader.putChar(high);</span><br><span class="line"></span><br><span class="line">                               isJavaIdentifierStart = Character.isJavaIdentifierStart(</span><br><span class="line">                                   Character.toCodePoint(high, reader.ch));</span><br><span class="line">                           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                               isJavaIdentifierStart = Character.isJavaIdentifierStart(reader.ch);</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="keyword">if</span> (isJavaIdentifierStart) &#123;</span><br><span class="line">                           scanIdent();</span><br><span class="line">                       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (reader.bp == reader.buflen || reader.ch == EOI &amp;&amp; reader.bp + <span class="number">1</span> == reader.buflen) &#123; <span class="comment">// JLS 3.5</span></span><br><span class="line">                           tk = TokenKind.EOF;</span><br><span class="line">                           pos = reader.buflen;</span><br><span class="line">                       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                           String arg = (<span class="number">32</span> &lt; reader.ch &amp;&amp; reader.ch &lt; <span class="number">127</span>) ?</span><br><span class="line">                                           String.format(<span class="string">&quot;%s&quot;</span>, reader.ch) :</span><br><span class="line">                                           String.format(<span class="string">&quot;\\u%04x&quot;</span>, (<span class="keyword">int</span>)reader.ch);</span><br><span class="line">                           lexError(pos, <span class="string">&quot;illegal.char&quot;</span>, arg);</span><br><span class="line">                           reader.scanChar();</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="keyword">break</span> loop;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           endPos = reader.bp;</span><br><span class="line">           # hold on... ,这是生成token创建方法，NamedToken、StringToken、NumericToken都是实现Token类，NamedToken信息是在name里</span><br><span class="line">           <span class="keyword">switch</span> (tk.tag) &#123;</span><br><span class="line">               <span class="keyword">case</span> DEFAULT: <span class="keyword">return</span> <span class="keyword">new</span> Token(tk, pos, endPos, comments);</span><br><span class="line">               <span class="keyword">case</span> NAMED: <span class="keyword">return</span> <span class="keyword">new</span> NamedToken(tk, pos, endPos, name, comments);</span><br><span class="line">               <span class="keyword">case</span> STRING: <span class="keyword">return</span> <span class="keyword">new</span> StringToken(tk, pos, endPos, reader.chars(), comments);</span><br><span class="line">               <span class="keyword">case</span> NUMERIC: <span class="keyword">return</span> <span class="keyword">new</span> NumericToken(tk, pos, endPos, reader.chars(), radix, comments);</span><br><span class="line">               <span class="keyword">default</span>: <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (scannerDebug) &#123;</span><br><span class="line">                   System.out.println(<span class="string">&quot;nextToken(&quot;</span> + pos</span><br><span class="line">                                      + <span class="string">&quot;,&quot;</span> + endPos + <span class="string">&quot;)=|&quot;</span> +</span><br><span class="line">                                      <span class="keyword">new</span> String(reader.getRawCharacters(pos, endPos))</span><br><span class="line">                                      + <span class="string">&quot;|&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>那生成出来的Token是什么呢？其实就是一组对应源码字符集合的单词序列，其中Token会有TokenKind和Name，那TokenKind就是Token表示的类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This is the class representing a javac token. Each token has several fields</span></span><br><span class="line"><span class="comment">     * that are set by the javac lexer (i.e. start/end position, string value, etc).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Token</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** tags constants **/</span></span><br><span class="line">        <span class="class"><span class="keyword">enum</span> <span class="title">Tag</span> </span>&#123;</span><br><span class="line">            DEFAULT,</span><br><span class="line">            NAMED,</span><br><span class="line">            STRING,</span><br><span class="line">            NUMERIC;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** The token kind */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> TokenKind kind;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** The start position of this token */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> pos;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** The end position of this token */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> endPos;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** Comment reader associated with this token */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> List&lt;Comment&gt; comments;</span><br><span class="line"></span><br><span class="line">        Token(TokenKind kind, <span class="keyword">int</span> pos, <span class="keyword">int</span> endPos, List&lt;Comment&gt; comments) &#123;</span><br><span class="line">            <span class="keyword">this</span>.kind = kind;</span><br><span class="line">            <span class="keyword">this</span>.pos = pos;</span><br><span class="line">            <span class="keyword">this</span>.endPos = endPos;</span><br><span class="line">            <span class="keyword">this</span>.comments = comments;</span><br><span class="line">            checkKind();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Token[] split(Tokens tokens) &#123;</span><br><span class="line">            <span class="keyword">if</span> (kind.name.length() &lt; <span class="number">2</span> || kind.tag != Tag.DEFAULT) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(<span class="string">&quot;Cant split&quot;</span> + kind);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            TokenKind t1 = tokens.lookupKind(kind.name.substring(<span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">            TokenKind t2 = tokens.lookupKind(kind.name.substring(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (t1 == <span class="keyword">null</span> || t2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(<span class="string">&quot;Cant split - bad subtokens&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Token[] &#123;</span><br><span class="line">                <span class="keyword">new</span> Token(t1, pos, pos + t1.name.length(), comments),</span><br><span class="line">                <span class="keyword">new</span> Token(t2, pos + t1.name.length(), endPos, <span class="keyword">null</span>)</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">checkKind</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (kind.tag != Tag.DEFAULT) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(<span class="string">&quot;Bad token kind - expected &quot;</span> + Tag.STRING);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Name <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">stringVal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">radix</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Preserve classic semantics - if multiple javadocs are found on the token</span></span><br><span class="line"><span class="comment">         * the last one is returned</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Comment <span class="title">comment</span><span class="params">(Comment.CommentStyle style)</span> </span>&#123;</span><br><span class="line">            List&lt;Comment&gt; comments = getComments(Comment.CommentStyle.JAVADOC);</span><br><span class="line">            <span class="keyword">return</span> comments.isEmpty() ?</span><br><span class="line">                    <span class="keyword">null</span> :</span><br><span class="line">                    comments.head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Preserve classic semantics - deprecated should be set if at least one</span></span><br><span class="line"><span class="comment">         * javadoc comment attached to this token contains the &#x27;<span class="doctag">@deprecated</span>&#x27; string</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">deprecatedFlag</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (Comment c : getComments(Comment.CommentStyle.JAVADOC)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (c.isDeprecated()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> List&lt;Comment&gt; <span class="title">getComments</span><span class="params">(Comment.CommentStyle style)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (comments == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> List.nil();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ListBuffer&lt;Comment&gt; buf = <span class="keyword">new</span> ListBuffer&lt;&gt;();</span><br><span class="line">                <span class="keyword">for</span> (Comment c : comments) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (c.getStyle() == style) &#123;</span><br><span class="line">                        buf.add(c);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> buf.toList();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"># TokenKind，这个就是表示Token类型，TokenKind类型中Named tag类型，除了IDENTIFIER没有String name字段属性的标识的，其他都有。</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This enum defines all tokens used by the javac scanner. A token is</span></span><br><span class="line"><span class="comment">     * optionally associated with a name.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">TokenKind</span> <span class="keyword">implements</span> <span class="title">Formattable</span>, <span class="title">Filter</span>&lt;<span class="title">TokenKind</span>&gt; </span>&#123;</span><br><span class="line">        EOF(),</span><br><span class="line">        ERROR(),</span><br><span class="line">        IDENTIFIER(Tag.NAMED),</span><br><span class="line">        ABSTRACT(<span class="string">&quot;abstract&quot;</span>),</span><br><span class="line">        ASSERT(<span class="string">&quot;assert&quot;</span>, Tag.NAMED),</span><br><span class="line">        BOOLEAN(<span class="string">&quot;boolean&quot;</span>, Tag.NAMED),</span><br><span class="line">        BREAK(<span class="string">&quot;break&quot;</span>),</span><br><span class="line">        BYTE(<span class="string">&quot;byte&quot;</span>, Tag.NAMED),</span><br><span class="line">        CASE(<span class="string">&quot;case&quot;</span>),</span><br><span class="line">        CATCH(<span class="string">&quot;catch&quot;</span>),</span><br><span class="line">        CHAR(<span class="string">&quot;char&quot;</span>, Tag.NAMED),</span><br><span class="line">        CLASS(<span class="string">&quot;class&quot;</span>),</span><br><span class="line">        CONST(<span class="string">&quot;const&quot;</span>),</span><br><span class="line">        CONTINUE(<span class="string">&quot;continue&quot;</span>),</span><br><span class="line">        DEFAULT(<span class="string">&quot;default&quot;</span>),</span><br><span class="line">        DO(<span class="string">&quot;do&quot;</span>),</span><br><span class="line">        DOUBLE(<span class="string">&quot;double&quot;</span>, Tag.NAMED),</span><br><span class="line">        ELSE(<span class="string">&quot;else&quot;</span>),</span><br><span class="line">        ENUM(<span class="string">&quot;enum&quot;</span>, Tag.NAMED),</span><br><span class="line">        EXTENDS(<span class="string">&quot;extends&quot;</span>),</span><br><span class="line">        FINAL(<span class="string">&quot;final&quot;</span>),</span><br><span class="line">        FINALLY(<span class="string">&quot;finally&quot;</span>),</span><br><span class="line">        FLOAT(<span class="string">&quot;float&quot;</span>, Tag.NAMED),</span><br><span class="line">        FOR(<span class="string">&quot;for&quot;</span>),</span><br><span class="line">        GOTO(<span class="string">&quot;goto&quot;</span>),</span><br><span class="line">        IF(<span class="string">&quot;if&quot;</span>),</span><br><span class="line">        IMPLEMENTS(<span class="string">&quot;implements&quot;</span>),</span><br><span class="line">        IMPORT(<span class="string">&quot;import&quot;</span>),</span><br><span class="line">        INSTANCEOF(<span class="string">&quot;instanceof&quot;</span>),</span><br><span class="line">        INT(<span class="string">&quot;int&quot;</span>, Tag.NAMED),</span><br><span class="line">        INTERFACE(<span class="string">&quot;interface&quot;</span>),</span><br><span class="line">        LONG(<span class="string">&quot;long&quot;</span>, Tag.NAMED),</span><br><span class="line">        NATIVE(<span class="string">&quot;native&quot;</span>),</span><br><span class="line">        NEW(<span class="string">&quot;new&quot;</span>),</span><br><span class="line">        PACKAGE(<span class="string">&quot;package&quot;</span>),</span><br><span class="line">        PRIVATE(<span class="string">&quot;private&quot;</span>),</span><br><span class="line">        PROTECTED(<span class="string">&quot;protected&quot;</span>),</span><br><span class="line">        PUBLIC(<span class="string">&quot;public&quot;</span>),</span><br><span class="line">        RETURN(<span class="string">&quot;return&quot;</span>),</span><br><span class="line">        SHORT(<span class="string">&quot;short&quot;</span>, Tag.NAMED),</span><br><span class="line">        STATIC(<span class="string">&quot;static&quot;</span>),</span><br><span class="line">        STRICTFP(<span class="string">&quot;strictfp&quot;</span>),</span><br><span class="line">        SUPER(<span class="string">&quot;super&quot;</span>, Tag.NAMED),</span><br><span class="line">        SWITCH(<span class="string">&quot;switch&quot;</span>),</span><br><span class="line">        SYNCHRONIZED(<span class="string">&quot;synchronized&quot;</span>),</span><br><span class="line">        THIS(<span class="string">&quot;this&quot;</span>, Tag.NAMED),</span><br><span class="line">        THROW(<span class="string">&quot;throw&quot;</span>),</span><br><span class="line">        THROWS(<span class="string">&quot;throws&quot;</span>),</span><br><span class="line">        TRANSIENT(<span class="string">&quot;transient&quot;</span>),</span><br><span class="line">        TRY(<span class="string">&quot;try&quot;</span>),</span><br><span class="line">        VOID(<span class="string">&quot;void&quot;</span>, Tag.NAMED),</span><br><span class="line">        VOLATILE(<span class="string">&quot;volatile&quot;</span>),</span><br><span class="line">        WHILE(<span class="string">&quot;while&quot;</span>),</span><br><span class="line">        INTLITERAL(Tag.NUMERIC),</span><br><span class="line">        LONGLITERAL(Tag.NUMERIC),</span><br><span class="line">        FLOATLITERAL(Tag.NUMERIC),</span><br><span class="line">        DOUBLELITERAL(Tag.NUMERIC),</span><br><span class="line">        CHARLITERAL(Tag.NUMERIC),</span><br><span class="line">        STRINGLITERAL(Tag.STRING),</span><br><span class="line">        TRUE(<span class="string">&quot;true&quot;</span>, Tag.NAMED),</span><br><span class="line">        FALSE(<span class="string">&quot;false&quot;</span>, Tag.NAMED),</span><br><span class="line">        NULL(<span class="string">&quot;null&quot;</span>, Tag.NAMED),</span><br><span class="line">        UNDERSCORE(<span class="string">&quot;_&quot;</span>, Tag.NAMED),</span><br><span class="line">        ARROW(<span class="string">&quot;-&gt;&quot;</span>),</span><br><span class="line">        COLCOL(<span class="string">&quot;::&quot;</span>),</span><br><span class="line">        LPAREN(<span class="string">&quot;(&quot;</span>),</span><br><span class="line">        RPAREN(<span class="string">&quot;)&quot;</span>),</span><br><span class="line">        LBRACE(<span class="string">&quot;&#123;&quot;</span>),</span><br><span class="line">        RBRACE(<span class="string">&quot;&#125;&quot;</span>),</span><br><span class="line">        LBRACKET(<span class="string">&quot;[&quot;</span>),</span><br><span class="line">        RBRACKET(<span class="string">&quot;]&quot;</span>),</span><br><span class="line">        SEMI(<span class="string">&quot;;&quot;</span>),</span><br><span class="line">        COMMA(<span class="string">&quot;,&quot;</span>),</span><br><span class="line">        DOT(<span class="string">&quot;.&quot;</span>),</span><br><span class="line">        ELLIPSIS(<span class="string">&quot;...&quot;</span>),</span><br><span class="line">        EQ(<span class="string">&quot;=&quot;</span>),</span><br><span class="line">        GT(<span class="string">&quot;&gt;&quot;</span>),</span><br><span class="line">        LT(<span class="string">&quot;&lt;&quot;</span>),</span><br><span class="line">        BANG(<span class="string">&quot;!&quot;</span>),</span><br><span class="line">        TILDE(<span class="string">&quot;~&quot;</span>),</span><br><span class="line">        QUES(<span class="string">&quot;?&quot;</span>),</span><br><span class="line">        COLON(<span class="string">&quot;:&quot;</span>),</span><br><span class="line">        EQEQ(<span class="string">&quot;==&quot;</span>),</span><br><span class="line">        LTEQ(<span class="string">&quot;&lt;=&quot;</span>),</span><br><span class="line">        GTEQ(<span class="string">&quot;&gt;=&quot;</span>),</span><br><span class="line">        BANGEQ(<span class="string">&quot;!=&quot;</span>),</span><br><span class="line">        AMPAMP(<span class="string">&quot;&amp;&amp;&quot;</span>),</span><br><span class="line">        BARBAR(<span class="string">&quot;||&quot;</span>),</span><br><span class="line">        PLUSPLUS(<span class="string">&quot;++&quot;</span>),</span><br><span class="line">        SUBSUB(<span class="string">&quot;--&quot;</span>),</span><br><span class="line">        PLUS(<span class="string">&quot;+&quot;</span>),</span><br><span class="line">        SUB(<span class="string">&quot;-&quot;</span>),</span><br><span class="line">        STAR(<span class="string">&quot;*&quot;</span>),</span><br><span class="line">        SLASH(<span class="string">&quot;/&quot;</span>),</span><br><span class="line">        AMP(<span class="string">&quot;&amp;&quot;</span>),</span><br><span class="line">        BAR(<span class="string">&quot;|&quot;</span>),</span><br><span class="line">        CARET(<span class="string">&quot;^&quot;</span>),</span><br><span class="line">        PERCENT(<span class="string">&quot;%&quot;</span>),</span><br><span class="line">        LTLT(<span class="string">&quot;&lt;&lt;&quot;</span>),</span><br><span class="line">        GTGT(<span class="string">&quot;&gt;&gt;&quot;</span>),</span><br><span class="line">        GTGTGT(<span class="string">&quot;&gt;&gt;&gt;&quot;</span>),</span><br><span class="line">        PLUSEQ(<span class="string">&quot;+=&quot;</span>),</span><br><span class="line">        SUBEQ(<span class="string">&quot;-=&quot;</span>),</span><br><span class="line">        STAREQ(<span class="string">&quot;*=&quot;</span>),</span><br><span class="line">        SLASHEQ(<span class="string">&quot;/=&quot;</span>),</span><br><span class="line">        AMPEQ(<span class="string">&quot;&amp;=&quot;</span>),</span><br><span class="line">        BAREQ(<span class="string">&quot;|=&quot;</span>),</span><br><span class="line">        CARETEQ(<span class="string">&quot;^=&quot;</span>),</span><br><span class="line">        PERCENTEQ(<span class="string">&quot;%=&quot;</span>),</span><br><span class="line">        LTLTEQ(<span class="string">&quot;&lt;&lt;=&quot;</span>),</span><br><span class="line">        GTGTEQ(<span class="string">&quot;&gt;&gt;=&quot;</span>),</span><br><span class="line">        GTGTGTEQ(<span class="string">&quot;&gt;&gt;&gt;=&quot;</span>),</span><br><span class="line">        MONKEYS_AT(<span class="string">&quot;@&quot;</span>),</span><br><span class="line">        CUSTOM;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> String name;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> Tag tag;</span><br><span class="line"></span><br><span class="line">        TokenKind() &#123;</span><br><span class="line">            <span class="keyword">this</span>(<span class="keyword">null</span>, Tag.DEFAULT);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TokenKind(String name) &#123;</span><br><span class="line">            <span class="keyword">this</span>(name, Tag.DEFAULT);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TokenKind(Tag tag) &#123;</span><br><span class="line">            <span class="keyword">this</span>(<span class="keyword">null</span>, tag);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TokenKind(String name, Tag tag) &#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">            <span class="keyword">this</span>.tag = tag;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">switch</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">case</span> IDENTIFIER:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;token.identifier&quot;</span>;</span><br><span class="line">            <span class="keyword">case</span> CHARLITERAL:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;token.character&quot;</span>;</span><br><span class="line">            <span class="keyword">case</span> STRINGLITERAL:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;token.string&quot;</span>;</span><br><span class="line">            <span class="keyword">case</span> INTLITERAL:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;token.integer&quot;</span>;</span><br><span class="line">            <span class="keyword">case</span> LONGLITERAL:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;token.long-integer&quot;</span>;</span><br><span class="line">            <span class="keyword">case</span> FLOATLITERAL:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;token.float&quot;</span>;</span><br><span class="line">            <span class="keyword">case</span> DOUBLELITERAL:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;token.double&quot;</span>;</span><br><span class="line">            <span class="keyword">case</span> ERROR:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;token.bad-symbol&quot;</span>;</span><br><span class="line">            <span class="keyword">case</span> EOF:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;token.end-of-input&quot;</span>;</span><br><span class="line">            <span class="keyword">case</span> DOT: <span class="keyword">case</span> COMMA: <span class="keyword">case</span> SEMI: <span class="keyword">case</span> LPAREN: <span class="keyword">case</span> RPAREN:</span><br><span class="line">            <span class="keyword">case</span> LBRACKET: <span class="keyword">case</span> RBRACKET: <span class="keyword">case</span> LBRACE: <span class="keyword">case</span> RBRACE:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;&#x27;&quot;</span> + name + <span class="string">&quot;&#x27;&quot;</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> name;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getKind</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Token&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">(Locale locale, Messages messages)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> name != <span class="keyword">null</span> ? toString() : messages.getLocalizedString(locale, <span class="string">&quot;compiler.misc.&quot;</span> + toString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">accepts</span><span class="params">(TokenKind that)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span> == that;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="2-1-词法分析"><a href="#2-1-词法分析" class="headerlink" title="2.1 词法分析"></a>2.1 词法分析</h4><p>javac编译第一步，词法解析器最主要的任务就是将java源码中的关键字和标示符等内容转换为符合java语法规范的token序列，然后按照指定的顺序规则进行匹配校验，以便为后续的语法分析做准备。</p><p>那源码字符集合与Token之间的对应关系</p><ol><li>源码字符集合如何转换成Token?<br>看一下下面的代码，是Tokens来转换的</li><li>词法解析器又是采用什么方式保存源码字符集合与Token之间的对应关系?<br>词法解析器在将源码字符集合转换为Token序列之前，会将每一个字符集合转换为一个对应的name对象。Tokens会将Token中的所有枚举常量全部转换为Name对象，将其存储在对象的内部类Table中，这样一来源码字符集合与Token就有联系了。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 该类是Tokens，其中下面就是token和name转换映射</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Keyword array. Maps name indices to Token.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TokenKind[] key;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">     <span class="comment">/**根据Name来获取TokenKind，进而获取token</span></span><br><span class="line"><span class="comment">     * Create a new token given a name; if the name corresponds to a token name,</span></span><br><span class="line"><span class="comment">     * a new token of the corresponding kind is returned; otherwise, an</span></span><br><span class="line"><span class="comment">     * identifier token is returned.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">TokenKind <span class="title">lookupKind</span><span class="params">(Name name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (name.getIndex() &gt; maxKey) ? TokenKind.IDENTIFIER : key[name.getIndex()];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>举个例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> compile;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cifa</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">int</span> b=a+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/pasted-14.png" alt="词法分析图"></p><h4 id="2-2-语法分析"><a href="#2-2-语法分析" class="headerlink" title="2.2 语法分析"></a>2.2 语法分析</h4><p>目的：将进行词法分析后形成的Token流中的一个个Token组成一句句话，检查这一句句话是不是符合Java语言规范，形成抽象语法树。</p><p>流程：</p><ul><li>package</li><li>import</li><li>类（包含class、interface、enum），一下提到的类泛指这三类，并不单单是指class<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> compile;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Yufa</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> c = a + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//getter</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//setter</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setC</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.c = c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="/images/pasted-15.png" alt="抽象语法树"></p><h4 id="2-3-语义分析"><a href="#2-3-语义分析" class="headerlink" title="2.3 语义分析"></a>2.3 语义分析</h4><p>由于语法解析出来的抽象语法树并不能直接应用于生成字节码文件，这是因为这颗语法树相对来说还不是很完善，那语义分析就是将语法树扩充的更加完善，后续编译器将会使用语义解析后的语法树来生成字节码<br>将语法树转化为注解语法树</p><p>流程：</p><ul><li>添加默认的无参构造器（在没有指定任何有参构造器的情况下），把引用其他类的方法或者变量，抑或是继承实现来的变量和方法等输入到类自身的符号表中</li><li>处理注解</li><li>标注：检查语义合法性、进行逻辑判断<pre><code>  * 检查语法树中的变量类型是否匹配（eg.String s = 1 + 2;//这样&quot;=&quot;两端的类型就不匹配）  * 检查变量、方法或者类的访问是否合法（eg.一个类无法访问另一个类的private方法）  * 变量在使用前是否已经声明、是否初始化  * 常量折叠（eg.代码中：String s = &quot;hello&quot; + &quot;world&quot;，语义分析后String s = &quot;helloworld&quot;）  * 推导泛型方法的参数类型</code></pre></li><li>数据流分析<pre><code>  * 变量的确定性赋值（eg.有返回值的方法必须确定有返回值）  * final变量只能赋一次值，在编译的时候再赋值的话会报错  * 所有的检查型异常是否抛出或捕获  * 所有的语句都要被执行到（return后边的语句就不会被执行到，除了finally块儿）</code></pre></li><li>进一步语义分析<pre><code>  * 去掉永假代码（eg.if(false)）  * 变量自动转换（eg.int和Integer）自动装箱拆箱  * 去掉语法糖（eg.foreach转化为for循环，assert转化为if，内部类解析成一个与外部类相关联的外部类）</code></pre>最后，将经过上述处理的语法树转化为最后的注解语法树</li></ul><h4 id="2-4-生成字节码"><a href="#2-4-生成字节码" class="headerlink" title="2.4 生成字节码"></a>2.4 生成字节码</h4><p>目的：将注解语法树转化成字节码，并将字节码写入*.class文件。</p><p>流程：</p><ul><li>将java的代码块转化为符合JVM语法的命令形式，这就是字节码</li><li>按照JVM的文件组织格式将字节码输出到*.class文件中</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;字节码&quot;&gt;&lt;a href=&quot;#字节码&quot; class=&quot;headerlink&quot; title=&quot;字节码&quot;&gt;&lt;/a&gt;字节码&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;一次编译，处处运行(write once,run anywhere)&lt;/p&gt;
&lt;/blockquote&gt;
</summary>
      
    
    
    
    <category term="jvm" scheme="http://example.com/categories/jvm/"/>
    
    
    <category term="jvm" scheme="http://example.com/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>java概览</title>
    <link href="http://example.com/2021/01/29/%E5%AD%97%E8%8A%82%E7%A0%81/"/>
    <id>http://example.com/2021/01/29/%E5%AD%97%E8%8A%82%E7%A0%81/</id>
    <published>2021-01-29T06:38:00.000Z</published>
    <updated>2021-07-06T15:00:15.391Z</updated>
    
    <content type="html"><![CDATA[<h3 id="java概览"><a href="#java概览" class="headerlink" title="java概览"></a>java概览</h3><h4 id="1-重要概念"><a href="#1-重要概念" class="headerlink" title="1. 重要概念"></a>1. 重要概念</h4><ul><li>java编程语言</li><li>字节码</li><li>Java api</li><li>java虚拟机</li></ul><p><img src="/images/pasted-9.png" alt="1"></p><h4 id="1-1-字节码"><a href="#1-1-字节码" class="headerlink" title="1.1 字节码"></a>1.1 字节码</h4><h5 id="1-1-1-一次编译，处处运行-write-once-run-anywhere"><a href="#1-1-1-一次编译，处处运行-write-once-run-anywhere" class="headerlink" title="1.1.1 一次编译，处处运行(write once,run anywhere)"></a>1.1.1 一次编译，处处运行(write once,run anywhere)</h5><p>java源代码的默认编译结果并非是可执行的代码(本地机器指令)，而是具有平台通用性的字节码。尽管不同平台java虚拟机内部实现机制不尽相同，但是他们共同解释出的字节码是一样的。所以说字节码才是java实现跨平台的关键要素</p><p><img src="/images/pasted-5.png" alt="1.1.1"></p><h5 id="1-1-2-什么是字节码"><a href="#1-1-2-什么是字节码" class="headerlink" title="1.1.2 什么是字节码"></a>1.1.2 什么是字节码</h5><p>任何编程语言的编译结果满足并包含java虚拟机的内部指令集、符号表以及一些其他辅助信息，它就是一个有效的字节码文件，就能够被虚拟机所识别并装载运行。</p><h4 id="1-2-java虚拟机"><a href="#1-2-java虚拟机" class="headerlink" title="1.2 java虚拟机"></a>1.2 java虚拟机</h4><p><img src="/images/pasted-6.png" alt="1.2"></p><ul><li>Hotspot是最流行的java虚拟机<ul><li>当虚拟机启动的时候，解释器首先发挥作用，而不必等待编译器全部编译完成再执行，这样减少编译的时间</li><li>热点探测功能将一个被频繁调用的方法或者方法体中有效循环次数较多的代码块标记为“热点代码”，通过内嵌的双重JIT(just in time compiler)编译器将字节码直接编译为本地机器指令</li><li>即时编译器与解释器并存，通过编译器与解释器的协同工作，既可以保证程序的响应时间，同时还能够提高程序的执行性能，并且对编译器的工作压力也降低了一定程度的负载<br>   - 两个JIT分别是client compiler、server compiler，简称C1编译器和C2编译器。<ul><li>C1编译器会对字节码进行简单和可靠的优化，已达到更快的编译速度</li><li>C2编译器会启动一些编译耗时更长的优化，已获得更好的编译质量</li></ul></li><li>编译策略<ul><li>完全编译策略<ul><li>编译器</li><li>解释器在编译器无法进行的特殊情况会介入执行</li></ul></li><li>完全解释策略<ul><li>解释器</li></ul></li><li>默认编译策略<ul><li>hotspot会根据操作系统和机器性能来自动选择</li></ul></li></ul></li></ul></li></ul><p>    <br>    <br><img src="/images/pasted-8.png" alt="1.2"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;java概览&quot;&gt;&lt;a href=&quot;#java概览&quot; class=&quot;headerlink&quot; title=&quot;java概览&quot;&gt;&lt;/a&gt;java概览&lt;/h3&gt;&lt;h4 id=&quot;1-重要概念&quot;&gt;&lt;a href=&quot;#1-重要概念&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="jvm" scheme="http://example.com/categories/jvm/"/>
    
    
    <category term="jvm" scheme="http://example.com/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>JVM类加载原理</title>
    <link href="http://example.com/2021/01/27/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%8E%9F%E7%90%86/"/>
    <id>http://example.com/2021/01/27/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%8E%9F%E7%90%86/</id>
    <published>2021-01-27T14:43:00.000Z</published>
    <updated>2021-07-06T15:00:15.394Z</updated>
    
    <content type="html"><![CDATA[<h2 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h2><ol><li>类加载</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.classloader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.classloader.model.Student;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JvmClassLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> i = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Student student = <span class="keyword">new</span> Student();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">exec</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> (i + j) * <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        JvmClassLoader jvmClassLoader = <span class="keyword">new</span> JvmClassLoader();</span><br><span class="line">        <span class="keyword">int</span> exec = jvmClassLoader.exec();</span><br><span class="line">        System.out.println(exec);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -classpath selene-1.0.0.jar com.classloader.JvmClassLoader</span><br></pre></td></tr></table></figure><p>todo 持续跟进中……</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;类加载过程&quot;&gt;&lt;a href=&quot;#类加载过程&quot; class=&quot;headerlink&quot; title=&quot;类加载过程&quot;&gt;&lt;/a&gt;类加载过程&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;类加载&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table</summary>
      
    
    
    
    <category term="jvm" scheme="http://example.com/categories/jvm/"/>
    
    
    <category term="jvm" scheme="http://example.com/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>学习路径</title>
    <link href="http://example.com/2021/01/15/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E5%BE%84/"/>
    <id>http://example.com/2021/01/15/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E5%BE%84/</id>
    <published>2021-01-15T09:12:00.000Z</published>
    <updated>2021-07-06T15:00:15.398Z</updated>
    
    <content type="html"><![CDATA[<h4 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h4><blockquote><p>java.util包下的非线程安全集合和java.util.concurrent下的线程安全集合。</p></blockquote><h5 id="List"><a href="#List" class="headerlink" title="List"></a>List</h5><p>ArrayList与LinkedList的实现和区别</p><h5 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h5><p>HashMap：了解其数据结构、hash冲突如何解决（链表和红黑树）、扩容时机、扩容时避免rehash的优化</p><p>LinkedHashMap：了解基本原理、哪两种有序、如何用它实现LRU</p><p>TreeMap：了解数据结构、了解其key对象为什么必须要实现Compare接口、如何用它实现一致性哈希</p><h5 id="set"><a href="#set" class="headerlink" title="set"></a>set</h5><p>Set基本上都是由对应的map实现，简单看看就好</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">常见问题</span><br><span class="line"><span class="bullet">1.</span> hashmap如何解决hash冲突，为什么hashmap中的链表需要转成红黑树？</span><br><span class="line"><span class="bullet">2.</span> hashmap什么时候会触发扩容？</span><br><span class="line"><span class="bullet">3.</span> jdk1.8之前并发操作hashmap时为什么会有死循环的问题？</span><br><span class="line"><span class="bullet">4.</span> hashmap扩容时每个entry需要再计算一次hash吗？</span><br><span class="line"><span class="bullet">5.</span> hashmap的数组长度为什么要保证是2的幂？</span><br><span class="line"><span class="bullet">6.</span> 如何用LinkedHashMap实现LRU？</span><br><span class="line"><span class="bullet">7.</span> 如何用TreeMap实现一致性hash？</span><br></pre></td></tr></table></figure><h5 id="线程安全的集合"><a href="#线程安全的集合" class="headerlink" title="线程安全的集合"></a>线程安全的集合</h5><p>Collections.synchronized 了解其实现原理</p><h5 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h5><p>了解写时复制机制、了解其适用场景、思考为什么没有ConcurrentArrayList</p><h5 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h5><p>了解实现原理、扩容时做的优化、与HashTable对比</p><h5 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h5><p>了解LinkedBlockingQueue、ArrayBlockingQueue、DelayQueue、SynchronousQueue</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">常见问题</span><br><span class="line"><span class="bullet">1.</span> ConcurrentHashMap是如何在保证并发安全的同时提高性能？</span><br><span class="line"><span class="bullet">2.</span> ConcurrentHashMap是如何让多线程同时参与扩容？</span><br><span class="line"><span class="bullet">3.</span> LinkedBlockingQueue、DelayQueue是如何实现的？</span><br><span class="line"><span class="bullet">4.</span> CopyOnWriteArrayList是如何保证线程安全的？</span><br></pre></td></tr></table></figure><h4 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h4><h5 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h5><p>了解偏向锁、轻量级锁、重量级锁的概念以及升级机制、以及和ReentrantLock的区别</p><h5 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h5><p>了解AtomicInteger实现原理、CAS适用场景、如何实现乐观锁</p><h5 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h5><p>了解AQS内部实现、及依靠AQS的同步类比如ReentrantLock、Semaphore、CountDownLatch、CyclicBarrier等的实现</p><h5 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h5><p>了解ThreadLocal使用场景和内部实现</p><h5 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h5><p>了解线程池的工作原理以及几个重要参数的设置</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">常见问题</span><br><span class="line"><span class="bullet">1.</span> synchronized与ReentrantLock的区别？</span><br><span class="line"><span class="bullet">2.</span> 乐观锁和悲观锁的区别？</span><br><span class="line"><span class="bullet">3.</span> 如何实现一个乐观锁？</span><br><span class="line"><span class="bullet">4.</span> AQS是如何唤醒下一个线程的？</span><br><span class="line"><span class="bullet">5.</span> ReentrantLock如何实现公平和非公平锁是如何实现？</span><br><span class="line"><span class="bullet">6.</span> CountDownLatch和CyclicBarrier的区别？各自适用于什么场景？</span><br><span class="line"><span class="bullet">7.</span> 适用ThreadLocal时要注意什么？比如说内存泄漏?</span><br><span class="line"><span class="bullet">8.</span> 说一说往线程池里提交一个任务会发生什么？</span><br><span class="line"><span class="bullet">9.</span> 线程池的几个参数如何设置？</span><br><span class="line"><span class="bullet">10.</span> 线程池的非核心线程什么时候会被释放？</span><br><span class="line"><span class="bullet">11.</span> 如何排查死锁？</span><br></pre></td></tr></table></figure><h4 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h4><p>了解BIO和NIO的区别、了解多路复用机制</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">常见问题</span><br><span class="line"><span class="bullet">1.</span> 同步阻塞、同步非阻塞、异步的区别？</span><br><span class="line"><span class="bullet">2.</span> select、poll、eopll的区别？</span><br><span class="line"><span class="bullet">3.</span> java NIO与BIO的区别？</span><br><span class="line"><span class="bullet">4.</span> reactor线程模型是什么?</span><br></pre></td></tr></table></figure><h4 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h4><h5 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h5><p>了解Java中的软引用、弱引用、虚引用的适用场景以及释放机制</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">常见问题</span><br><span class="line"><span class="bullet">1.</span> 软引用什么时候会被释放</span><br><span class="line"><span class="bullet">2.</span> 弱引用什么时候会被释放</span><br></pre></td></tr></table></figure><h5 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h5><p>了解双亲委派机制</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">常见问题</span><br><span class="line"><span class="bullet">1.</span> 双亲委派机制的作用？</span><br><span class="line"><span class="bullet">2.</span> Tomcat的classloader结构</span><br><span class="line"><span class="bullet">3.</span> 如何自己实现一个classloader打破双亲委派</span><br></pre></td></tr></table></figure><h5 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h5><p>垃圾回收基本原理、几种常见的垃圾回收器的特性、重点了解CMS（或G1）以及一些重要的参数</p><h5 id="内存区域"><a href="#内存区域" class="headerlink" title="内存区域"></a>内存区域</h5><p>能说清jvm的内存划分</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">常见问题</span><br><span class="line"><span class="bullet">1.</span> CMS GC回收分为哪几个阶段？分别做了什么事情？</span><br><span class="line"><span class="bullet">2.</span> CMS有哪些重要参数？</span><br><span class="line"><span class="bullet">3.</span> Concurrent Model Failure和ParNew promotion failed什么情况下会发生？</span><br><span class="line"><span class="bullet">4.</span> CMS的优缺点？</span><br><span class="line"><span class="bullet">5.</span> 有做过哪些GC调优？</span><br><span class="line"><span class="bullet">6.</span> 为什么要划分成年轻代和老年代？</span><br><span class="line"><span class="bullet">7.</span> 年轻代为什么被划分成eden、survivor区域？</span><br><span class="line"><span class="bullet">8.</span> 年轻代为什么采用的是复制算法？</span><br><span class="line"><span class="bullet">9.</span> 老年代为什么采用的是标记清除、标记整理算法</span><br><span class="line"><span class="bullet">10.</span> 什么情况下使用堆外内存？要注意些什么？</span><br><span class="line"><span class="bullet">11.</span> 堆外内存如何被回收？</span><br><span class="line"><span class="bullet">12.</span> jvm内存区域划分是怎样的？</span><br></pre></td></tr></table></figure><h4 id="中间件、存储、以及框架"><a href="#中间件、存储、以及框架" class="headerlink" title="中间件、存储、以及框架"></a>中间件、存储、以及框架</h4><h5 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h5><p>bean的生命周期、循环依赖问题、spring cloud（如项目中有用过）、AOP的实现、spring事务传播</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">常见问题</span><br><span class="line"><span class="bullet">1.</span> java动态代理和cglib动态代理的区别（经常结合spring一起问所以就放这里了）</span><br><span class="line"><span class="bullet">2.</span> spring中bean的生命周期是怎样的？</span><br><span class="line"><span class="bullet">3.</span> 属性注入和构造器注入哪种会有循环依赖的问题？</span><br></pre></td></tr></table></figure><h5 id="Dubbo"><a href="#Dubbo" class="headerlink" title="Dubbo"></a>Dubbo</h5><p>了解一个常用RPC框架如Dubbo的实现：服务发现、路由、异步调用、限流降级、失败重试</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">常见问题</span><br><span class="line"><span class="bullet">1.</span> Dubbo如何做负载均衡？</span><br><span class="line"><span class="bullet">2.</span> Dubbo如何做限流降级？</span><br><span class="line"><span class="bullet">3.</span> Dubbo如何优雅的下线服务？</span><br><span class="line"><span class="bullet">4.</span> Dubbo如何实现异步调用的？</span><br></pre></td></tr></table></figure><h5 id="RocketMq"><a href="#RocketMq" class="headerlink" title="RocketMq"></a>RocketMq</h5><p>了解一个常用消息中间件如RocketMq的实现：如何保证高可用和高吞吐、消息顺序、重复消费、事务消息、延迟消息、死信队列</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">常见问题</span><br><span class="line"><span class="bullet">1.</span> RocketMq如何保证高可用的？</span><br><span class="line"><span class="bullet">2.</span> RocketMq如何保证高吞吐的？</span><br><span class="line"><span class="bullet">3.</span> RocketMq的消息是有序的吗？</span><br><span class="line"><span class="bullet">4.</span> RocketMq的消息局部顺序是如何保证的?</span><br><span class="line"><span class="bullet">5.</span> RocketMq事务消息的实现机制？</span><br><span class="line"><span class="bullet">6.</span> RocketMq会有重复消费的问题吗？如何解决？</span><br><span class="line"><span class="bullet">7.</span> RocketMq支持什么级别的延迟消息？如何实现的？</span><br><span class="line"><span class="bullet">8.</span> RocketMq是推模型还是拉模型？</span><br><span class="line"><span class="bullet">9.</span> Consumer的负载均衡是怎么样的？</span><br></pre></td></tr></table></figure><h5 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h5><p>redis工作模型、redis持久化、redis过期淘汰机制、redis分布式集群的常见形式、分布式锁、缓存击穿、缓存雪崩、缓存一致性问题</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">常见问题</span><br><span class="line"><span class="bullet">1.</span> redis性能为什么高?</span><br><span class="line"><span class="bullet">2.</span> 单线程的redis如何利用多核cpu机器？</span><br><span class="line"><span class="bullet">3.</span> redis的缓存淘汰策略？</span><br><span class="line"><span class="bullet">4.</span> redis如何持久化数据？</span><br><span class="line"><span class="bullet">5.</span> redis有哪几种数据结构？</span><br><span class="line"><span class="bullet">6.</span> redis集群有哪几种形式？</span><br><span class="line"><span class="bullet">7.</span> 有海量key和value都比较小的数据，在redis中如何存储才更省内存？</span><br><span class="line"><span class="bullet">8.</span> 如何保证redis和DB中的数据一致性？</span><br><span class="line"><span class="bullet">9.</span> 如何解决缓存穿透和缓存雪崩？</span><br><span class="line"><span class="bullet">10.</span> 如何用redis实现分布式锁？</span><br></pre></td></tr></table></figure><h5 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h5><p>事务隔离级别、锁、索引的数据结构、聚簇索引和非聚簇索引、最左匹配原则、查询优化（explain等命令）</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">常见问题</span><br><span class="line"><span class="bullet">1.</span> Mysql(innondb 下同) 有哪几种事务隔离级别？</span><br><span class="line"><span class="bullet">2.</span> 不同事务隔离级别分别会加哪些锁？</span><br><span class="line"><span class="bullet">3.</span> mysql的行锁、表锁、间隙锁、意向锁分别是做什么的？</span><br><span class="line"><span class="bullet">4.</span> 说说什么是最左匹配？</span><br><span class="line"><span class="bullet">5.</span> 如何优化慢查询？</span><br><span class="line"><span class="bullet">6.</span> mysql索引为什么用的是b+ tree而不是b tree、红黑树</span><br><span class="line"><span class="bullet">7.</span> 分库分表如何选择分表键</span><br><span class="line"><span class="bullet">8.</span> 分库分表的情况下，查询时一般是如何做排序的？</span><br></pre></td></tr></table></figure><h5 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h5><p>zk大致原理（可以了解下原理相近的Raft算法）、zk实现分布式锁、zk做集群master选举</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">常见问题</span><br><span class="line"><span class="bullet">1.</span> 如何用zk实现分布式锁，与redis分布式锁有和优缺点</span><br></pre></td></tr></table></figure><h5 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h5><p>算法的话不是所有公司都会问，但最好还是准备下，主要是靠刷题，在leetcode上刷个100-200道easy和medium的题，然后对应公司的面经多看看，问题应该不大。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;集合&quot;&gt;&lt;a href=&quot;#集合&quot; class=&quot;headerlink&quot; title=&quot;集合&quot;&gt;&lt;/a&gt;集合&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;java.util包下的非线程安全集合和java.util.concurrent下的线程安全集合。&lt;/p&gt;
&lt;/b</summary>
      
    
    
    
    <category term="面试" scheme="http://example.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>flink介绍</title>
    <link href="http://example.com/2021/01/10/flink-init/"/>
    <id>http://example.com/2021/01/10/flink-init/</id>
    <published>2021-01-10T11:26:00.000Z</published>
    <updated>2021-07-06T15:00:15.406Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/pasted-1.png"></p><h3 id="flink是什么？"><a href="#flink是什么？" class="headerlink" title="flink是什么？"></a>flink是什么？</h3><blockquote><p>Apache Flink is a framework and distributed processing engine for stateful computations over unbounded and bounded data streams.<br>apache flink是一个<font color='red'><strong>框架</strong></font>和<font color='red'><strong>分布式处理引擎</strong></font>，用于对<font color='red'><strong>无界</strong></font>与<font color='red'><strong>有界</strong></font>数据流进行<font color='red'><strong>状态</strong></font>计算</p></blockquote><h3 id="为什么选择flink"><a href="#为什么选择flink" class="headerlink" title="为什么选择flink?"></a>为什么选择flink?</h3><ul><li>流数据更真实的反应我们的生活方式<ul><li>源源不断</li></ul></li><li>传统的数据架构是基于有限数据集<ul><li>非实时</li><li>spark streaming</li></ul></li><li>实时不是一堆数据到达某个时间点处理（批处理），类似于实时聊天</li><li>目标<ul><li>低延迟<ul><li>ms级别</li></ul></li><li>高吞吐<ul><li>分布式</li></ul></li><li>结果的准确性和良好的容错性<ul><li>分布式保持准确</li><li>数据传输，合并数据正确性</li></ul></li></ul></li></ul><h3 id="哪些业务需要使用"><a href="#哪些业务需要使用" class="headerlink" title="哪些业务需要使用?"></a>哪些业务需要使用?</h3><ul><li>数据报表</li><li>用户交互密集</li><li>实时聊天</li><li>…</li></ul><h3 id="应用场景对比"><a href="#应用场景对比" class="headerlink" title="应用场景对比"></a>应用场景对比</h3><ol><li>事件驱动应用<ul><li>传统架构<ul><li>读写远程事务型数据库</li><li>优点：实时性好</li><li>缺点：能够处理的数据有限，<font color='red'><strong>高并发做不好</strong></font></li></ul></li><li>flink<ul><li>无须查询远程数据库</li><li>本地数据访问使得它具有<font color='red'><strong>更高的吞吐</strong></font>和<font color='red'><strong>更低的延迟</strong></font></li><li>savepoint例子</li></ul></li></ul></li></ol><p><img src="/images/pasted-2.png"></p><ol start="2"><li>数据分析应用<ul><li>批处理<ul><li>利用批查询，或将事件记录下来并基于此有限数据集构建应用来完成，为了得到最新数据的分析结果，必须先将它们加入分析数据集并重新执行查询或运行应用，随后将结果写入存储系统或生成报告。</li><li>能够处理海量数据</li><li><font color='red'><strong>实时性不好</strong></font></li></ul></li><li>流处理<ul><li>流式查询或应用会接入实时事件流，并随着事件消费持续产生和更新结果。这些结果数据可能会写入外部数据库系统或以内部状态的形式维护。仪表展示应用可以相应地从外部数据库读取数据或直接查询应用的内部状态。</li><li>流式分析省掉了周期性的数据导入和查询过程，因此从事件中获取指标的<font color='red'><strong>延迟更低</strong></font></li></ul></li><li>批处理和流处理<ul><li>flink既可做批处理和流处理</li><li>处理必须处理定期导入和输入有界性导致的人工数据边界，而流式查询则无须考虑该问题</li></ul></li></ul></li></ol><p><img src="/images/pasted-3.png"></p><ol start="3"><li>数据管道应用<ul><li>周期性 ETL 作业<ul><li>提取-转换-加载（ETL）是一种在存储系统之间进行数据转换和迁移的常用方法。ETL 作业通常会周期性地触发，将数据从事务型数据库拷贝到分析型数据库或数据仓库</li><li><font color='red'><strong>实时性不好</strong></font></li></ul></li><li>持续数据管道<ul><li>可以明显<font color='red'><strong>降低将数据移动到目的端的延迟</strong></font>。此外，由于它能够持续消费和发送数据，因此用途更广，支持用例更多<br><img src="/images/pasted-4.png"></li></ul></li></ul></li></ol><h3 id="flink-架构图"><a href="#flink-架构图" class="headerlink" title="flink 架构图"></a>flink 架构图</h3><ol><li>state<ul><li>数据直接存在本地内存</li><li>集群</li><li><font color='red'><strong>低延迟</strong></font></li><li><font color='red'><strong>高吞吐</strong></font></li></ul></li><li>checkpoint<ul><li>持久化</li><li>故障容错</li></ul></li><li>Exactly-once<ul><li>数据正确<br><img src="/images/pasted-0.png" alt="flink"></li></ul></li></ol><h3 id="flink-cdc-change-data-capture-etl例子"><a href="#flink-cdc-change-data-capture-etl例子" class="headerlink" title="flink cdc(change data capture) etl例子"></a>flink cdc(change data capture) etl例子</h3><p><a href="https://github.com/ververica/flink-cdc-connectors/wiki/%E4%B8%AD%E6%96%87%E6%95%99%E7%A8%8B">https://github.com/ververica/flink-cdc-connectors/wiki/%E4%B8%AD%E6%96%87%E6%95%99%E7%A8%8B</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/pasted-1.png&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;flink是什么？&quot;&gt;&lt;a href=&quot;#flink是什么？&quot; class=&quot;headerlink&quot; title=&quot;flink是什么？&quot;&gt;&lt;/a&gt;flink是什么？&lt;/h3&gt;&lt;bloc</summary>
      
    
    
    
    <category term="大数据" scheme="http://example.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
    <category term="flink" scheme="http://example.com/tags/flink/"/>
    
  </entry>
  
</feed>
