{"meta":{"title":"李俊龙's Blog","subtitle":"","description":"","author":"jianghe","url":"http://example.com","root":"/"},"pages":[{"title":"","date":"2021-01-10T10:23:28.000Z","updated":"2021-07-06T15:00:15.412Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"广度-深度 当你不想学习，那是你没有压力"},{"title":"","date":"2021-01-10T11:04:43.000Z","updated":"2021-07-06T15:00:15.414Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"","date":"2021-01-10T11:05:05.000Z","updated":"2021-07-06T15:00:15.417Z","comments":true,"path":"timeline/index.html","permalink":"http://example.com/timeline/index.html","excerpt":"","text":""}],"posts":[{"title":"AQS","slug":"AQS","date":"2021-05-26T11:30:00.000Z","updated":"2021-07-06T15:00:15.407Z","comments":true,"path":"2021/05/26/AQS/","link":"","permalink":"http://example.com/2021/05/26/AQS/","excerpt":"","text":"简介&nbsp;&nbsp;&nbsp;&nbsp;AQS是什么呢？AbstractQueuedSynchronizer简称AQS。java并发变成核心在于java.concurrent.util包而juc当中的大多数同步器实现都是围绕着共同的基础行为，比如等待队列、条件队列、独占获取、共享获取等。而这个行为都是都是aqs去做的。下面是aqs的官方介绍。 Provides a framework for implementing blocking locks and related synchronizers (semaphores, events, etc) that rely on first-in-first-out (FIFO) wait queues. This class is designed to be a useful basis for most kinds of synchronizers that rely on a single atomic int value to represent state. AQS依赖 &nbsp;&nbsp;&nbsp;&nbsp;根据上面类图，我们可以看见ReentrantLock、Semaphore、ReentrantReadWriteLock都是使用的AQS AQS特性 阻塞等待队列 共享/独占 公平/非公平 可重入 允许中断 除了lock外，在juc下面实现如latch、Barrier、BlockingQueue等都是基于AQS来实现的 一般都是定义一个内部的Sync类，然后再去实现AbstractQueuedSynchronizer 将同步器所有调用都映射到Sync对应的方法 采用的模板模式-子类根据需要来实现具体的业务 AQS volatile int state(32位) state表示资源的可用状态 AQS 两种资源共享方式 EXCLUSIVE，只有一个线程能执行，如ReentrantLock SHARED，多个线程可以同时执行，如Semaphore、CountDownLatch AQS 两种队列 CLH 同步等待队列 Condition 条件等待队列 AQS 方法 不同的自定义同步器争用共享资源的方式不同。自定义同步器只需要实现共享资源state的获取与释放方式即可。至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队），AQS已经在顶层实现好了 在AQS上，只有下面这几个方法是需要实现的 boolean isHeldExclusively() 该线程是否正在独占资源。只有用到Condition才需要去实现 boolean tryAcquire(int arg) 独占模式。尝试获取资源，成功true，失败false boolean tryRelease(int arg) 独占模式。尝试释放资源，成功true，失败false int tryAcquireShared(int arg) 共享模式。尝试获取资源，负数表示失败，0表示成功但是没有剩余资源可用，正数表示成功而且有资源可用 boolean tryReleaseShared(int arg) 共享模式。尝试释放资源，如果释放后允许唤醒后续等待节点返回true，否则返回false AQS源码解析&nbsp;&nbsp;&nbsp;&nbsp;在真正看代码的时候，我们先知道怎么去使用，在这里通过ReentrantLock来深入说明aqs 12345ReentrantLock reentrantLock = new ReentrantLock(false);// false 非公平锁、默认// true 公平锁reentrantLock.lock(); //加锁reentrantLock.unlock(); //解锁 &nbsp;&nbsp;&nbsp;&nbsp;ReentrantLock是采用aqs框架实现的，是jdk并发访问的特性，它的功能类似于synchronized互斥锁，可以保证线程安全。它还支持手动加锁与解锁，支持加锁的公平性。 ReentrantLock猜想&nbsp;&nbsp;&nbsp;&nbsp;如果想实现一个ReentrantLock，你会如何实现呢？ 123456789101112131415161718192021reentrantLock.lock(); 这个是加锁？那么加锁会干嘛？while(true)&#123;// 1. 获取锁，获取成功后 // 执行业务逻辑// 2. 获取锁失败 // 2.1 Thread.yield 让出cpu使用权，但是这里有个问题，一直让出会消耗cpu性能 // 2.2 Thread.sleep 休眠一下，但是有个问题，不知道休眠多久，有的业务代码时间长，有的业务代码时间短 // 2.3 阻塞一下，等到当前获取锁的线程释放了，那就让他不阻塞不就行了，LockSupport。 // 2.4 这里还要实现一个公平的特性，一想到公平性，那就是得排队，先进先出——队列，那在这里阻塞的时候需要放到队列queue里排队&#125;reentrantLock.unlock(); //解锁// 1. 在queue里取出元素，然后拿出来// 2. 取出后在解锁的时候就让之前阻塞的线程唤醒了 结论1. 获取锁，这里肯定是单线程了，可以使用synchronized，这个有点太重，这里可以使用cas的方式，是一个原子操作，一次只能让一个线程成功，cas是依赖汇编指令：cmpxchg()2. 队列queue3. LockSupport(park 阻塞 和 unpark 非阻塞)4. 自旋 那经过自己的思考和结论，AQS就是这样实现的。 结构图 队列CLH同步等待队列&nbsp;&nbsp;&nbsp;&nbsp;AQS当中的同步队列也称CLH队列，CLH是Craig、Landin、Hagersten三人发明的基于双向链表数据结构的队列，是FIFO先进先出的等待队列，Java中的CLH队列是原CLH队列的一个变种，线程由原自旋机制改成阻塞机制 Condition条件等待队列&nbsp;&nbsp;&nbsp;&nbsp;Condition是一个多线程间协调通信的工具类，使得某个或者某些线程一起等待某个条件，只有该条件具备时，这些等待的线程才被唤醒，从而重新争夺锁 介绍ReentrantLock代码，这里采用公平锁来介绍 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155public class ReentrantLock implements Lock, java.io.Serializable &#123; private final Sync sync; abstract static class Sync extends AbstractQueuedSynchronizer &#123; private static final long serialVersionUID = -5179523762034025860L; /** * Performs &#123;@link Lock#lock&#125;. The main reason for subclassing * is to allow fast path for nonfair version. */ abstract void lock(); /** * Performs non-fair tryLock. tryAcquire is implemented in * subclasses, but both need nonfair try for trylock method. * * * 1. 非公平获取锁，只要判断资源状态state=0，如果这个时候有线程可以直接获取锁，这里就是非公平的概念（刚进来的线程和head后的第一个线程来争抢） * 2. 其他和公平是一样的 */ final boolean nonfairTryAcquire(int acquires) &#123; final Thread current = Thread.currentThread(); int c = getState(); if (c == 0) &#123; if (compareAndSetState(0, acquires)) &#123; setExclusiveOwnerThread(current); return true; &#125; &#125; else if (current == getExclusiveOwnerThread()) &#123; int nextc = c + acquires; if (nextc &lt; 0) // overflow throw new Error(&quot;Maximum lock count exceeded&quot;); setState(nextc); return true; &#125; return false; &#125; /** * * 释放锁 **/ protected final boolean tryRelease(int releases) &#123; int c = getState() - releases; if (Thread.currentThread() != getExclusiveOwnerThread()) throw new IllegalMonitorStateException(); boolean free = false; if (c == 0) &#123; free = true; setExclusiveOwnerThread(null); &#125; setState(c); return free; &#125; protected final boolean isHeldExclusively() &#123; // While we must in general read state before owner, // we don&#x27;t need to do so to check if current thread is owner return getExclusiveOwnerThread() == Thread.currentThread(); &#125; final ConditionObject newCondition() &#123; return new ConditionObject(); &#125; // Methods relayed from outer class final Thread getOwner() &#123; return getState() == 0 ? null : getExclusiveOwnerThread(); &#125; final int getHoldCount() &#123; return isHeldExclusively() ? getState() : 0; &#125; final boolean isLocked() &#123; return getState() != 0; &#125; /** * Reconstitutes the instance from a stream (that is, deserializes it). */ private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException &#123; s.defaultReadObject(); setState(0); // reset to unlocked state &#125; &#125; /** * 非公平锁 * Sync object for non-fair locks */ static final class NonfairSync extends Sync &#123; private static final long serialVersionUID = 7316153563782823691L; /** * Performs lock. Try immediate barge, backing up to normal * acquire on failure. */ final void lock() &#123; if (compareAndSetState(0, 1)) setExclusiveOwnerThread(Thread.currentThread()); else acquire(1); &#125; protected final boolean tryAcquire(int acquires) &#123; return nonfairTryAcquire(acquires); &#125; &#125; /** * 公平锁 * Sync object for fair locks */ static final class FairSync extends Sync &#123; private static final long serialVersionUID = -3000897897090466540L; final void lock() &#123; // 调用AQS方法 acquire(1); &#125; /** * Fair version of tryAcquire. Don&#x27;t grant access unless * recursive call or no waiters or is first. * * 1. 尝试获取锁，判断有没有state资源可以用，如果有的话，还要判断队列里面有没有节点，如果有就去获取锁 */ protected final boolean tryAcquire(int acquires) &#123; final Thread current = Thread.currentThread(); int c = getState(); if (c == 0) &#123; if (!hasQueuedPredecessors() &amp;&amp; compareAndSetState(0, acquires)) &#123; setExclusiveOwnerThread(current); return true; &#125; &#125; else if (current == getExclusiveOwnerThread()) &#123; int nextc = c + acquires; if (nextc &lt; 0) throw new Error(&quot;Maximum lock count exceeded&quot;); setState(nextc); return true; &#125; return false; &#125; &#125; public void unlock() &#123; sync.release(1); &#125;&#125; AbstractQueuedSynchronizer代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473483493503513523533543553563573583593603613623633643653663673683693703713723733743753763773783793803813823833843853863873883893903913923933943953963973983994004014024034044054064074084094104114124134144154164174184194204214224234244254264274284294304314324334344354364374384394404414424434444454464474484494504514524534544554564574584594604614624634644654664674684694704714724734744754764774784794804814824834844854864874884894904914924934944954964974984995005015025035045055065075085095105115125135145155165175185195205215225235245255265275285295305315325335345355365375385395405415425435445455465475485495505515525535545555565575585595605615625635645655665675685695705715725735745755765775785795805815825835845855865875885895905915925935945955965975985996006016026036046056066076086096106116126136146156166176186196206216226236246256266276286296306316326336346356366376386396406416426436446456466476486496506516526536546556566576586596606616626636646656666676686696706716726736746756766776786796806816826836846856866876886896906916926936946956966976986997007017027037047057067077087097107117127137147157167177187197207217227237247257267277287297307317327337347357367377387397407417427437447457467477487497507517527537547557567577587597607617627637647657667677687697707717727737747757767777787797807817827837847857867877887897907917927937947957967977987998008018028038048058068078088098108118128138148158168178188198208218228238248258268278288298308318328338348358368378388398408418428438448458468478488498508518528538548558568578588598608618628638648658668678688698708718728738748758768778788798808818828838848858868878888898908918928938948958968978988999009019029039049059069079089099109119129139149159169179189199209219229239249259269279289299309319329339349359369379389399409419429439449459469479489499509519529539549559569579589599609619629639649659669679689699709719729739749759769779789799809819829839849859869879889899909919929939949959969979989991000100110021003100410051006100710081009101010111012101310141015101610171018101910201021102210231024102510261027102810291030103110321033103410351036103710381039104010411042104310441045104610471048104910501051105210531054105510561057105810591060106110621063106410651066106710681069107010711072107310741075107610771078107910801081108210831084108510861087108810891090109110921093109410951096109710981099110011011102110311041105110611071108110911101111111211131114111511161117111811191120112111221123112411251126112711281129113011311132113311341135113611371138113911401141114211431144114511461147114811491150115111521153115411551156115711581159116011611162116311641165116611671168116911701171117211731174117511761177117811791180118111821183118411851186118711881189119011911192119311941195119611971198119912001201120212031204120512061207120812091210121112121213121412151216121712181219122012211222122312241225122612271228122912301231123212331234123512361237123812391240124112421243124412451246124712481249125012511252125312541255125612571258125912601261126212631264126512661267126812691270127112721273127412751276127712781279128012811282128312841285128612871288128912901291129212931294129512961297129812991300130113021303130413051306130713081309131013111312131313141315131613171318131913201321132213231324132513261327132813291330133113321333133413351336133713381339134013411342134313441345134613471348134913501351135213531354135513561357135813591360136113621363136413651366136713681369137013711372137313741375137613771378137913801381138213831384138513861387138813891390139113921393139413951396139713981399140014011402140314041405140614071408140914101411141214131414141514161417141814191420142114221423142414251426142714281429143014311432143314341435143614371438143914401441144214431444144514461447144814491450145114521453145414551456145714581459146014611462146314641465146614671468146914701471147214731474147514761477147814791480148114821483148414851486148714881489149014911492149314941495149614971498149915001501150215031504150515061507150815091510151115121513151415151516151715181519152015211522152315241525152615271528152915301531153215331534153515361537153815391540154115421543154415451546154715481549155015511552155315541555155615571558155915601561156215631564156515661567156815691570157115721573157415751576157715781579158015811582158315841585158615871588158915901591159215931594159515961597159815991600160116021603160416051606160716081609161016111612161316141615161616171618161916201621162216231624162516261627162816291630163116321633163416351636163716381639164016411642164316441645164616471648164916501651165216531654165516561657165816591660166116621663166416651666166716681669167016711672167316741675167616771678167916801681168216831684168516861687168816891690169116921693169416951696169716981699170017011702170317041705170617071708170917101711171217131714171517161717171817191720172117221723172417251726172717281729173017311732173317341735173617371738173917401741174217431744174517461747174817491750175117521753175417551756175717581759176017611762176317641765176617671768176917701771177217731774177517761777177817791780178117821783178417851786178717881789179017911792179317941795179617971798179918001801180218031804180518061807180818091810181118121813181418151816181718181819182018211822182318241825182618271828182918301831183218331834183518361837183818391840184118421843184418451846184718481849185018511852185318541855185618571858185918601861186218631864186518661867186818691870187118721873187418751876187718781879188018811882188318841885188618871888188918901891189218931894189518961897189818991900190119021903190419051906190719081909191019111912191319141915191619171918191919201921192219231924192519261927192819291930193119321933193419351936193719381939194019411942194319441945194619471948194919501951195219531954195519561957195819591960196119621963196419651966196719681969197019711972197319741975197619771978197919801981198219831984198519861987198819891990199119921993199419951996199719981999200020012002200320042005200620072008200920102011201220132014201520162017201820192020202120222023202420252026202720282029203020312032203320342035203620372038203920402041204220432044204520462047204820492050205120522053205420552056205720582059206020612062206320642065206620672068206920702071207220732074207520762077207820792080208120822083208420852086208720882089209020912092209320942095209620972098209921002101210221032104210521062107210821092110211121122113public abstract class AbstractQueuedSynchronizer extends AbstractOwnableSynchronizer implements java.io.Serializable &#123; private static final long serialVersionUID = 7373984972572414691L; /** * Creates a new &#123;@code AbstractQueuedSynchronizer&#125; instance * with initial synchronization state of zero. */ protected AbstractQueuedSynchronizer() &#123; &#125; /** * Wait queue node class. * * &lt;p&gt;The wait queue is a variant of a &quot;CLH&quot; (Craig, Landin, and * Hagersten) lock queue. CLH locks are normally used for * spinlocks. We instead use them for blocking synchronizers, but * use the same basic tactic of holding some of the control * information about a thread in the predecessor of its node. A * &quot;status&quot; field in each node keeps track of whether a thread * should block. A node is signalled when its predecessor * releases. Each node of the queue otherwise serves as a * specific-notification-style monitor holding a single waiting * thread. The status field does NOT control whether threads are * granted locks etc though. A thread may try to acquire if it is * first in the queue. But being first does not guarantee success; * it only gives the right to contend. So the currently released * contender thread may need to rewait. * * &lt;p&gt;To enqueue into a CLH lock, you atomically splice it in as new * tail. To dequeue, you just set the head field. * &lt;pre&gt; * +------+ prev +-----+ +-----+ * head | | &lt;---- | | &lt;---- | | tail * +------+ +-----+ +-----+ * &lt;/pre&gt; * * &lt;p&gt;Insertion into a CLH queue requires only a single atomic * operation on &quot;tail&quot;, so there is a simple atomic point of * demarcation from unqueued to queued. Similarly, dequeuing * involves only updating the &quot;head&quot;. However, it takes a bit * more work for nodes to determine who their successors are, * in part to deal with possible cancellation due to timeouts * and interrupts. * * &lt;p&gt;The &quot;prev&quot; links (not used in original CLH locks), are mainly * needed to handle cancellation. If a node is cancelled, its * successor is (normally) relinked to a non-cancelled * predecessor. For explanation of similar mechanics in the case * of spin locks, see the papers by Scott and Scherer at * http://www.cs.rochester.edu/u/scott/synchronization/ * * &lt;p&gt;We also use &quot;next&quot; links to implement blocking mechanics. * The thread id for each node is kept in its own node, so a * predecessor signals the next node to wake up by traversing * next link to determine which thread it is. Determination of * successor must avoid races with newly queued nodes to set * the &quot;next&quot; fields of their predecessors. This is solved * when necessary by checking backwards from the atomically * updated &quot;tail&quot; when a node&#x27;s successor appears to be null. * (Or, said differently, the next-links are an optimization * so that we don&#x27;t usually need a backward scan.) * * &lt;p&gt;Cancellation introduces some conservatism to the basic * algorithms. Since we must poll for cancellation of other * nodes, we can miss noticing whether a cancelled node is * ahead or behind us. This is dealt with by always unparking * successors upon cancellation, allowing them to stabilize on * a new predecessor, unless we can identify an uncancelled * predecessor who will carry this responsibility. * * &lt;p&gt;CLH queues need a dummy header node to get started. But * we don&#x27;t create them on construction, because it would be wasted * effort if there is never contention. Instead, the node * is constructed and head and tail pointers are set upon first * contention. * * &lt;p&gt;Threads waiting on Conditions use the same nodes, but * use an additional link. Conditions only need to link nodes * in simple (non-concurrent) linked queues because they are * only accessed when exclusively held. Upon await, a node is * inserted into a condition queue. Upon signal, the node is * transferred to the main queue. A special value of status * field is used to mark which queue a node is on. * * &lt;p&gt;Thanks go to Dave Dice, Mark Moir, Victor Luchangco, Bill * Scherer and Michael Scott, along with members of JSR-166 * expert group, for helpful ideas, discussions, and critiques * on the design of this class. * CLH同步等待队列实现 */ static final class Node &#123; /** Marker to indicate a node is waiting in shared mode * 共享模式 */ static final Node SHARED = new Node(); /** Marker to indicate a node is waiting in exclusive mode * 排他模式 */ static final Node EXCLUSIVE = null; /** waitStatus value to indicate thread has cancelled * 取消状态是&gt;0，其他都是小于0，默认状态是0 */ static final int CANCELLED = 1; /** waitStatus value to indicate successor&#x27;s thread needs unparking * 等待被唤醒 */ static final int SIGNAL = -1; /** waitStatus value to indicate thread is waiting on condition * 条件等待状态 */ static final int CONDITION = -2; /** * waitStatus value to indicate the next acquireShared should * unconditionally propagate */ static final int PROPAGATE = -3; /** * Status field, taking on only the values: * SIGNAL: The successor of this node is (or will soon be) * blocked (via park), so the current node must * unpark its successor when it releases or * cancels. To avoid races, acquire methods must * first indicate they need a signal, * then retry the atomic acquire, and then, * on failure, block. * CANCELLED: This node is cancelled due to timeout or interrupt. * Nodes never leave this state. In particular, * a thread with cancelled node never again blocks. * CONDITION: This node is currently on a condition queue. * It will not be used as a sync queue node * until transferred, at which time the status * will be set to 0. (Use of this value here has * nothing to do with the other uses of the * field, but simplifies mechanics.) * PROPAGATE: A releaseShared should be propagated to other * nodes. This is set (for head node only) in * doReleaseShared to ensure propagation * continues, even if other operations have * since intervened. * 0: None of the above * * The values are arranged numerically to simplify use. * Non-negative values mean that a node doesn&#x27;t need to * signal. So, most code doesn&#x27;t need to check for particular * values, just for sign. * * The field is initialized to 0 for normal sync nodes, and * CONDITION for condition nodes. It is modified using CAS * (or when possible, unconditional volatile writes). * 节点状态 */ volatile int waitStatus; /** * Link to predecessor node that current node/thread relies on * for checking waitStatus. Assigned during enqueuing, and nulled * out (for sake of GC) only upon dequeuing. Also, upon * cancellation of a predecessor, we short-circuit while * finding a non-cancelled one, which will always exist * because the head node is never cancelled: A node becomes * head only as a result of successful acquire. A * cancelled thread never succeeds in acquiring, and a thread only * cancels itself, not any other node. * 前置节点 */ volatile Node prev; /** * Link to the successor node that the current node/thread * unparks upon release. Assigned during enqueuing, adjusted * when bypassing cancelled predecessors, and nulled out (for * sake of GC) when dequeued. The enq operation does not * assign next field of a predecessor until after attachment, * so seeing a null next field does not necessarily mean that * node is at end of queue. However, if a next field appears * to be null, we can scan prev&#x27;s from the tail to * double-check. The next field of cancelled nodes is set to * point to the node itself instead of null, to make life * easier for isOnSyncQueue. * 后置节点 */ volatile Node next; /** * The thread that enqueued this node. Initialized on * construction and nulled out after use. * 当前节点存储的内容，当前线程，拿出来阻塞&amp;唤醒 */ volatile Thread thread; /** * Link to next node waiting on condition, or the special * value SHARED. Because condition queues are accessed only * when holding in exclusive mode, we just need a simple * linked queue to hold nodes while they are waiting on * conditions. They are then transferred to the queue to * re-acquire. And because conditions can only be exclusive, * we save a field by using special value to indicate shared * mode. * 条件队列下一个节点 */ Node nextWaiter; /** * Returns true if node is waiting in shared mode. */ final boolean isShared() &#123; return nextWaiter == SHARED; &#125; /** * Returns previous node, or throws NullPointerException if null. * Use when predecessor cannot be null. The null check could * be elided, but is present to help the VM. * * @return the predecessor of this node */ final Node predecessor() throws NullPointerException &#123; Node p = prev; if (p == null) throw new NullPointerException(); else return p; &#125; Node() &#123; // Used to establish initial head or SHARED marker &#125; Node(Thread thread, Node mode) &#123; // Used by addWaiter this.nextWaiter = mode; this.thread = thread; &#125; Node(Thread thread, int waitStatus) &#123; // Used by Condition this.waitStatus = waitStatus; this.thread = thread; &#125; &#125; /** * Head of the wait queue, lazily initialized. Except for * initialization, it is modified only via method setHead. Note: * If head exists, its waitStatus is guaranteed not to be * CANCELLED. * * 头节点 * transient表示反序列化被透明，其他没什么不同 */ private transient volatile Node head; /** * Tail of the wait queue, lazily initialized. Modified only via * method enq to add new wait node. * * 尾结点 */ private transient volatile Node tail; /** * The synchronization state. * * 这个字段非常重要，就是多个线程来争抢是否有资源可用 */ private volatile int state; /** * Returns the current value of synchronization state. * This operation has memory semantics of a &#123;@code volatile&#125; read. * @return current state value */ protected final int getState() &#123; return state; &#125; /** * Sets the value of synchronization state. * This operation has memory semantics of a &#123;@code volatile&#125; write. * @param newState the new state value */ protected final void setState(int newState) &#123; state = newState; &#125; /** * Atomically sets synchronization state to the given updated * value if the current state value equals the expected value. * This operation has memory semantics of a &#123;@code volatile&#125; read * and write. * * @param expect the expected value * @param update the new value * @return &#123;@code true&#125; if successful. False return indicates that the actual * value was not equal to the expected value. * cas操作 */ protected final boolean compareAndSetState(int expect, int update) &#123; // See below for intrinsics setup to support this return unsafe.compareAndSwapInt(this, stateOffset, expect, update); &#125; // Queuing utilities /** * The number of nanoseconds for which it is faster to spin * rather than to use timed park. A rough estimate suffices * to improve responsiveness with very short timeouts. */ static final long spinForTimeoutThreshold = 1000L; /** * Inserts node into queue, initializing if necessary. See picture above. * @param node the node to insert * @return node&#x27;s predecessor * * 入队，如果队列为空的话，创建一个空的头节点，然后把节点加入到头的后面，通过cas操作 * 通过自旋的操作必须入队成功，添加成尾节点 */ private Node enq(final Node node) &#123; for (;;) &#123; Node t = tail; if (t == null) &#123; // Must initialize if (compareAndSetHead(new Node())) tail = head; &#125; else &#123; node.prev = t; if (compareAndSetTail(t, node)) &#123; t.next = node; return t; &#125; &#125; &#125; &#125; /** * Creates and enqueues node for current thread and given mode. * * @param mode Node.EXCLUSIVE for exclusive, Node.SHARED for shared * @return the new node * * 入队，如果队列不为空，直接插入到队列后面 */ private Node addWaiter(Node mode) &#123; Node node = new Node(Thread.currentThread(), mode); // Try the fast path of enq; backup to full enq on failure Node pred = tail; if (pred != null) &#123; node.prev = pred; if (compareAndSetTail(pred, node)) &#123; pred.next = node; return node; &#125; &#125; enq(node); return node; &#125; /** * Sets head of queue to be node, thus dequeuing. Called only by * acquire methods. Also nulls out unused fields for sake of GC * and to suppress unnecessary signals and traversals. * * @param node the node * * 设置head，这里需要注意下，其中thread为null，prev节点 * 这里的head节点是实际不存数据的 */ private void setHead(Node node) &#123; head = node; node.thread = null; node.prev = null; &#125; /** * Wakes up node&#x27;s successor, if one exists. * * @param node the node * * 这是阻塞队列中唤醒操作，这里操作分为两个步骤 * 1. 默认进来就是-1，这里可以看下获取锁阶段没拿到锁的时候会将state设置成-1 * 2. 进来的时候会将当前节点head状态设置成0，可以是尝试去拿锁 * 3. 然后取当前节点后的第一个节点的线程唤醒，node是head节点 */ private void unparkSuccessor(Node node) &#123; /* * If status is negative (i.e., possibly needing signal) try * to clear in anticipation of signalling. It is OK if this * fails or if status is changed by waiting thread. */ int ws = node.waitStatus; if (ws &lt; 0) compareAndSetWaitStatus(node, ws, 0); /* * Thread to unpark is held in successor, which is normally * just the next node. But if cancelled or apparently null, * traverse backwards from tail to find the actual * non-cancelled successor. */ Node s = node.next; if (s == null || s.waitStatus &gt; 0) &#123; s = null; for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev) if (t.waitStatus &lt;= 0) s = t; &#125; if (s != null) LockSupport.unpark(s.thread); &#125; /** * Release action for shared mode -- signals successor and ensures * propagation. (Note: For exclusive mode, release just amounts * to calling unparkSuccessor of head if it needs signal.) */ private void doReleaseShared() &#123; /* * Ensure that a release propagates, even if there are other * in-progress acquires/releases. This proceeds in the usual * way of trying to unparkSuccessor of head if it needs * signal. But if it does not, status is set to PROPAGATE to * ensure that upon release, propagation continues. * Additionally, we must loop in case a new node is added * while we are doing this. Also, unlike other uses of * unparkSuccessor, we need to know if CAS to reset status * fails, if so rechecking. */ for (;;) &#123; Node h = head; if (h != null &amp;&amp; h != tail) &#123; int ws = h.waitStatus; if (ws == Node.SIGNAL) &#123; if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0)) continue; // loop to recheck cases unparkSuccessor(h); &#125; else if (ws == 0 &amp;&amp; !compareAndSetWaitStatus(h, 0, Node.PROPAGATE)) continue; // loop on failed CAS &#125; if (h == head) // loop if head changed break; &#125; &#125; /** * Sets head of queue, and checks if successor may be waiting * in shared mode, if so propagating if either propagate &gt; 0 or * PROPAGATE status was set. * * @param node the node * @param propagate the return value from a tryAcquireShared */ private void setHeadAndPropagate(Node node, int propagate) &#123; Node h = head; // Record old head for check below setHead(node); /* * Try to signal next queued node if: * Propagation was indicated by caller, * or was recorded (as h.waitStatus either before * or after setHead) by a previous operation * (note: this uses sign-check of waitStatus because * PROPAGATE status may transition to SIGNAL.) * and * The next node is waiting in shared mode, * or we don&#x27;t know, because it appears null * * The conservatism in both of these checks may cause * unnecessary wake-ups, but only when there are multiple * racing acquires/releases, so most need signals now or soon * anyway. */ if (propagate &gt; 0 || h == null || h.waitStatus &lt; 0 || (h = head) == null || h.waitStatus &lt; 0) &#123; Node s = node.next; if (s == null || s.isShared()) doReleaseShared(); &#125; &#125; // Utilities for various versions of acquire /** * Cancels an ongoing attempt to acquire. * * @param node the node * * 取消获取锁，中断，把当前节点踢出掉队列 * 1. 设置thread为空 * 2. 找到它之前的节点，如果他之前的节点也是取消节点，那就是把当前节点连续的取消节点踢出队列中 * 3. 接下来的操作就是将连续取消节点的prev节点指向连续取消节点的next节点 */ private void cancelAcquire(Node node) &#123; // Ignore if node doesn&#x27;t exist if (node == null) return; node.thread = null; // Skip cancelled predecessors Node pred = node.prev; while (pred.waitStatus &gt; 0) node.prev = pred = pred.prev; // predNext is the apparent node to unsplice. CASes below will // fail if not, in which case, we lost race vs another cancel // or signal, so no further action is necessary. Node predNext = pred.next; // Can use unconditional write instead of CAS here. // After this atomic step, other Nodes can skip past us. // Before, we are free of interference from other threads. node.waitStatus = Node.CANCELLED; // If we are the tail, remove ourselves. if (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123; compareAndSetNext(pred, predNext, null); &#125; else &#123; // If successor needs signal, try to set pred&#x27;s next-link // so it will get one. Otherwise wake it up to propagate. int ws; if (pred != head &amp;&amp; ((ws = pred.waitStatus) == Node.SIGNAL || (ws &lt;= 0 &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp; pred.thread != null) &#123; Node next = node.next; if (next != null &amp;&amp; next.waitStatus &lt;= 0) compareAndSetNext(pred, predNext, next); &#125; else &#123; unparkSuccessor(node); &#125; node.next = node; // help GC &#125; &#125; /** * Checks and updates status for a node that failed to acquire. * Returns true if thread should block. This is the main signal * control in all acquire loops. Requires that pred == node.prev. * * @param pred node&#x27;s predecessor holding status * @param node the node * @return &#123;@code true&#125; if thread should block * * 这里是表示尝试获取锁时没获取到锁，然后准备阻塞线程 * 1. 当前进入的节点前置节点默认进来就是0 * 2. 然后前置节点状态设置成-1 * 3. 这里很奇怪，刚才我们看unlock 时调用unparkSuccessor又把状态设置成0 * 4. 这里解释下，为什么状态从0-&gt;-1-&gt;0，这里为什么要这么设计？因为在公平锁的时候，这个时候一定会是head后的第一个获取到锁，这是没有问题的， 但是如果是非公平锁的时候，head后的第一个节点线程是有可能获取不到锁的，还需要阻塞，这个时候进来的状态还是0，就还是会变成0-&gt;-1-&gt;0，循环就能持续下去 * */ private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) &#123; int ws = pred.waitStatus; if (ws == Node.SIGNAL) /* * This node has already set status asking a release * to signal it, so it can safely park. */ return true; if (ws &gt; 0) &#123; /* * Predecessor was cancelled. Skip over predecessors and * indicate retry. */ do &#123; node.prev = pred = pred.prev; &#125; while (pred.waitStatus &gt; 0); pred.next = node; &#125; else &#123; /* * waitStatus must be 0 or PROPAGATE. Indicate that we * need a signal, but don&#x27;t park yet. Caller will need to * retry to make sure it cannot acquire before parking. */ compareAndSetWaitStatus(pred, ws, Node.SIGNAL); &#125; return false; &#125; /** * Convenience method to interrupt current thread. * 中断当前线程，中断就是给线程打上一个中断标识 */ static void selfInterrupt() &#123; Thread.currentThread().interrupt(); &#125; /** * Convenience method to park and then check if interrupted * * @return &#123;@code true&#125; if interrupted * * 阻塞当前线程 * Thread.interrupted() 判断当前是否中断过 */ private final boolean parkAndCheckInterrupt() &#123; LockSupport.park(this); return Thread.interrupted(); &#125; /* * Various flavors of acquire, varying in exclusive/shared and * control modes. Each is mostly the same, but annoyingly * different. Only a little bit of factoring is possible due to * interactions of exception mechanics (including ensuring that we * cancel if tryAcquire throws exception) and other control, at * least not without hurting performance too much. */ /** * Acquires in exclusive uninterruptible mode for thread already in * queue. Used by condition wait methods as well as acquire. * * @param node the node * @param arg the acquire argument * @return &#123;@code true&#125; if interrupted while waiting * * 1. 这里是获取锁失败后，然后进入队列 * 2. 这里有个点，发现如果是当前节点的前置节点是head，还会尝试获取锁，有可能在阻塞之前，刚好这个时候之前获取锁的时候正好释放锁，就可以获取到锁 * 3. 这里如果是ReentrantLock不会走到cancelAcquire这里，因为这里都是正常返回，要不然就是阻塞到这里，那failed=false * */ final boolean acquireQueued(final Node node, int arg) &#123; boolean failed = true; try &#123; boolean interrupted = false; for (;;) &#123; final Node p = node.predecessor(); if (p == head &amp;&amp; tryAcquire(arg)) &#123; setHead(node); p.next = null; // help GC failed = false; return interrupted; &#125; if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) interrupted = true; &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125; &#125; /** * Acquires in exclusive interruptible mode. * @param arg the acquire argument * * 这个相比较acquireQueued就可能会进入到cancelAcquire，一旦发生中断，抛出异常，抛出异常之前会走到finally，然后这个时候failed = true就会走到cancelAcquire */ private void doAcquireInterruptibly(int arg) throws InterruptedException &#123; final Node node = addWaiter(Node.EXCLUSIVE); boolean failed = true; try &#123; for (;;) &#123; final Node p = node.predecessor(); if (p == head &amp;&amp; tryAcquire(arg)) &#123; setHead(node); p.next = null; // help GC failed = false; return; &#125; if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) throw new InterruptedException(); &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125; &#125; /** * Acquires in exclusive timed mode. * * @param arg the acquire argument * @param nanosTimeout max wait time * @return &#123;@code true&#125; if acquired */ private boolean doAcquireNanos(int arg, long nanosTimeout) throws InterruptedException &#123; if (nanosTimeout &lt;= 0L) return false; final long deadline = System.nanoTime() + nanosTimeout; final Node node = addWaiter(Node.EXCLUSIVE); boolean failed = true; try &#123; for (;;) &#123; final Node p = node.predecessor(); if (p == head &amp;&amp; tryAcquire(arg)) &#123; setHead(node); p.next = null; // help GC failed = false; return true; &#125; nanosTimeout = deadline - System.nanoTime(); if (nanosTimeout &lt;= 0L) return false; if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; nanosTimeout &gt; spinForTimeoutThreshold) LockSupport.parkNanos(this, nanosTimeout); if (Thread.interrupted()) throw new InterruptedException(); &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125; &#125; /** * Acquires in shared uninterruptible mode. * @param arg the acquire argument */ private void doAcquireShared(int arg) &#123; final Node node = addWaiter(Node.SHARED); boolean failed = true; try &#123; boolean interrupted = false; for (;;) &#123; final Node p = node.predecessor(); if (p == head) &#123; int r = tryAcquireShared(arg); if (r &gt;= 0) &#123; setHeadAndPropagate(node, r); p.next = null; // help GC if (interrupted) selfInterrupt(); failed = false; return; &#125; &#125; if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) interrupted = true; &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125; &#125; /** * Acquires in shared interruptible mode. * @param arg the acquire argument */ private void doAcquireSharedInterruptibly(int arg) throws InterruptedException &#123; final Node node = addWaiter(Node.SHARED); boolean failed = true; try &#123; for (;;) &#123; final Node p = node.predecessor(); if (p == head) &#123; int r = tryAcquireShared(arg); if (r &gt;= 0) &#123; setHeadAndPropagate(node, r); p.next = null; // help GC failed = false; return; &#125; &#125; if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) throw new InterruptedException(); &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125; &#125; /** * Acquires in shared timed mode. * * @param arg the acquire argument * @param nanosTimeout max wait time * @return &#123;@code true&#125; if acquired */ private boolean doAcquireSharedNanos(int arg, long nanosTimeout) throws InterruptedException &#123; if (nanosTimeout &lt;= 0L) return false; final long deadline = System.nanoTime() + nanosTimeout; final Node node = addWaiter(Node.SHARED); boolean failed = true; try &#123; for (;;) &#123; final Node p = node.predecessor(); if (p == head) &#123; int r = tryAcquireShared(arg); if (r &gt;= 0) &#123; setHeadAndPropagate(node, r); p.next = null; // help GC failed = false; return true; &#125; &#125; nanosTimeout = deadline - System.nanoTime(); if (nanosTimeout &lt;= 0L) return false; if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; nanosTimeout &gt; spinForTimeoutThreshold) LockSupport.parkNanos(this, nanosTimeout); if (Thread.interrupted()) throw new InterruptedException(); &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125; &#125; // Main exported methods /** * Attempts to acquire in exclusive mode. This method should query * if the state of the object permits it to be acquired in the * exclusive mode, and if so to acquire it. * * &lt;p&gt;This method is always invoked by the thread performing * acquire. If this method reports failure, the acquire method * may queue the thread, if it is not already queued, until it is * signalled by a release from some other thread. This can be used * to implement method &#123;@link Lock#tryLock()&#125;. * * &lt;p&gt;The default * implementation throws &#123;@link UnsupportedOperationException&#125;. * * @param arg the acquire argument. This value is always the one * passed to an acquire method, or is the value saved on entry * to a condition wait. The value is otherwise uninterpreted * and can represent anything you like. * @return &#123;@code true&#125; if successful. Upon success, this object has * been acquired. * @throws IllegalMonitorStateException if acquiring would place this * synchronizer in an illegal state. This exception must be * thrown in a consistent fashion for synchronization to work * correctly. * @throws UnsupportedOperationException if exclusive mode is not supported * * AQS实现独占模式获取锁，子类需要实现 */ protected boolean tryAcquire(int arg) &#123; throw new UnsupportedOperationException(); &#125; /** * Attempts to set the state to reflect a release in exclusive * mode. * * &lt;p&gt;This method is always invoked by the thread performing release. * * &lt;p&gt;The default implementation throws * &#123;@link UnsupportedOperationException&#125;. * * @param arg the release argument. This value is always the one * passed to a release method, or the current state value upon * entry to a condition wait. The value is otherwise * uninterpreted and can represent anything you like. * @return &#123;@code true&#125; if this object is now in a fully released * state, so that any waiting threads may attempt to acquire; * and &#123;@code false&#125; otherwise. * @throws IllegalMonitorStateException if releasing would place this * synchronizer in an illegal state. This exception must be * thrown in a consistent fashion for synchronization to work * correctly. * @throws UnsupportedOperationException if exclusive mode is not supported * * AQS独占模式下释放锁，子类需要实现 */ protected boolean tryRelease(int arg) &#123; throw new UnsupportedOperationException(); &#125; /** * Attempts to acquire in shared mode. This method should query if * the state of the object permits it to be acquired in the shared * mode, and if so to acquire it. * * &lt;p&gt;This method is always invoked by the thread performing * acquire. If this method reports failure, the acquire method * may queue the thread, if it is not already queued, until it is * signalled by a release from some other thread. * * &lt;p&gt;The default implementation throws &#123;@link * UnsupportedOperationException&#125;. * * @param arg the acquire argument. This value is always the one * passed to an acquire method, or is the value saved on entry * to a condition wait. The value is otherwise uninterpreted * and can represent anything you like. * @return a negative value on failure; zero if acquisition in shared * mode succeeded but no subsequent shared-mode acquire can * succeed; and a positive value if acquisition in shared * mode succeeded and subsequent shared-mode acquires might * also succeed, in which case a subsequent waiting thread * must check availability. (Support for three different * return values enables this method to be used in contexts * where acquires only sometimes act exclusively.) Upon * success, this object has been acquired. * @throws IllegalMonitorStateException if acquiring would place this * synchronizer in an illegal state. This exception must be * thrown in a consistent fashion for synchronization to work * correctly. * @throws UnsupportedOperationException if shared mode is not supported * * 共享模式下获取锁，子类需要实现 */ protected int tryAcquireShared(int arg) &#123; throw new UnsupportedOperationException(); &#125; /** * Attempts to set the state to reflect a release in shared mode. * * &lt;p&gt;This method is always invoked by the thread performing release. * * &lt;p&gt;The default implementation throws * &#123;@link UnsupportedOperationException&#125;. * * @param arg the release argument. This value is always the one * passed to a release method, or the current state value upon * entry to a condition wait. The value is otherwise * uninterpreted and can represent anything you like. * @return &#123;@code true&#125; if this release of shared mode may permit a * waiting acquire (shared or exclusive) to succeed; and * &#123;@code false&#125; otherwise * @throws IllegalMonitorStateException if releasing would place this * synchronizer in an illegal state. This exception must be * thrown in a consistent fashion for synchronization to work * correctly. * @throws UnsupportedOperationException if shared mode is not supported * * 共享模式下释放锁，子类需要实现 */ protected boolean tryReleaseShared(int arg) &#123; throw new UnsupportedOperationException(); &#125; /** * Returns &#123;@code true&#125; if synchronization is held exclusively with * respect to the current (calling) thread. This method is invoked * upon each call to a non-waiting &#123;@link ConditionObject&#125; method. * (Waiting methods instead invoke &#123;@link #release&#125;.) * * &lt;p&gt;The default implementation throws &#123;@link * UnsupportedOperationException&#125;. This method is invoked * internally only within &#123;@link ConditionObject&#125; methods, so need * not be defined if conditions are not used. * * @return &#123;@code true&#125; if synchronization is held exclusively; * &#123;@code false&#125; otherwise * @throws UnsupportedOperationException if conditions are not supported * * 该线程是否正在独占资源。只有用到Condition才需要去实现 */ protected boolean isHeldExclusively() &#123; throw new UnsupportedOperationException(); &#125; /** * Acquires in exclusive mode, ignoring interrupts. Implemented * by invoking at least once &#123;@link #tryAcquire&#125;, * returning on success. Otherwise the thread is queued, possibly * repeatedly blocking and unblocking, invoking &#123;@link * #tryAcquire&#125; until success. This method can be used * to implement method &#123;@link Lock#lock&#125;. * * @param arg the acquire argument. This value is conveyed to * &#123;@link #tryAcquire&#125; but is otherwise uninterpreted and * can represent anything you like. * * 获取锁的通用模式 * 1. tryAcquire(arg) 尝试获取锁，获取锁成功后返回true，获取锁失败后返回false * 2. addWaiter(Node.EXCLUSIVE) 获取锁后加入到队列中 * 3. acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) 这个加入队列后准备阻塞线程 */ public final void acquire(int arg) &#123; if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt(); &#125; /** * Acquires in exclusive mode, aborting if interrupted. * Implemented by first checking interrupt status, then invoking * at least once &#123;@link #tryAcquire&#125;, returning on * success. Otherwise the thread is queued, possibly repeatedly * blocking and unblocking, invoking &#123;@link #tryAcquire&#125; * until success or the thread is interrupted. This method can be * used to implement method &#123;@link Lock#lockInterruptibly&#125;. * * @param arg the acquire argument. This value is conveyed to * &#123;@link #tryAcquire&#125; but is otherwise uninterpreted and * can represent anything you like. * @throws InterruptedException if the current thread is interrupted */ public final void acquireInterruptibly(int arg) throws InterruptedException &#123; if (Thread.interrupted()) throw new InterruptedException(); if (!tryAcquire(arg)) doAcquireInterruptibly(arg); &#125; /** * Attempts to acquire in exclusive mode, aborting if interrupted, * and failing if the given timeout elapses. Implemented by first * checking interrupt status, then invoking at least once &#123;@link * #tryAcquire&#125;, returning on success. Otherwise, the thread is * queued, possibly repeatedly blocking and unblocking, invoking * &#123;@link #tryAcquire&#125; until success or the thread is interrupted * or the timeout elapses. This method can be used to implement * method &#123;@link Lock#tryLock(long, TimeUnit)&#125;. * * @param arg the acquire argument. This value is conveyed to * &#123;@link #tryAcquire&#125; but is otherwise uninterpreted and * can represent anything you like. * @param nanosTimeout the maximum number of nanoseconds to wait * @return &#123;@code true&#125; if acquired; &#123;@code false&#125; if timed out * @throws InterruptedException if the current thread is interrupted */ public final boolean tryAcquireNanos(int arg, long nanosTimeout) throws InterruptedException &#123; if (Thread.interrupted()) throw new InterruptedException(); return tryAcquire(arg) || doAcquireNanos(arg, nanosTimeout); &#125; /** * Releases in exclusive mode. Implemented by unblocking one or * more threads if &#123;@link #tryRelease&#125; returns true. * This method can be used to implement method &#123;@link Lock#unlock&#125;. * * @param arg the release argument. This value is conveyed to * &#123;@link #tryRelease&#125; but is otherwise uninterpreted and * can represent anything you like. * @return the value returned from &#123;@link #tryRelease&#125; * * 1. 释放锁的通用方法，当前线程用完了锁，一个是将其释放，然后唤醒下一个线程（排队或者正在获取锁的线程） * 2. tryRelease(arg) 设置状态state * 3. 在执行unparkSuccessor(h)之前，有个逻辑判断，这里获取的是head为-1，有排队的线程，否则是进不去的 */ public final boolean release(int arg) &#123; if (tryRelease(arg)) &#123; Node h = head; if (h != null &amp;&amp; h.waitStatus != 0) unparkSuccessor(h); return true; &#125; return false; &#125; /** * Acquires in shared mode, ignoring interrupts. Implemented by * first invoking at least once &#123;@link #tryAcquireShared&#125;, * returning on success. Otherwise the thread is queued, possibly * repeatedly blocking and unblocking, invoking &#123;@link * #tryAcquireShared&#125; until success. * * @param arg the acquire argument. This value is conveyed to * &#123;@link #tryAcquireShared&#125; but is otherwise uninterpreted * and can represent anything you like. */ public final void acquireShared(int arg) &#123; if (tryAcquireShared(arg) &lt; 0) doAcquireShared(arg); &#125; /** * Acquires in shared mode, aborting if interrupted. Implemented * by first checking interrupt status, then invoking at least once * &#123;@link #tryAcquireShared&#125;, returning on success. Otherwise the * thread is queued, possibly repeatedly blocking and unblocking, * invoking &#123;@link #tryAcquireShared&#125; until success or the thread * is interrupted. * @param arg the acquire argument. * This value is conveyed to &#123;@link #tryAcquireShared&#125; but is * otherwise uninterpreted and can represent anything * you like. * @throws InterruptedException if the current thread is interrupted */ public final void acquireSharedInterruptibly(int arg) throws InterruptedException &#123; if (Thread.interrupted()) throw new InterruptedException(); if (tryAcquireShared(arg) &lt; 0) doAcquireSharedInterruptibly(arg); &#125; /** * Attempts to acquire in shared mode, aborting if interrupted, and * failing if the given timeout elapses. Implemented by first * checking interrupt status, then invoking at least once &#123;@link * #tryAcquireShared&#125;, returning on success. Otherwise, the * thread is queued, possibly repeatedly blocking and unblocking, * invoking &#123;@link #tryAcquireShared&#125; until success or the thread * is interrupted or the timeout elapses. * * @param arg the acquire argument. This value is conveyed to * &#123;@link #tryAcquireShared&#125; but is otherwise uninterpreted * and can represent anything you like. * @param nanosTimeout the maximum number of nanoseconds to wait * @return &#123;@code true&#125; if acquired; &#123;@code false&#125; if timed out * @throws InterruptedException if the current thread is interrupted */ public final boolean tryAcquireSharedNanos(int arg, long nanosTimeout) throws InterruptedException &#123; if (Thread.interrupted()) throw new InterruptedException(); return tryAcquireShared(arg) &gt;= 0 || doAcquireSharedNanos(arg, nanosTimeout); &#125; /** * Releases in shared mode. Implemented by unblocking one or more * threads if &#123;@link #tryReleaseShared&#125; returns true. * * @param arg the release argument. This value is conveyed to * &#123;@link #tryReleaseShared&#125; but is otherwise uninterpreted * and can represent anything you like. * @return the value returned from &#123;@link #tryReleaseShared&#125; */ public final boolean releaseShared(int arg) &#123; if (tryReleaseShared(arg)) &#123; doReleaseShared(); return true; &#125; return false; &#125; // Queue inspection methods /** * Queries whether any threads are waiting to acquire. Note that * because cancellations due to interrupts and timeouts may occur * at any time, a &#123;@code true&#125; return does not guarantee that any * other thread will ever acquire. * * &lt;p&gt;In this implementation, this operation returns in * constant time. * * @return &#123;@code true&#125; if there may be other threads waiting to acquire */ public final boolean hasQueuedThreads() &#123; return head != tail; &#125; /** * Queries whether any threads have ever contended to acquire this * synchronizer; that is if an acquire method has ever blocked. * * &lt;p&gt;In this implementation, this operation returns in * constant time. * * @return &#123;@code true&#125; if there has ever been contention */ public final boolean hasContended() &#123; return head != null; &#125; /** * Returns the first (longest-waiting) thread in the queue, or * &#123;@code null&#125; if no threads are currently queued. * * &lt;p&gt;In this implementation, this operation normally returns in * constant time, but may iterate upon contention if other threads are * concurrently modifying the queue. * * @return the first (longest-waiting) thread in the queue, or * &#123;@code null&#125; if no threads are currently queued */ public final Thread getFirstQueuedThread() &#123; // handle only fast path, else relay return (head == tail) ? null : fullGetFirstQueuedThread(); &#125; /** * Version of getFirstQueuedThread called when fastpath fails */ private Thread fullGetFirstQueuedThread() &#123; /* * The first node is normally head.next. Try to get its * thread field, ensuring consistent reads: If thread * field is nulled out or s.prev is no longer head, then * some other thread(s) concurrently performed setHead in * between some of our reads. We try this twice before * resorting to traversal. */ Node h, s; Thread st; if (((h = head) != null &amp;&amp; (s = h.next) != null &amp;&amp; s.prev == head &amp;&amp; (st = s.thread) != null) || ((h = head) != null &amp;&amp; (s = h.next) != null &amp;&amp; s.prev == head &amp;&amp; (st = s.thread) != null)) return st; /* * Head&#x27;s next field might not have been set yet, or may have * been unset after setHead. So we must check to see if tail * is actually first node. If not, we continue on, safely * traversing from tail back to head to find first, * guaranteeing termination. */ Node t = tail; Thread firstThread = null; while (t != null &amp;&amp; t != head) &#123; Thread tt = t.thread; if (tt != null) firstThread = tt; t = t.prev; &#125; return firstThread; &#125; /** * Returns true if the given thread is currently queued. * * &lt;p&gt;This implementation traverses the queue to determine * presence of the given thread. * * @param thread the thread * @return &#123;@code true&#125; if the given thread is on the queue * @throws NullPointerException if the thread is null */ public final boolean isQueued(Thread thread) &#123; if (thread == null) throw new NullPointerException(); for (Node p = tail; p != null; p = p.prev) if (p.thread == thread) return true; return false; &#125; /** * Returns &#123;@code true&#125; if the apparent first queued thread, if one * exists, is waiting in exclusive mode. If this method returns * &#123;@code true&#125;, and the current thread is attempting to acquire in * shared mode (that is, this method is invoked from &#123;@link * #tryAcquireShared&#125;) then it is guaranteed that the current thread * is not the first queued thread. Used only as a heuristic in * ReentrantReadWriteLock. */ final boolean apparentlyFirstQueuedIsExclusive() &#123; Node h, s; return (h = head) != null &amp;&amp; (s = h.next) != null &amp;&amp; !s.isShared() &amp;&amp; s.thread != null; &#125; /** * Queries whether any threads have been waiting to acquire longer * than the current thread. * * &lt;p&gt;An invocation of this method is equivalent to (but may be * more efficient than): * &lt;pre&gt; &#123;@code * getFirstQueuedThread() != Thread.currentThread() &amp;&amp; * hasQueuedThreads()&#125;&lt;/pre&gt; * * &lt;p&gt;Note that because cancellations due to interrupts and * timeouts may occur at any time, a &#123;@code true&#125; return does not * guarantee that some other thread will acquire before the current * thread. Likewise, it is possible for another thread to win a * race to enqueue after this method has returned &#123;@code false&#125;, * due to the queue being empty. * * &lt;p&gt;This method is designed to be used by a fair synchronizer to * avoid &lt;a href=&quot;AbstractQueuedSynchronizer#barging&quot;&gt;barging&lt;/a&gt;. * Such a synchronizer&#x27;s &#123;@link #tryAcquire&#125; method should return * &#123;@code false&#125;, and its &#123;@link #tryAcquireShared&#125; method should * return a negative value, if this method returns &#123;@code true&#125; * (unless this is a reentrant acquire). For example, the &#123;@code * tryAcquire&#125; method for a fair, reentrant, exclusive mode * synchronizer might look like this: * * &lt;pre&gt; &#123;@code * protected boolean tryAcquire(int arg) &#123; * if (isHeldExclusively()) &#123; * // A reentrant acquire; increment hold count * return true; * &#125; else if (hasQueuedPredecessors()) &#123; * return false; * &#125; else &#123; * // try to acquire normally * &#125; * &#125;&#125;&lt;/pre&gt; * * @return &#123;@code true&#125; if there is a queued thread preceding the * current thread, and &#123;@code false&#125; if the current thread * is at the head of the queue or the queue is empty * @since 1.7 * * 在尝试获取锁时调用，判断是否有不包含当前线程中队列的前置节点，有就可以去尝试获取锁 */ public final boolean hasQueuedPredecessors() &#123; // The correctness of this depends on head being initialized // before tail and on head.next being accurate if the current // thread is first in queue. Node t = tail; // Read fields in reverse initialization order Node h = head; Node s; return h != t &amp;&amp; ((s = h.next) == null || s.thread != Thread.currentThread()); &#125; // Instrumentation and monitoring methods /** * Returns an estimate of the number of threads waiting to * acquire. The value is only an estimate because the number of * threads may change dynamically while this method traverses * internal data structures. This method is designed for use in * monitoring system state, not for synchronization * control. * * @return the estimated number of threads waiting to acquire */ public final int getQueueLength() &#123; int n = 0; for (Node p = tail; p != null; p = p.prev) &#123; if (p.thread != null) ++n; &#125; return n; &#125; /** * Returns a collection containing threads that may be waiting to * acquire. Because the actual set of threads may change * dynamically while constructing this result, the returned * collection is only a best-effort estimate. The elements of the * returned collection are in no particular order. This method is * designed to facilitate construction of subclasses that provide * more extensive monitoring facilities. * * @return the collection of threads */ public final Collection&lt;Thread&gt; getQueuedThreads() &#123; ArrayList&lt;Thread&gt; list = new ArrayList&lt;Thread&gt;(); for (Node p = tail; p != null; p = p.prev) &#123; Thread t = p.thread; if (t != null) list.add(t); &#125; return list; &#125; /** * Returns a collection containing threads that may be waiting to * acquire in exclusive mode. This has the same properties * as &#123;@link #getQueuedThreads&#125; except that it only returns * those threads waiting due to an exclusive acquire. * * @return the collection of threads */ public final Collection&lt;Thread&gt; getExclusiveQueuedThreads() &#123; ArrayList&lt;Thread&gt; list = new ArrayList&lt;Thread&gt;(); for (Node p = tail; p != null; p = p.prev) &#123; if (!p.isShared()) &#123; Thread t = p.thread; if (t != null) list.add(t); &#125; &#125; return list; &#125; /** * Returns a collection containing threads that may be waiting to * acquire in shared mode. This has the same properties * as &#123;@link #getQueuedThreads&#125; except that it only returns * those threads waiting due to a shared acquire. * * @return the collection of threads */ public final Collection&lt;Thread&gt; getSharedQueuedThreads() &#123; ArrayList&lt;Thread&gt; list = new ArrayList&lt;Thread&gt;(); for (Node p = tail; p != null; p = p.prev) &#123; if (p.isShared()) &#123; Thread t = p.thread; if (t != null) list.add(t); &#125; &#125; return list; &#125; /** * Returns a string identifying this synchronizer, as well as its state. * The state, in brackets, includes the String &#123;@code &quot;State =&quot;&#125; * followed by the current value of &#123;@link #getState&#125;, and either * &#123;@code &quot;nonempty&quot;&#125; or &#123;@code &quot;empty&quot;&#125; depending on whether the * queue is empty. * * @return a string identifying this synchronizer, as well as its state */ public String toString() &#123; int s = getState(); String q = hasQueuedThreads() ? &quot;non&quot; : &quot;&quot;; return super.toString() + &quot;[State = &quot; + s + &quot;, &quot; + q + &quot;empty queue]&quot;; &#125; // Internal support methods for Conditions /** * Returns true if a node, always one that was initially placed on * a condition queue, is now waiting to reacquire on sync queue. * @param node the node * @return true if is reacquiring */ final boolean isOnSyncQueue(Node node) &#123; if (node.waitStatus == Node.CONDITION || node.prev == null) return false; if (node.next != null) // If has successor, it must be on queue return true; /* * node.prev can be non-null, but not yet on queue because * the CAS to place it on queue can fail. So we have to * traverse from tail to make sure it actually made it. It * will always be near the tail in calls to this method, and * unless the CAS failed (which is unlikely), it will be * there, so we hardly ever traverse much. */ return findNodeFromTail(node); &#125; /** * Returns true if node is on sync queue by searching backwards from tail. * Called only when needed by isOnSyncQueue. * @return true if present */ private boolean findNodeFromTail(Node node) &#123; Node t = tail; for (;;) &#123; if (t == node) return true; if (t == null) return false; t = t.prev; &#125; &#125; /** * Transfers a node from a condition queue onto sync queue. * Returns true if successful. * @param node the node * @return true if successfully transferred (else the node was * cancelled before signal) */ final boolean transferForSignal(Node node) &#123; /* * If cannot change waitStatus, the node has been cancelled. */ if (!compareAndSetWaitStatus(node, Node.CONDITION, 0)) return false; /* * Splice onto queue and try to set waitStatus of predecessor to * indicate that thread is (probably) waiting. If cancelled or * attempt to set waitStatus fails, wake up to resync (in which * case the waitStatus can be transiently and harmlessly wrong). */ Node p = enq(node); int ws = p.waitStatus; if (ws &gt; 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL)) LockSupport.unpark(node.thread); return true; &#125; /** * Transfers node, if necessary, to sync queue after a cancelled wait. * Returns true if thread was cancelled before being signalled. * * @param node the node * @return true if cancelled before the node was signalled */ final boolean transferAfterCancelledWait(Node node) &#123; if (compareAndSetWaitStatus(node, Node.CONDITION, 0)) &#123; enq(node); return true; &#125; /* * If we lost out to a signal(), then we can&#x27;t proceed * until it finishes its enq(). Cancelling during an * incomplete transfer is both rare and transient, so just * spin. */ while (!isOnSyncQueue(node)) Thread.yield(); return false; &#125; /** * Invokes release with current state value; returns saved state. * Cancels node and throws exception on failure. * @param node the condition node for this wait * @return previous sync state */ final int fullyRelease(Node node) &#123; boolean failed = true; try &#123; int savedState = getState(); if (release(savedState)) &#123; failed = false; return savedState; &#125; else &#123; throw new IllegalMonitorStateException(); &#125; &#125; finally &#123; if (failed) node.waitStatus = Node.CANCELLED; &#125; &#125; // Instrumentation methods for conditions /** * Queries whether the given ConditionObject * uses this synchronizer as its lock. * * @param condition the condition * @return &#123;@code true&#125; if owned * @throws NullPointerException if the condition is null */ public final boolean owns(ConditionObject condition) &#123; return condition.isOwnedBy(this); &#125; /** * Queries whether any threads are waiting on the given condition * associated with this synchronizer. Note that because timeouts * and interrupts may occur at any time, a &#123;@code true&#125; return * does not guarantee that a future &#123;@code signal&#125; will awaken * any threads. This method is designed primarily for use in * monitoring of the system state. * * @param condition the condition * @return &#123;@code true&#125; if there are any waiting threads * @throws IllegalMonitorStateException if exclusive synchronization * is not held * @throws IllegalArgumentException if the given condition is * not associated with this synchronizer * @throws NullPointerException if the condition is null */ public final boolean hasWaiters(ConditionObject condition) &#123; if (!owns(condition)) throw new IllegalArgumentException(&quot;Not owner&quot;); return condition.hasWaiters(); &#125; /** * Returns an estimate of the number of threads waiting on the * given condition associated with this synchronizer. Note that * because timeouts and interrupts may occur at any time, the * estimate serves only as an upper bound on the actual number of * waiters. This method is designed for use in monitoring of the * system state, not for synchronization control. * * @param condition the condition * @return the estimated number of waiting threads * @throws IllegalMonitorStateException if exclusive synchronization * is not held * @throws IllegalArgumentException if the given condition is * not associated with this synchronizer * @throws NullPointerException if the condition is null */ public final int getWaitQueueLength(ConditionObject condition) &#123; if (!owns(condition)) throw new IllegalArgumentException(&quot;Not owner&quot;); return condition.getWaitQueueLength(); &#125; /** * Returns a collection containing those threads that may be * waiting on the given condition associated with this * synchronizer. Because the actual set of threads may change * dynamically while constructing this result, the returned * collection is only a best-effort estimate. The elements of the * returned collection are in no particular order. * * @param condition the condition * @return the collection of threads * @throws IllegalMonitorStateException if exclusive synchronization * is not held * @throws IllegalArgumentException if the given condition is * not associated with this synchronizer * @throws NullPointerException if the condition is null */ public final Collection&lt;Thread&gt; getWaitingThreads(ConditionObject condition) &#123; if (!owns(condition)) throw new IllegalArgumentException(&quot;Not owner&quot;); return condition.getWaitingThreads(); &#125; /** * Condition implementation for a &#123;@link * AbstractQueuedSynchronizer&#125; serving as the basis of a &#123;@link * Lock&#125; implementation. * * &lt;p&gt;Method documentation for this class describes mechanics, * not behavioral specifications from the point of view of Lock * and Condition users. Exported versions of this class will in * general need to be accompanied by documentation describing * condition semantics that rely on those of the associated * &#123;@code AbstractQueuedSynchronizer&#125;. * * &lt;p&gt;This class is Serializable, but all fields are transient, * so deserialized conditions have no waiters. */ public class ConditionObject implements Condition, java.io.Serializable &#123; private static final long serialVersionUID = 1173984872572414699L; /** First node of condition queue. */ private transient Node firstWaiter; /** Last node of condition queue. */ private transient Node lastWaiter; /** * Creates a new &#123;@code ConditionObject&#125; instance. */ public ConditionObject() &#123; &#125; // Internal methods /** * Adds a new waiter to wait queue. * @return its new wait node */ private Node addConditionWaiter() &#123; Node t = lastWaiter; // If lastWaiter is cancelled, clean out. if (t != null &amp;&amp; t.waitStatus != Node.CONDITION) &#123; unlinkCancelledWaiters(); t = lastWaiter; &#125; Node node = new Node(Thread.currentThread(), Node.CONDITION); if (t == null) firstWaiter = node; else t.nextWaiter = node; lastWaiter = node; return node; &#125; /** * Removes and transfers nodes until hit non-cancelled one or * null. Split out from signal in part to encourage compilers * to inline the case of no waiters. * @param first (non-null) the first node on condition queue */ private void doSignal(Node first) &#123; do &#123; if ( (firstWaiter = first.nextWaiter) == null) lastWaiter = null; first.nextWaiter = null; &#125; while (!transferForSignal(first) &amp;&amp; (first = firstWaiter) != null); &#125; /** * Removes and transfers all nodes. * @param first (non-null) the first node on condition queue */ private void doSignalAll(Node first) &#123; lastWaiter = firstWaiter = null; do &#123; Node next = first.nextWaiter; first.nextWaiter = null; transferForSignal(first); first = next; &#125; while (first != null); &#125; /** * Unlinks cancelled waiter nodes from condition queue. * Called only while holding lock. This is called when * cancellation occurred during condition wait, and upon * insertion of a new waiter when lastWaiter is seen to have * been cancelled. This method is needed to avoid garbage * retention in the absence of signals. So even though it may * require a full traversal, it comes into play only when * timeouts or cancellations occur in the absence of * signals. It traverses all nodes rather than stopping at a * particular target to unlink all pointers to garbage nodes * without requiring many re-traversals during cancellation * storms. */ private void unlinkCancelledWaiters() &#123; Node t = firstWaiter; Node trail = null; while (t != null) &#123; Node next = t.nextWaiter; if (t.waitStatus != Node.CONDITION) &#123; t.nextWaiter = null; if (trail == null) firstWaiter = next; else trail.nextWaiter = next; if (next == null) lastWaiter = trail; &#125; else trail = t; t = next; &#125; &#125; // public methods /** * Moves the longest-waiting thread, if one exists, from the * wait queue for this condition to the wait queue for the * owning lock. * * @throws IllegalMonitorStateException if &#123;@link #isHeldExclusively&#125; * returns &#123;@code false&#125; */ public final void signal() &#123; if (!isHeldExclusively()) throw new IllegalMonitorStateException(); Node first = firstWaiter; if (first != null) doSignal(first); &#125; /** * Moves all threads from the wait queue for this condition to * the wait queue for the owning lock. * * @throws IllegalMonitorStateException if &#123;@link #isHeldExclusively&#125; * returns &#123;@code false&#125; */ public final void signalAll() &#123; if (!isHeldExclusively()) throw new IllegalMonitorStateException(); Node first = firstWaiter; if (first != null) doSignalAll(first); &#125; /** * Implements uninterruptible condition wait. * &lt;ol&gt; * &lt;li&gt; Save lock state returned by &#123;@link #getState&#125;. * &lt;li&gt; Invoke &#123;@link #release&#125; with saved state as argument, * throwing IllegalMonitorStateException if it fails. * &lt;li&gt; Block until signalled. * &lt;li&gt; Reacquire by invoking specialized version of * &#123;@link #acquire&#125; with saved state as argument. * &lt;/ol&gt; */ public final void awaitUninterruptibly() &#123; Node node = addConditionWaiter(); int savedState = fullyRelease(node); boolean interrupted = false; while (!isOnSyncQueue(node)) &#123; LockSupport.park(this); if (Thread.interrupted()) interrupted = true; &#125; if (acquireQueued(node, savedState) || interrupted) selfInterrupt(); &#125; /* * For interruptible waits, we need to track whether to throw * InterruptedException, if interrupted while blocked on * condition, versus reinterrupt current thread, if * interrupted while blocked waiting to re-acquire. */ /** Mode meaning to reinterrupt on exit from wait */ private static final int REINTERRUPT = 1; /** Mode meaning to throw InterruptedException on exit from wait */ private static final int THROW_IE = -1; /** * Checks for interrupt, returning THROW_IE if interrupted * before signalled, REINTERRUPT if after signalled, or * 0 if not interrupted. */ private int checkInterruptWhileWaiting(Node node) &#123; return Thread.interrupted() ? (transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) : 0; &#125; /** * Throws InterruptedException, reinterrupts current thread, or * does nothing, depending on mode. */ private void reportInterruptAfterWait(int interruptMode) throws InterruptedException &#123; if (interruptMode == THROW_IE) throw new InterruptedException(); else if (interruptMode == REINTERRUPT) selfInterrupt(); &#125; /** * Implements interruptible condition wait. * &lt;ol&gt; * &lt;li&gt; If current thread is interrupted, throw InterruptedException. * &lt;li&gt; Save lock state returned by &#123;@link #getState&#125;. * &lt;li&gt; Invoke &#123;@link #release&#125; with saved state as argument, * throwing IllegalMonitorStateException if it fails. * &lt;li&gt; Block until signalled or interrupted. * &lt;li&gt; Reacquire by invoking specialized version of * &#123;@link #acquire&#125; with saved state as argument. * &lt;li&gt; If interrupted while blocked in step 4, throw InterruptedException. * &lt;/ol&gt; */ public final void await() throws InterruptedException &#123; if (Thread.interrupted()) throw new InterruptedException(); Node node = addConditionWaiter(); int savedState = fullyRelease(node); int interruptMode = 0; while (!isOnSyncQueue(node)) &#123; LockSupport.park(this); if ((interruptMode = checkInterruptWhileWaiting(node)) != 0) break; &#125; if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE) interruptMode = REINTERRUPT; if (node.nextWaiter != null) // clean up if cancelled unlinkCancelledWaiters(); if (interruptMode != 0) reportInterruptAfterWait(interruptMode); &#125; /** * Implements timed condition wait. * &lt;ol&gt; * &lt;li&gt; If current thread is interrupted, throw InterruptedException. * &lt;li&gt; Save lock state returned by &#123;@link #getState&#125;. * &lt;li&gt; Invoke &#123;@link #release&#125; with saved state as argument, * throwing IllegalMonitorStateException if it fails. * &lt;li&gt; Block until signalled, interrupted, or timed out. * &lt;li&gt; Reacquire by invoking specialized version of * &#123;@link #acquire&#125; with saved state as argument. * &lt;li&gt; If interrupted while blocked in step 4, throw InterruptedException. * &lt;/ol&gt; */ public final long awaitNanos(long nanosTimeout) throws InterruptedException &#123; if (Thread.interrupted()) throw new InterruptedException(); Node node = addConditionWaiter(); int savedState = fullyRelease(node); final long deadline = System.nanoTime() + nanosTimeout; int interruptMode = 0; while (!isOnSyncQueue(node)) &#123; if (nanosTimeout &lt;= 0L) &#123; transferAfterCancelledWait(node); break; &#125; if (nanosTimeout &gt;= spinForTimeoutThreshold) LockSupport.parkNanos(this, nanosTimeout); if ((interruptMode = checkInterruptWhileWaiting(node)) != 0) break; nanosTimeout = deadline - System.nanoTime(); &#125; if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE) interruptMode = REINTERRUPT; if (node.nextWaiter != null) unlinkCancelledWaiters(); if (interruptMode != 0) reportInterruptAfterWait(interruptMode); return deadline - System.nanoTime(); &#125; /** * Implements absolute timed condition wait. * &lt;ol&gt; * &lt;li&gt; If current thread is interrupted, throw InterruptedException. * &lt;li&gt; Save lock state returned by &#123;@link #getState&#125;. * &lt;li&gt; Invoke &#123;@link #release&#125; with saved state as argument, * throwing IllegalMonitorStateException if it fails. * &lt;li&gt; Block until signalled, interrupted, or timed out. * &lt;li&gt; Reacquire by invoking specialized version of * &#123;@link #acquire&#125; with saved state as argument. * &lt;li&gt; If interrupted while blocked in step 4, throw InterruptedException. * &lt;li&gt; If timed out while blocked in step 4, return false, else true. * &lt;/ol&gt; */ public final boolean awaitUntil(Date deadline) throws InterruptedException &#123; long abstime = deadline.getTime(); if (Thread.interrupted()) throw new InterruptedException(); Node node = addConditionWaiter(); int savedState = fullyRelease(node); boolean timedout = false; int interruptMode = 0; while (!isOnSyncQueue(node)) &#123; if (System.currentTimeMillis() &gt; abstime) &#123; timedout = transferAfterCancelledWait(node); break; &#125; LockSupport.parkUntil(this, abstime); if ((interruptMode = checkInterruptWhileWaiting(node)) != 0) break; &#125; if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE) interruptMode = REINTERRUPT; if (node.nextWaiter != null) unlinkCancelledWaiters(); if (interruptMode != 0) reportInterruptAfterWait(interruptMode); return !timedout; &#125; /** * Implements timed condition wait. * &lt;ol&gt; * &lt;li&gt; If current thread is interrupted, throw InterruptedException. * &lt;li&gt; Save lock state returned by &#123;@link #getState&#125;. * &lt;li&gt; Invoke &#123;@link #release&#125; with saved state as argument, * throwing IllegalMonitorStateException if it fails. * &lt;li&gt; Block until signalled, interrupted, or timed out. * &lt;li&gt; Reacquire by invoking specialized version of * &#123;@link #acquire&#125; with saved state as argument. * &lt;li&gt; If interrupted while blocked in step 4, throw InterruptedException. * &lt;li&gt; If timed out while blocked in step 4, return false, else true. * &lt;/ol&gt; */ public final boolean await(long time, TimeUnit unit) throws InterruptedException &#123; long nanosTimeout = unit.toNanos(time); if (Thread.interrupted()) throw new InterruptedException(); Node node = addConditionWaiter(); int savedState = fullyRelease(node); final long deadline = System.nanoTime() + nanosTimeout; boolean timedout = false; int interruptMode = 0; while (!isOnSyncQueue(node)) &#123; if (nanosTimeout &lt;= 0L) &#123; timedout = transferAfterCancelledWait(node); break; &#125; if (nanosTimeout &gt;= spinForTimeoutThreshold) LockSupport.parkNanos(this, nanosTimeout); if ((interruptMode = checkInterruptWhileWaiting(node)) != 0) break; nanosTimeout = deadline - System.nanoTime(); &#125; if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE) interruptMode = REINTERRUPT; if (node.nextWaiter != null) unlinkCancelledWaiters(); if (interruptMode != 0) reportInterruptAfterWait(interruptMode); return !timedout; &#125; // support for instrumentation /** * Returns true if this condition was created by the given * synchronization object. * * @return &#123;@code true&#125; if owned */ final boolean isOwnedBy(AbstractQueuedSynchronizer sync) &#123; return sync == AbstractQueuedSynchronizer.this; &#125; /** * Queries whether any threads are waiting on this condition. * Implements &#123;@link AbstractQueuedSynchronizer#hasWaiters(ConditionObject)&#125;. * * @return &#123;@code true&#125; if there are any waiting threads * @throws IllegalMonitorStateException if &#123;@link #isHeldExclusively&#125; * returns &#123;@code false&#125; */ protected final boolean hasWaiters() &#123; if (!isHeldExclusively()) throw new IllegalMonitorStateException(); for (Node w = firstWaiter; w != null; w = w.nextWaiter) &#123; if (w.waitStatus == Node.CONDITION) return true; &#125; return false; &#125; /** * Returns an estimate of the number of threads waiting on * this condition. * Implements &#123;@link AbstractQueuedSynchronizer#getWaitQueueLength(ConditionObject)&#125;. * * @return the estimated number of waiting threads * @throws IllegalMonitorStateException if &#123;@link #isHeldExclusively&#125; * returns &#123;@code false&#125; */ protected final int getWaitQueueLength() &#123; if (!isHeldExclusively()) throw new IllegalMonitorStateException(); int n = 0; for (Node w = firstWaiter; w != null; w = w.nextWaiter) &#123; if (w.waitStatus == Node.CONDITION) ++n; &#125; return n; &#125; /** * Returns a collection containing those threads that may be * waiting on this Condition. * Implements &#123;@link AbstractQueuedSynchronizer#getWaitingThreads(ConditionObject)&#125;. * * @return the collection of threads * @throws IllegalMonitorStateException if &#123;@link #isHeldExclusively&#125; * returns &#123;@code false&#125; */ protected final Collection&lt;Thread&gt; getWaitingThreads() &#123; if (!isHeldExclusively()) throw new IllegalMonitorStateException(); ArrayList&lt;Thread&gt; list = new ArrayList&lt;Thread&gt;(); for (Node w = firstWaiter; w != null; w = w.nextWaiter) &#123; if (w.waitStatus == Node.CONDITION) &#123; Thread t = w.thread; if (t != null) list.add(t); &#125; &#125; return list; &#125; &#125; /** * Setup to support compareAndSet. We need to natively implement * this here: For the sake of permitting future enhancements, we * cannot explicitly subclass AtomicInteger, which would be * efficient and useful otherwise. So, as the lesser of evils, we * natively implement using hotspot intrinsics API. And while we * are at it, we do the same for other CASable fields (which could * otherwise be done with atomic field updaters). * * 这里是使用unsafe来操作，cas操作，原子操作 * */ private static final Unsafe unsafe = Unsafe.getUnsafe(); private static final long stateOffset; private static final long headOffset; private static final long tailOffset; private static final long waitStatusOffset; private static final long nextOffset; static &#123; try &#123; stateOffset = unsafe.objectFieldOffset (AbstractQueuedSynchronizer.class.getDeclaredField(&quot;state&quot;)); headOffset = unsafe.objectFieldOffset (AbstractQueuedSynchronizer.class.getDeclaredField(&quot;head&quot;)); tailOffset = unsafe.objectFieldOffset (AbstractQueuedSynchronizer.class.getDeclaredField(&quot;tail&quot;)); waitStatusOffset = unsafe.objectFieldOffset (Node.class.getDeclaredField(&quot;waitStatus&quot;)); nextOffset = unsafe.objectFieldOffset (Node.class.getDeclaredField(&quot;next&quot;)); &#125; catch (Exception ex) &#123; throw new Error(ex); &#125; &#125; /** * CAS head field. Used only by enq. */ private final boolean compareAndSetHead(Node update) &#123; return unsafe.compareAndSwapObject(this, headOffset, null, update); &#125; /** * CAS tail field. Used only by enq. */ private final boolean compareAndSetTail(Node expect, Node update) &#123; return unsafe.compareAndSwapObject(this, tailOffset, expect, update); &#125; /** * CAS waitStatus field of a node. */ private static final boolean compareAndSetWaitStatus(Node node, int expect, int update) &#123; return unsafe.compareAndSwapInt(node, waitStatusOffset, expect, update); &#125; /** * CAS next field of a node. */ private static final boolean compareAndSetNext(Node node, Node expect, Node update) &#123; return unsafe.compareAndSwapObject(node, nextOffset, expect, update); &#125;&#125; 公平锁 非公平锁","categories":[{"name":"并发","slug":"并发","permalink":"http://example.com/categories/%E5%B9%B6%E5%8F%91/"}],"tags":[{"name":"并发","slug":"并发","permalink":"http://example.com/tags/%E5%B9%B6%E5%8F%91/"}],"author":"jianghe"},{"title":"synchronized","slug":"并发synchronized详解","date":"2021-05-19T01:02:00.000Z","updated":"2021-07-06T15:00:15.392Z","comments":true,"path":"2021/05/19/并发synchronized详解/","link":"","permalink":"http://example.com/2021/05/19/%E5%B9%B6%E5%8F%91synchronized%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"如何解决并发问题&nbsp;&nbsp;&nbsp;&nbsp;实际上，所有的并发模式在解决并发安全问题时，采用的方案都是序列化访问临界资源。即在同一时刻，只能有一个线程访问临界资源，也称作同步互质访问。Java中提供了两种方式来实现同步互质访问：synchronized和lock。同步器的本质就是加锁，加锁的目的：序列化访问临界资源。 当多个线程执行一个方法时，该方法的局部变量并不是临界资源，因为这些局部变量是在每个线程的私有栈中，因此不具备共享性，不会导致线程安全问题 12345678910111213141516171819202122private static int total = 0; public static void main(String[] args) throws InterruptedException &#123; CountDownLatch countDownLatch = new CountDownLatch(1); for (int i = 0; i &lt; 10; i++) &#123; new Thread(()-&gt;&#123; try &#123; countDownLatch.await(); for (int j = 0; j &lt; 1000; j++) &#123; total++; &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;).start(); &#125; Thread.sleep(200); countDownLatch.countDown(); Thread.sleep(2000); System.out.println(total); &#125; 这样的方式先采用countDownLatch.await()，然后再执行countDownLatch.countDown()，可以最大限度实现并发，这里的CountDownLatch为1，结果肯定是小于10000，解决方式可以采用synchronized和lock 锁发展历史 jdk&lt;1.6是jdk自带的，这是第一代加锁方式，但是这种锁非常的重，一旦加锁，都是采用os实现的加锁方式，这里就会发生上下文切换，空间切换，非常缓慢。 doug li看synchronized太慢了，自己开发了一个并发包，juc，性能非常好，纯java写的，里面还实现了jdk没有的特性，虽然底层还是调用了一个java内置的函数。 oracle收购sun公司后，优化了synchronized，锁的膨胀升级，锁粗化，锁消除，现在的性能和aqs差不多。 synchronized原理详解&nbsp;&nbsp;&nbsp;&nbsp;这里主要还是聊jdk&gt;=1/6后的synchronized。&nbsp;&nbsp;&nbsp;&nbsp;synchronized内置锁是一种对象锁（锁的是对象而非引用），作用粒度是对象，可以用来实现对临界资源的访问，是可重入的。 12345public synchronized void a() 锁的是这个实例对象public static synchronized void a() 锁的是这个类对象public void a()&#123; 锁的是括号里的这个对象 synchronized(Object.class)&#125; synchronized底层原理&nbsp;&nbsp;&nbsp;&nbsp;synchronized是基于JVM内置锁实现，通过内部对象Monitor（监视器锁）实现。基于进入与退出Monitor对象实现方法与代码块同步，监视器锁的实现依赖操作系统的Mutex Lock（互斥锁）实现，它是一个重量级锁性能低。（在&gt;=jdk1.6，实现重量级锁是monitor锁，轻量级锁、偏向锁不是使用monitor锁）当然JVM内置锁在jdk&gt;=1.6后做了升级优化，锁粗化（Lock Coarsening）、锁消除（Lock Elimination）、轻量级锁（LightWeight Locking）、偏向锁（Biased Locking）、适应性自旋锁（adaptive Spinning）等技术减少锁的开销。 jdk&gt;=1.6，偏向锁、轻量级锁的实现是通过对象头的mark word锁标识和lock record来实现。那为什么一个线程的锁编译还是有monitorenter和monitorexit呢？其实是编译器加的https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-3.htmlThe compiler ensures that at any method invocation completion, a monitorexit instruction will have been executed for each monitorenter instruction executed since the method invocation. monitor监视器锁&nbsp;&nbsp;&nbsp;&nbsp;任何一个对象都有一个monitor与之关联，并且一个monitor被持有后，它将处于锁定状态。synchronized在jvm里的实现都是基于进入和退出monitor对象来实现方法的同步与代码块同步。虽然具体实现细节不一样，但是都可以成对的monitorenter和monitorexit指令来实现。 monitorenter 当monitorenter为0，如果线程进入monitor，则进入数加1，该线程持有了monitor * 如果这个线程持有了monitor，尝试再进入monitor（例如方法调用方法），则monitor的进入数加1 * 那其他线程已经占有的monitor，则其他线程会阻塞状态，直至monitor的进入数为0，再重新尝试获取monitor的所有权 monitorexit 执行monitorexit的线程必须是objectref所对应的monitor的所有者，指令执行时，monitor的进入数减1，如果减1为0，那线程退出monitor，不再是这个monitor的持有者了。 下面这个例子，其中有一个monitorenter和两个monitorexit，两个中的一个是异常情况下的退出 123456789101112131415161718192021222324252627 private Object object = new Object(); public void sync()&#123; synchronized (object)&#123; System.out.println(111); &#125; &#125;#对应的字节码public void sync(); Code: 0: aload_0 1: getfield #3 // Field object:Ljava/lang/Object; 4: dup 5: astore_1 6: monitorenter 7: getstatic #4 // Field java/lang/System.out:Ljava/io/PrintStream; 10: bipush 111 12: invokevirtual #5 // Method java/io/PrintStream.println:(I)V 15: aload_1 16: monitorexit 17: goto 25 20: astore_2 21: aload_1 22: monitorexit 23: aload_2 24: athrow 25: return 下面这个例子是修饰在方法上，看字节码，里面的flags增加了ACC_SYNCHRONIZED，虽然没有加上monitor对象，但是jvm也能根据这个标识来实现方法的同步，当调用指令将会检查方法的ACC_SYNCHRONIZED访问标志是否被设置，如果设置了，执行线程将先获取monitor，获取成功之后才能执行方法体，方法执行完了再释放monitor。 1234567891011121314151617181920 public synchronized void syncO()&#123; System.out.println(111); &#125;# 对应字节码public synchronized void syncO(); descriptor: ()V flags: ACC_PUBLIC, ACC_SYNCHRONIZED Code: stack=2, locals=1, args_size=1 0: getstatic #4 // Field java/lang/System.out:Ljava/io/PrintStream; 3: bipush 111 5: invokevirtual #5 // Method java/io/PrintStream.println:(I)V 8: return LineNumberTable: line 14: 0 line 15: 8 LocalVariableTable: Start Length Slot Name Signature 0 9 0 this Ljuc/juc04/SynchronizedDemo; 两种同步方法本质上没有区别，只是方法的同步是一种隐式的方法来实现，无需通过字节码来完成。两个指令的执行是jvm通过调用操作系统的互斥源于mutex来实现，被阻塞的线程会被挂起，等待重新调度，会导致”用户态和内核态“两个态切换。 Synchronized的语义底层是通过一个monitor的对象来完成，其实wait/notify等方法也依赖于monitor对象，这就是为什么只有在同步的块或者方法中才能调用wait/notify等方法，否则 会抛出java.lang.IllegalMonitorStateException的异常的原因。 什么是monitor&nbsp;&nbsp;&nbsp;&nbsp;monitor可以把它理解为一个同步工具，也可以描述为一个同步机制，它通常被描述一个对象。所有的java对象都是monitor，每一个java对象都有成为monitor的潜质。因为在java设计中，每一个java对象都带一把看不见的锁，它叫做内部锁或者monitor锁。也就是synchronized的对象锁。MarkWord锁标志位为10，其中指针指向monitor对象的起始地址。 在jdk中Monitor由ObjectMonitor.hpp文件实现的（c++实现）。 1234567891011121314151617181920ObjectMonitor() &#123; _header = NULL; _count = 0; //记录个数 _waiters = 0, _recursions = 0; _object = NULL; _owner = NULL; // 线程拥有者 _WaitSet = NULL; // 等待wait状态的线程，会被加入到这里 _WaitSetLock = 0 ; _Responsible = NULL ; _succ = NULL ; _cxq = NULL ; FreeNext = NULL ; _EntryList = NULL ;// 处于等待锁block状态的线程，会被加入到这里 _SpinFreq = 0 ; _SpinClock = 0 ; OwnerIsThread = 0 ; _previous_owner_tid = 0; &#125; ObjectMonitor中有两个队列，_WaitSet和_EntryList，用来保存ObjectWaiter对象列表（每个等待锁的线程都会被封装成ObjectWaiter对象），_owner指向持有ObjectMonitor对象的线程，多个线程访问一个同步代码时： 首先会进入_EntryList，当线程获取到对象的monitor后，进入_owner区域并把monitor的_owner为当前线程，同时_count计数器会加1 若线程调用wait()方法，将释放当前持有的monitor，owner变量恢复为null，count自减1，同时该线程进入waitSet集合中等待被唤醒 若当前线程执行完毕，也将释放monitor并复位count的值，以便其他线程进入获取monitor。 monitor对象存在于每个java对象的对象头mark word中（存储的指针的指向），synchronized锁便是通过这种方式获取锁的，也是为什么java中任意对象可以作为锁的原因，同时notify、notifyAll、wait等方法会使用monitor对象，所以必须在同步代码块中使用。 对象的内存布局&nbsp;&nbsp;&nbsp;&nbsp;当成功对分配的内存空间进行零值初始化后，jvm就会对对象进行实例化。在hotSpot中，对象实例化操作无非就是初始化对象头和实例数据，而且存储对象实例信息的内存布局也主要由这两个部分组成。 对象头 主要存储Mark Word和元数据指针等数据，其中Mark Word主要用于存储对象运行时的数据信息，比如HashCode、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。元数据指针则是用于指向方法区中目标类的类型信息，也就是说可以通过元数据指针可以准确定位到当前对象的具体目标类型 实例数据 用于存储定义在当前对象中各种类型的字段信息（包括派生于超类的字段信息） 对齐填充 由于虚拟机要求对象起始地址必须是8字节的整数倍。填充数据不是必须存在的，仅仅是为了字节对齐 Mark Word&nbsp;&nbsp;&nbsp;&nbsp;现在我们虚拟机基本是64位的，而64位的对象头有点浪费空间,JVM默认会开启指针压缩，所以基本上也是按32位的形式记录对象头的，手动设置‐XX:+UseCompressedOops mark word，有方法可以去看吗？ 123456789# 1. 引入下面pom&lt;dependency&gt; &lt;groupId&gt;org.openjdk.jol&lt;/groupId&gt; &lt;artifactId&gt;jol-core&lt;/artifactId&gt; &lt;version&gt;0.15&lt;/version&gt;&lt;/dependency&gt;# 2.打印对象头，object是锁对象System.out.println(ClassLayout.parseInstance(object).toPrintable()); 锁的膨胀升级过程&nbsp;&nbsp;&nbsp;&nbsp;锁的状态总共有四种，无锁状态、偏向锁、轻量级锁、重量级锁。锁可以从偏向锁升级到轻量级锁，再升级到重量级锁，锁的升级是单向的，只能从低到高，不会出现锁的降级。 偏向锁&nbsp;&nbsp;&nbsp;&nbsp;偏向锁是在jdk1.6引入的新锁，它是一种针对加锁的优化手段，经过研究发现，在大多情况下，锁不仅不存在多线程竞争，而且总是有同一线程多次获得，因此为了减少同一线程获取锁（会涉及一些cas操作，耗时）的代价而引入偏向锁。偏向锁的核心思想是，如果一个线程获得了锁，那么锁就进入偏向模式，此时Mark Word的结构也变为偏向锁的结构，当这个线程再次请求锁时，无需再做任何同步的操作，从而节省锁的申请过程，提供了性能。所以，对于没有锁竞争的场合，偏向锁有很好的效果，毕竟极有可能连续多次是同一线程申请相同的锁。但是对于锁竞争比较激烈的场合，偏向锁就失效了，因为这个场合极有可能申请锁的线程是不相同的，因此使用偏向锁就得不偿失，需要注意的是，偏向锁失败后，并不会直接升级重量级锁，而是先升级轻量级锁。 123默认开启偏向锁 开启偏向锁：-XX:+UseBiasedLocking -XX:BiasedLockingStartupDelay=0 关闭偏向锁：-XX:-UseBiasedLocking 下面是偏向锁的例子 123456Thread.sleep(5000); Object o = new Object(); System.out.println(ClassLayout.parseInstance(o).toPrintable()); synchronized (o)&#123; System.out.println(ClassLayout.parseInstance(o).toPrintable()); &#125; 打印Mark Word 123456789101112131415java.lang.Object object internals:OFF SZ TYPE DESCRIPTION VALUE 0 8 (object header: mark) 0x0000000000000005 (biasable; age: 0) 8 4 (object header: class) 0xf80001e5 12 4 (object alignment gap) Instance size: 16 bytesSpace losses: 0 bytes internal + 4 bytes external = 4 bytes totaljava.lang.Object object internals:OFF SZ TYPE DESCRIPTION VALUE 0 8 (object header: mark) 0x00007fd8f000a805 (biased: 0x0000001ff63c002a; epoch: 0; age: 0) 8 4 (object header: class) 0xf80001e5 12 4 (object alignment gap) Instance size: 16 bytesSpace losses: 0 bytes internal + 4 bytes external = 4 bytes total 其中，java虚拟机开启偏向锁是懒加载的方式，默认需要等待4s的时间，因为java虚拟机在启动的时候，里面有多个线程会去加载，会存在竞争，如果打开偏向锁，多个线程竞争还需要锁升级，这里要演示偏向锁就需要等待4s多，其中biasable表示无锁状态，但是可偏向，表示能偏向线程，mark word 为101，但是mark word 前面字节都是0，但是还没有偏向。biased表示偏向锁。 轻量级锁&nbsp;&nbsp;&nbsp;&nbsp;偏向锁失败后，虚拟机并不会立马升级为重量级锁，它还会尝试使用一种轻量级锁的优化手段，此时Mark Word的结构也变为轻量级锁的结构。轻量级锁能够提升程序性能的依据是“对绝大部分的锁，在整个同步周期内都不存在竞争”，注意这是经验数据。轻量级锁所适应的场景是线程交替执行同步块的场合，如果存在同一时间访问同一个锁的场景，就会导致轻量级锁升级为重量级锁。 下面是轻量级锁的例子 12345678910111213141516171819Thread.sleep(5000); final Object o = new Object(); System.out.println(ClassLayout.parseInstance(o).toPrintable()); new Thread(new Runnable() &#123; public void run() &#123; synchronized (o)&#123; System.out.println(ClassLayout.parseInstance(o).toPrintable()); &#125; &#125; &#125;).start(); // 等待的时间如果长的话，接下来mark word不一定是轻量级锁，如果等待3s有可能是偏向锁，看资源已经释放 Thread.sleep(30); new Thread(new Runnable() &#123; public void run() &#123; synchronized (o)&#123; System.out.println(ClassLayout.parseInstance(o).toPrintable()); &#125; &#125; &#125;).start(); 打印Mark Word 123456789101112131415161718192021222324java.lang.Object object internals:OFF SZ TYPE DESCRIPTION VALUE 0 8 (object header: mark) 0x0000000000000005 (biasable; age: 0) 8 4 (object header: class) 0xf80001e5 12 4 (object alignment gap) Instance size: 16 bytesSpace losses: 0 bytes internal + 4 bytes external = 4 bytes totaljava.lang.Object object internals:OFF SZ TYPE DESCRIPTION VALUE 0 8 (object header: mark) 0x00007f81460aa805 (biased: 0x0000001fe05182aa; epoch: 0; age: 0) 8 4 (object header: class) 0xf80001e5 12 4 (object alignment gap) Instance size: 16 bytesSpace losses: 0 bytes internal + 4 bytes external = 4 bytes totaljava.lang.Object object internals:OFF SZ TYPE DESCRIPTION VALUE 0 8 (object header: mark) 0x0000700003528960 (thin lock: 0x0000700003528960) 8 4 (object header: class) 0xf80001e5 12 4 (object alignment gap) Instance size: 16 bytesSpace losses: 0 bytes internal + 4 bytes external = 4 bytes total 还有一个例子，是调用对象的hashCode会导致偏向锁升级为轻量级锁 1234567891011Thread.sleep(5000); Object o = new Object(); System.out.println(ClassLayout.parseInstance(o).toPrintable()); synchronized (o)&#123; System.out.println(ClassLayout.parseInstance(o).toPrintable()); &#125; System.out.println(o.hashCode()); // 会将偏向锁升级为轻量级锁 System.out.println(ClassLayout.parseInstance(o).toPrintable()); //可重偏向 synchronized (o)&#123; System.out.println(ClassLayout.parseInstance(o).toPrintable()); // 轻量级锁 &#125; 打印的Mark Word 123456789101112131415161718192021222324252627282930313233java.lang.Object object internals:OFF SZ TYPE DESCRIPTION VALUE 0 8 (object header: mark) 0x0000000000000005 (biasable; age: 0) 8 4 (object header: class) 0xf80001e5 12 4 (object alignment gap) Instance size: 16 bytesSpace losses: 0 bytes internal + 4 bytes external = 4 bytes totaljava.lang.Object object internals:OFF SZ TYPE DESCRIPTION VALUE 0 8 (object header: mark) 0x00007ffeda809005 (biased: 0x0000001fffb6a024; epoch: 0; age: 0) 8 4 (object header: class) 0xf80001e5 12 4 (object alignment gap) Instance size: 16 bytesSpace losses: 0 bytes internal + 4 bytes external = 4 bytes total607635164java.lang.Object object internals:OFF SZ TYPE DESCRIPTION VALUE 0 8 (object header: mark) 0x0000002437c6dc01 (hash: 0x2437c6dc; age: 0) 8 4 (object header: class) 0xf80001e5 12 4 (object alignment gap) Instance size: 16 bytesSpace losses: 0 bytes internal + 4 bytes external = 4 bytes totaljava.lang.Object object internals:OFF SZ TYPE DESCRIPTION VALUE 0 8 (object header: mark) 0x000070000c4d2988 (thin lock: 0x000070000c4d2988) 8 4 (object header: class) 0xf80001e5 12 4 (object alignment gap) Instance size: 16 bytesSpace losses: 0 bytes internal + 4 bytes external = 4 bytes total 那打印的System.out.println(o.hashCode());不是锁降为无锁状态，而是此时作为没有synchronized修饰对象，获取的此时对象的头。那这里为什么偏向锁调用hashCode会升级偏向锁呢？由于偏向锁的时候Mark Word里是没有存储hashCode，而轻量级锁里面是有hashCode的，hashCode是锁对象里的Mark Word的指针指向栈中lock record中的mark word的hashCode，详细见锁的膨胀升级。那这是直接调用底层生成的hashcode，还是使用的lock record的hashcode，这块是不确定的。 自旋锁&nbsp;&nbsp;&nbsp;&nbsp;轻量级锁失败后，虚拟机为了避免线程真实地在操作系统层面挂起，还会进行一项称为自旋锁的手段。这是基于在大多情况下，线程持有锁的时间都不太长，如果直接挂起操作系统层面的线程可能会得不偿失，毕竟操作系统实现线程之间的切换时需要从用户态切换到核心态，这个状态切换是需要时间的，成本比较高。因此自旋锁会假设在不久将来，当前的线程可以获取锁，因此虚拟机会让当前想要获取锁的线程做几个空循环（这也是成为自旋的原因），一般不会太久，可能是50个循环或100循环，在经过若干次循环后，如果得到锁，就顺利进入临界区。如果还不能获取锁，那就会将线程在操作系统层面挂起，这就是自旋锁的优化。否则就升级为重量级锁 锁消除&nbsp;&nbsp;&nbsp;&nbsp;锁消除是虚拟机的另外一种锁的优化。这种优化更彻底，java虚拟机在Jit编译时（可以简单理解为当某段代码即将第一次被执行时进行编译，又称及时编译），通过对上下文的扫描，去除不可能存在共享资源竞争的锁，通过这种方式消除没有必要的锁，可以节省毫无意义的请求锁时间。所消除的依据是逃逸分析的数据支持。 如StringBuffer的append是一个同步方法，但是在add方法中的StringBuffer属于一个局部变量，并且不会被其他线程所使用，因此StringBuffer不可能存在共享资源竞争的情景，JVM会自动将其锁消除。 123456public void sync()&#123; Object obj = new Object(); synchronized(obj)&#123; // xxx &#125;&#125; 这里的synchronized可以去掉，锁的对象是方法内部，不会存在竞争 锁消除，前提是java必须运行在server模式，同时必须开启逃逸分析:-XX:+DoEscapeAnalysis 开启逃逸分析-XX:+EliminateLocks 表示开启锁消除。 锁粗化&nbsp;&nbsp;&nbsp;&nbsp;按理来说，同步块的作用范围应该尽可能小，仅在共享数据的实际作用域中才进行同步，这样做的目的是为了使需要同步的操作数量尽可能缩小，缩短阻塞时间，如果存在锁竞争，那么等待锁的线程也能尽快拿到锁。但是加锁解锁也需要消耗资源，如果存在一系列的连续加锁解锁操作，可能会导致不必要的性能损耗。锁粗化就是将多个连续的加锁、解锁操作连接在一起，扩展成一个范围更大的锁，避免频繁的加锁解锁操作。 1234567891011public void sync()&#123; synchronized(Object.class)&#123; // aaa &#125; synchronized(Object.class)&#123; // bbb &#125; synchronized(Object.class)&#123; // ccc &#125;&#125; 可以优化为 1234567public void sync()&#123; synchronized(Object.class)&#123; // aaa // bbb // ccc &#125;&#125;","categories":[{"name":"并发","slug":"并发","permalink":"http://example.com/categories/%E5%B9%B6%E5%8F%91/"}],"tags":[{"name":"并发","slug":"并发","permalink":"http://example.com/tags/%E5%B9%B6%E5%8F%91/"}],"author":"jianghe"},{"title":"MESI","slug":"MESI","date":"2021-05-15T12:17:00.000Z","updated":"2021-07-06T15:00:15.406Z","comments":true,"path":"2021/05/15/MESI/","link":"","permalink":"http://example.com/2021/05/15/MESI/","excerpt":"","text":"jvm整个执行过程 volatile可见性1234567891011121314151617181920212223242526272829303132333435363738394041/** * 打印汇编 * 在jdk库里加上/Library/Java/JavaVirtualMachines/jdk1.8.0_201.jdk/Contents/Home/jre/lib/hsdis-amd64.dylib * vm options：-server -Xcomp -XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly -XX:CompileCommand=compileonly,*JavaVolatile.fresh */public class JavaVolatile &#123; private volatile static boolean initFlag = false; private static int j = 0; private static void fresh()&#123; initFlag = true; &#125; public static void main(String[] args) &#123; Thread thread = new Thread(new Runnable() &#123; public void run() &#123; while (!initFlag) &#123; j++; &#125; System.out.println(&quot;param=&quot; + initFlag); &#125; &#125;); Thread thread1 = new Thread(new Runnable() &#123; public void run() &#123; fresh(); &#125; &#125;); thread.start(); try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; thread1.start(); &#125;&#125; 其中输出结果如下，发现被volatile修饰的initFlag中有lock#打头。 123450x000000010657165b: movabs $0x7956a1a38,%rsi ; &#123;oop(a &#x27;java/lang/Class&#x27; = &#x27;juc/juc03/JavaVolatile&#x27;)&#125;0x0000000106571665: mov $0x1,%edi0x000000010657166a: mov %dil,0x6c(%rsi)0x000000010657166e: lock addl $0x0,(%rsp) ;*putstatic initFlag ; - juc.juc03.JavaVolatile::fresh@1 (line 14) 总线锁和缓存一致性协议lock#是汇编指令。用lock会触发硬件缓存锁定机制。总线锁和缓存一致性协议。 在IA-32架构中有描述以下文字：在修改内存操作时，使用 LOCK 前缀去调用加锁的读-修改-写操作(原子的)。这种机制用于多处理器系统中处理器之间进行可靠的通讯，具体描述如下：在 Pentium 和早期的 IA-32 处理器中，LOCK 前缀会使处理器执行当前指令时产生一个 LOCK#信号，这总是引起显式总线锁定出现 总线锁&nbsp;&nbsp;&nbsp;&nbsp;早期技术比较落后，cpu多核操作主内存，会发生线程安全问题，然后会加一个总线锁来解决线程安全。如果一个cpu要操作数据，首先先获取总线锁。然后再去操作数据。但是这样的效率非常低，一个cpu拿到总线锁，另外的cpu就只能等待。发挥不了多核的能力。 这里要引申下，现在还是用到总线锁，是在mesi操作不了的时候才采用总线锁，那么什么是mesi操作不了，那接下来看下mesi。这里还是解释下，由于cpu数据是放在cache line里的，如果锁不住cache line。就只能是用总线锁。（什么情况下锁不住cache line，使用多个cache line，多个cache line不是原子操作） 缓存一致性协议（MESI）现在的处理器都是多核处理器，并且每个核都带有多个缓存（指令缓存和数据缓存，见下图）。为什么需要缓存呢，这是因为CPU访问内存的速度比较慢，所以在CPU和内存之间加了个缓存以提高访问速度。既然每个核都有缓存，那么假设两个核或者多个核同时访问同一个变量时这些缓存是如何进行同步的呢（缓存细分为一个个缓存行），这就有了MESI协议。MESI是指4个状态的首字母。每个cache line有4个状态。用两个2个bit表示。 状态 描述 监听任务 M(修改) 该cache line有效，数据被修改了，和内存中的数据不一致，数据只存在本cache中 缓存行必须时刻监听所有试图读该缓存行相对就主存的操作，这种操作必须在缓存将该缓存行写回主存并将状态变成S（共享）状态之前被延迟执行 E(独享) 该Cache line有效，数据和内存中的数据一致，数据只存在于本Cache中。 缓存行也必须监听其它缓存读主存中该缓存行的操作，一旦有这种操作，该缓存行需要变成S（共享）状态。 S(共享) 该Cache line有效，数据和内存中的数据一致，数据存在于很多Cache中。 缓存行也必须监听其它缓存使该缓存行无效或者独享该缓存行的请求，并将该缓存行变成无效（Invalid）。 I(无效) 该Cache line无效。 无 对于M和E状态而言总是精准的。他们在和该缓存行的真正状态是一致的，而S状态有可能是不一致的。如果一个缓存将处于S状态的缓存行作废了，而另一个缓存实际上可能已经独享了该缓存行，但是该缓存却不会将该缓存行升迁为E状态，这是因为其它缓存不会广播他们作废掉该缓存行的通知，同样由于缓存并没有保存该缓存行的copy的数量，因此（即使有这种通知）也没有办法确定自己是否已经独享了该缓存行。从上面的意义看来E状态是一种投机性的优化：如果一个CPU想修改一个处于S状态的缓存行，总线事务需要将所有该缓存行的copy变成invalid状态，而修改E状态的缓存不需要使用总线事务。 MESI状态切换理解该图的前置说明： 触发事件 本地读取(local read)-本地内核读取本地cache数据 本地写入(local write)-本地内核写入本地cache数据 远端读取(remote read)-其它内核读取其它Cache中的值 远端写入(remote write)-其他内核写入其他cache数据 MESI状态扭转： 当前状态 事件 行为 下一个状态 I local read 如果其它Cache没有这份数据，本Cache从内存中取数据，Cache line状态变成E； 如果其它Cache有这份数据，且状态为M，则将数据更新到内存，本Cache再从内存中取数据，2个Cache 的Cache line状态都变成S；如果其它Cache有这份数据，且状态为S或者E，本Cache从内存中取数据，这些Cache 的Cache line状态都变成S E/S local write 从内存中取数据，在Cache中修改，状态变成M； 如果其它Cache有这份数据，且状态为M，则要先将数据更新到内存； 如果其它Cache有这份数据，则其它Cache的Cache line状态变成I M remote read 既然是Invalid，别的核的操作与它无关 I remote write 既然是Invalid，别的核的操作与它无关 I E local read 从Cache中取数据，状态不变 E local write 修改Cache中的数据，状态变成M M remote read 数据和其它核共用，状态变成了S S remote write 数据被修改，本Cache line不能再使用，状态变成I I S local read 从Cache中取数据，状态不变 S local write 修改Cache中的数据，状态变成M，其它核共享的Cache line状态变成I M remote read 状态不变 S remote write 数据被修改，本Cache line不能再使用，状态变成I I M local read 从Cache中取数据，状态不变 E local write 修改Cache中的数据，状态不变 M remote read 这行数据被写到内存中，使其它核能使用到最新的数据，状态变成S S remote write 这行数据被写到内存中，使其它核能使用到最新的数据，由于其它核会修改这行数据，状态变成I I Store Buffer和Invalidate QueueCPU架构中传统的MESI协议中有两个行为的执行成本比较大。一个是将某个Cache Line标记为Invalid状态，另一个是当某Cache Line当前状态为Invalid时写入新的数据。所以CPU通过Store Buffer和Invalidate Queue组件来降低这类操作的延时。 当一个核心在Invalid状态进行写入时，首先会给其它CPU核发送Invalid消息，然后把当前写入的数据写入到Store Buffer中。然后异步在某个时刻真正的写入到Cache Line中。当前CPU核如果要读Cache Line中的数据，需要先扫描Store Buffer之后再读取Cache Line（Store-Buffer Forwarding）。但是此时其它CPU核是看不到当前核的Store Buffer中的数据的，要等到Store Buffer中的数据被刷到了Cache Line之后才会触发失效操作。而当一个CPU核收到Invalid消息时，会把消息写入自身的Invalidate Queue中，随后异步将其设为Invalid状态。和Store Buffer不同的是，当前CPU核心使用Cache时并不扫描Invalidate Queue部分，所以可能会有极短时间的脏读问题。这里的Store Buffer和Invalidate Queue的说法是针对一般的SMP架构来说的，不涉及具体架构。","categories":[{"name":"并发","slug":"并发","permalink":"http://example.com/categories/%E5%B9%B6%E5%8F%91/"}],"tags":[{"name":"并发","slug":"并发","permalink":"http://example.com/tags/%E5%B9%B6%E5%8F%91/"}],"author":"jianghe"},{"title":"JMM内存模型","slug":"JMM内存模型","date":"2021-04-22T13:01:00.000Z","updated":"2021-07-06T15:00:15.402Z","comments":true,"path":"2021/04/22/JMM内存模型/","link":"","permalink":"http://example.com/2021/04/22/JMM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/","excerpt":"","text":"什么是JMM?&nbsp;&nbsp;&nbsp;&nbsp;Java 内存模型（Java Mermory Model）是一个抽象的概念，并不真实存在。它描述的是一种规范和准则，通过这组规范定义了程序中各个变量的访问方式。它是描述的线程模型。JVM运行程序的实体是线程，而每个线程创建时JVM都会为其创建一个工作内存，用户存储线程私有的数据，而Java内存模型中规定所有变量都存储在主内存，主内存是共享区域，所有线程都可以访问，但线程对变量的操作必须在工作内存中，其中首先会从主内存中变量复制到工作内存中，然后对变量进行操作后写会到主内存中。不同的工作线程无法通信，只能通过主内存来进行通信。 主内存&nbsp;&nbsp;&nbsp;&nbsp;主要存储的是java对象，所有线程创建的实例对象都存放在主内存，不管该实例对象是成员变量还是局部变量，还包括类信息、常量、静态变量。由于是共享区域，会发生线程安全问题。 工作内存&nbsp;&nbsp;&nbsp;&nbsp;主要存储当前方法的所有本地方法变量，存储的主内存的变量副本，每个线程只能访问自己的工作内存，线程间无法通信，工作内存不存在线程安全问题。 JMM和jvm内存区域模型关系&nbsp;&nbsp;&nbsp;&nbsp;提起jvm内存模型，那就肯定有堆、栈、本地方法栈、方法区、程序计数器这些，他和jmm有相似之处，都有共享区域和私有区域，不同的地方是，jmm是描述的一个规范，通过这种规范来控制变量在共享区域和私有区域的访问方式，jmm围绕的还是原子性、可见性、有序性。 JMM和硬件内存架构关系&nbsp;&nbsp;&nbsp;&nbsp;从前面可以了解到，多线程的执行还是会映射到硬件上，但是jmm和硬件内存架构并不完全一致。硬件内存架构只有寄存器、缓存内存、主内存的概念，并没有工作内存和主内存。对于硬件内存架构中数据存储在主内存、寄存器中。java内存模型和计算机硬件内存架构是一个相互交叉的关系，是一种抽象和真实物理硬件的交叉。 JMM存在必要性&nbsp;&nbsp;&nbsp;&nbsp;从下面这个问题，线程B读取的值到底是1还是2，工作内存读取主内存变量实现细节，jmm定义了八种操作来完成，来解决这类问题。 数据同步八大原子操作 lock（锁定）：作用于主内存的变量，把一个变量标记为一条线程独占状态 unlock（解锁）：作用于主内存的变量，把一个变量处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定 read（读取）：作用于主内存的变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用 load（载入）：作用于工作内存的变量，他把read操作从主内存中得到的变量值放入工作内存的变量副本中 use（使用）：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎 assign（赋值）：作用于工作内存的变量，他把一个从执行引擎执行后的变量赋值给工作内存的变量 store（存储）：作用于工作内存的变量，把工作内存中的一个变量的值传递给主内存中，以便随后的write的操作 write（写入）：作用于工作内存的变量，它把store操作从工作内存中的一个变量的值传送到主内存的变量中 同步规则分析 不允许一个线程无原因地把数据（没有经过任何assign操作）从工作内存同步到主内存中 一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化变量。 一个变量在同一时刻只允许一条线程对其进行lock操作，但lock操作可以被同一线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，才有可能被其他线程给获取。lock和unlock必须成对出现 如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量之前需要重新执行load或assign操作初始化变量的值 如果一个变量事先没有被lock操作锁定，则不允许对它执行unlock操作；也不允许去 unlock一个被其他线程锁定的变量。 对一个变量执行unlock操作之前，必须先把此变量同步到主内存中（执行store和write 操作） 三大特性问题原子性问题&nbsp;&nbsp;&nbsp;&nbsp;原子性指的是一个操作是不可中断的，即使在多线程的环境下，一个操作一旦开始就不会被其他线程影响。在并发情况下可以使用synchronized关键字来解决原子性,后面会着重讲解synchronized和lock 1234567891011121314151617181920# private static int count = 0; static Object o = new Object(); public static void main(String[] args) throws InterruptedException &#123; for (int i = 0; i &lt; 10; i++) &#123; new Thread(new Runnable() &#123; public void run() &#123; for (int j = 0; j &lt;1000; j++) &#123; synchronized (o) &#123; //一个线程只能进入一次 count++; //不会发生指令重排 &#125; &#125; &#125; &#125;).start(); &#125; Thread.sleep(200); System.out.println(count); &#125; 可见性问题下面这个会出现可见性问题 1234567891011121314151617181920private static boolean initFlag = false; public static void main(String[] args) throws InterruptedException &#123; new Thread(new Runnable() &#123; public void run() &#123; System.out.println(&quot;thread 1 start&quot;); while (!initFlag)&#123; &#125; System.out.println(&quot;thread 1 stop&quot;); &#125; &#125;).start(); Thread.sleep(200); // 休眠 new Thread(new Runnable() &#123; public void run() &#123; System.out.println(&quot;thread 2 start&quot;); initFlag = true; System.out.println(&quot;thread 2 stop&quot;); &#125; &#125;).start(); &#125; 可见性解决方案，后面会着重讲解volatile和synchronized 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121# 第一种方案（volatile可以解决可见性问题，通过MESI来控制）private static volatile boolean initFlag = false; public static void main(String[] args) throws InterruptedException &#123; new Thread(new Runnable() &#123; public void run() &#123; System.out.println(&quot;thread 1 start&quot;); while (!initFlag)&#123; &#125; System.out.println(&quot;thread 1 stop&quot;); &#125; &#125;).start(); Thread.sleep(200); // 休眠 new Thread(new Runnable() &#123; public void run() &#123; System.out.println(&quot;thread 2 start&quot;); initFlag = true; System.out.println(&quot;thread 2 stop&quot;); &#125; &#125;).start(); &#125; # 第二种方案（原因有可能是i和initFlag在一个cacheline上面，导致获取i的时候initFlag也读取到最新的）private static boolean initFlag = false; // 如果换成int类型就不可以了 private static Integer i = 0; public static void main(String[] args) throws InterruptedException &#123; new Thread(new Runnable() &#123; public void run() &#123; System.out.println(&quot;thread 1 start&quot;); while (!initFlag)&#123; i++; &#125; System.out.println(&quot;thread 1 stop&quot;); &#125; &#125;).start(); Thread.sleep(200); // 休眠 new Thread(new Runnable() &#123; public void run() &#123; System.out.println(&quot;thread 2 start&quot;); initFlag = true; System.out.println(&quot;thread 2 stop&quot;); &#125; &#125;).start(); &#125; # 第三种方案（原因有可能是i和initFlag在一个cacheline上面，导致获取i的时候initFlag也读取到最新的）private static boolean initFlag = false; private static volatile int i = 0; public static void main(String[] args) throws InterruptedException &#123; new Thread(new Runnable() &#123; public void run() &#123; System.out.println(&quot;thread 1 start&quot;); while (!initFlag)&#123; i++; &#125; System.out.println(&quot;thread 1 stop&quot;); &#125; &#125;).start(); Thread.sleep(200); // 休眠 new Thread(new Runnable() &#123; public void run() &#123; System.out.println(&quot;thread 2 start&quot;); initFlag = true; System.out.println(&quot;thread 2 stop&quot;); &#125; &#125;).start(); &#125; # 第四种方案（为什么加上sout就会可以，因为空循环的优先级非常高，一旦获取cpu，很难切换时间片的）private static boolean initFlag = false; public static void main(String[] args) throws InterruptedException &#123; new Thread(new Runnable() &#123; public void run() &#123; System.out.println(&quot;thread 1 start&quot;); while (!initFlag)&#123; System.out.println(111); &#125; System.out.println(&quot;thread 1 stop&quot;); &#125; &#125;).start(); Thread.sleep(200); // 休眠 new Thread(new Runnable() &#123; public void run() &#123; System.out.println(&quot;thread 2 start&quot;); initFlag = true; System.out.println(&quot;thread 2 stop&quot;); &#125; &#125;).start(); &#125; # 第五种方案（jvm 增加-Djava.compiler=NONE 这是关掉jvm jit编译，jit编译优化是：编译过一次，下次再执行的时候就不用再次编译了，类似于for循环，就非常好）private static boolean initFlag = false; // 注意这里是int类型 private static int i = 0; public static void main(String[] args) throws InterruptedException &#123; new Thread(new Runnable() &#123; public void run() &#123; System.out.println(&quot;thread 1 start&quot;); while (!initFlag)&#123; i++; &#125; System.out.println(&quot;thread 1 stop&quot;); &#125; &#125;).start(); Thread.sleep(200); // 休眠 new Thread(new Runnable() &#123; public void run() &#123; System.out.println(&quot;thread 2 start&quot;); initFlag = true; System.out.println(&quot;thread 2 stop&quot;); &#125; &#125;).start(); &#125; 有序性问题123456789101112131415161718192021222324252627282930313233343536373839404142434445private static Integer x, y = 0; private static Integer a, b = 0; public static void main(String[] args) throws InterruptedException &#123; int i=0; for (;;)&#123; i++; x=0;y=0; a=0;b=0; Thread t1 = new Thread(new Runnable() &#123; public void run() &#123; // 等待 sleep(); a = 1; x = b; &#125; &#125;); Thread t2 = new Thread(new Runnable() &#123; public void run() &#123; // 等待 sleep(); b = 1; y = a; &#125; &#125;); t1.start(); t2.start(); t1.join(); t2.join(); if(x ==0 &amp;&amp; y ==0)&#123; System.out.println(&quot;第&quot;+i+&quot;次&quot;+&quot;,x=&quot;+x+&quot;,y=&quot;+y); break; &#125;else&#123; System.out.println(&quot;第&quot;+i+&quot;次&quot;+&quot;,x=&quot;+x+&quot;,y=&quot;+y); &#125; &#125; &#125; private static void sleep() &#123; try &#123; Thread.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; 当x和y都是0的时候就发生指令重排，可以通过volatile来解决。 happens-before原则&nbsp;&nbsp;&nbsp;&nbsp;每个线程都有自己的工作内存。每个线程对变量的操作都必须在工作内存中进行，而不是直接对主内存进行操作。并且每个线程不能访问其他线程的工作内存。在java内存模型中存在一些先天的“有序性”，即不需要通过任何手段就能够得到程序的有序性。这个就是happens-before原则。如果两个操作无法从happens-before原则推导出来，那么他们就不能保证有序性。那happens-before原则原则就是如下： 程序顺序原则，即在一个线程内必须保证语义串行性，也就是说按照代码顺序执行。 锁规则 解锁(unlock)操作必然发生在后续的同一个锁的加锁(lock)之前，也就是说，如果对于一个锁解锁后，再加锁，那么加锁的动作必须在解锁动作之后(同一个 锁)。 volatile规则 volatile变量的写，先发生于读，这保证了volatile变量的可见性，简 单的理解就是，volatile变量在每次被线程访问时，都强迫从主内存中读该变量的 值，而当该变量发生变化时，又会强迫将最新的值刷新到主内存，任何时刻，不同的 线程总是能够看到该变量的最新值。 4. 线程启动规则 线程的start()方法先于它的每一个动作，即如果线程A在执行线程B 的start方法之前修改了共享变量的值，那么当线程B执行start方法时，线程A对共享 变量的修改对线程B可见 传递性 A先于B ，B先于C 那么A必然先于C 线程终止规则 线程的所有操作先于线程的终结，Thread.join()方法的作用是等待 当前执行的线程终止。假设在线程B终止之前，修改了共享变量，线程A从线程B的 join方法成功返回后，线程B对共享变量的修改将对线程A可见。 线程中断规则 对线程 interrupt()方法的调用先行发生于被中断线程的代码检测到 中断事件的发生，可以通过Thread.interrupted()方法检测线程是否中断。 对象终结规则对象的构造函数执行，结束先于finalize()方法 指令重排&nbsp;&nbsp;&nbsp;&nbsp;java语言规范规定jvm线程内部维持顺序化语义。即只要程序的最终结果与它顺序的结果相等，那么指令的执行顺序可以与代码顺序不一致，此过程叫指令的重排序。指令重排的意义在哪？jvm能够根据处理器的特性（CPU多级缓存、多核处理器等）适当对机器指令进行重排序，是机器指令能更符合CPU的执行特性，最大限度发挥机器性能。 as-if-serial语义不管怎么重排序（编译器和处理器为了提高并行度），（单线程下）程序的执行结果不能被改变。编译器，runtime 和处理器都必须遵守as-if-serial语义。 volatile语义&nbsp;&nbsp;&nbsp;&nbsp;volatile是java虚拟机提供的轻量级的同步机制。有两个作用： 可见性，一个被volatile变量修改会被其他线程感知到 有序性，通过内存屏障，禁止指令重排 无法保证原子性，参照下面的代码，并发情况下，执行incr方法会线程安全问题，可以通过synchronized解决。其中synchronized本身也具有可见性，故不用volatile修饰 12345private static volatile Interger counter = 0public static void incr()&#123; counter++; // 不会发生指令重排，但是不是原子性&#125; 这里引申下，dcl（双重检测锁）在并发情况下，会有线程问题，细节不过多展示，那这里需要加入volatile，这里volatile和synchronized都必须在，因为不加volatile,这里instance = new Instance()会发生指令重排，会出现线程问题 1234567891011private static Instance instance;public static Instance getInstance()&#123; if(instance == null)&#123; synchronized(Instance.class)&#123; if(instance == null)&#123; instance = new Instance(); &#125; &#125; &#125;&#125; volatile禁止重排优化&nbsp;&nbsp;&nbsp;&nbsp;要说明volatile禁止重排，这里就的引入一个名词内存屏障（memory barrier）。 内存屏障是一个cpu指令。jvm有四个内存屏障指令。 屏蔽类型 指令实例 说明 LoadLoad Load1;LoadLoad;Load2 保证Load1的读取操作在Load2之前 StoreStore Store1;StoreStore;Store2 在Store2及其后的写操作执行前，保证Store1的写操作已刷新到主内存 LoadStore Load1;LoadStore;Store2; 在Store2及其后的写操作执行前，保证Load1的读操作是正确数据 StoreLoad Store1;StoreLoad;Load2 保证Store1的写操作已刷新内存，Load2读取数据是正确数据 编译器屏障（Compiler Barrior）阻止编译器重排，保证编译程序时在优化屏障之前的指令不会在优化屏障之后执行。 123/* The &quot;volatile&quot; is due to gcc bugs */#define barrier() __asm__ __volatile__(&quot;&quot;: : :&quot;memory&quot;) CPU屏障（Cpu Barrior） 作用： 防止指令重排序 保证数据可见性 分类： lfence，是一种Load Barrior 读屏障，会将invalidate queue失效，强制读取L1 Cache中，而且lfence之后的读操作不会被调度到之前，即lfence的读操作一定在lfence完成（并未规定全局可见性）； sfence，是一种save Barrior 写屏障，会将store buffer中缓存的修改刷入L1 Cache中，使得其他cpu核可以观察到这些变化，而且之后的写操作不会被调度到之前，即sfence之前的写操作一定在sfence完成且全局可见 mfence，是一种全能型屏障，具备lfence和sfence的能力，同时刷新store buffer和invalidate queue，保证了mfence前后的读写操作的顺序，同时要求mfence之后写操作结果全局可见之前，mfence之前写操作全局可见 cpu屏障也包含指令lock前缀，lock不是一种内存屏障，但是它能完成类似内存屏障的功能。lock会对cpu总线和高速缓存加锁，可以理解为cpu指令级的一种锁。会让指令操作原子化，而且自带mfence效果。 &nbsp;&nbsp;&nbsp;&nbsp;X86-64一般情况根本不会需要使用lfence与sfence这两个指令，除非操作Write-Through内存或使用 non-temporal 指令（NT指令，属于SSE指令集），比如movntdq, movnti, maskmovq，这些指令也使用Write-Through内存策略，通常使用在图形学或视频处理，Linux编程里就需要使用GNC提供的专门的函数，下面是GNU中的三种内存屏障定义方法，下面是结合编译器屏障和CPU指令屏障。 123#define lfence() __asm__ __volatile__(&quot;lfence&quot;: : :&quot;memory&quot;) #define sfence() __asm__ __volatile__(&quot;sfence&quot;: : :&quot;memory&quot;) #define mfence() __asm__ __volatile__(&quot;mfence&quot;: : :&quot;memory&quot;) &nbsp;&nbsp;&nbsp;&nbsp;代码中仍然使用lfence()与sfence()这两个内存屏障应该也是一种长远的考虑。按照Interface写代码是最保险的，万一Intel以后出一个采用弱一致模型的CPU，遗留代码出问题就不好了。目前在X86下面视为编译器屏障即可。 12345# java通过魔术类来加内存屏障private static final Unsafe unsafe = Unsafe.getUnsafe();unsafe.loadFence();unsafe.storeFence();unsafe.fullFence(); 下面这里有一个典型的使用内存屏障的例子（DCL） 1234567891011private static A a= null; public static A getInstance()&#123; if(a == null)&#123; synchronized (双重检查锁.class)&#123; a = new A(); // 多线程可能会出现问题的地方 &#125; &#125; return a; &#125; 为什么在多线程的场景下a = new A();会出现问题？其实这里不是原子操作，有分为下面三步； 分配对象内存空间 memory = allocate(); 初始化对象 instance(memory); 设置instance的对象指向刚分配的内存空间instance = memory; 由于第二步和第三步没有依赖关系，是可以重排的。重排后再单线程结果是没有改变的，所有这种重排是可以允许的。指令重排只会保证串行语义的执行的一致性(单线程)，但并不会关心多线程间的语义一致性。所以当一个线程访问instance对象不为null时，虽然是不为空的，但是执行方法时就会报错，对象没有实例化完成。解决重排通过加上volatile就可以解决。 volatile内存语义的实现编译器制定的volatile重排序规则表 第二个操作：普通读写 第二个操作：volatile读 第二个操作：volatile写 第一个操作：普通读写 可以 可以 不可以 第一个操作：volatile读 不可以 不可以 不可以 第一个操作：volatile写 可以 不可以 不可以 其中第一个操作：volatile读，都不可以重排 其中第二个操作：volatile写，都不可以重排 其中第一个操作：volatile写，第二个操作：volatile读，都不可以重排 &nbsp;&nbsp;&nbsp;&nbsp;为了实现volatile的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。对于编译器来说，发现一个最优布置来最小化插入屏障的总数几乎不可能。为此，JMM采取保守策略。下面是基于保守策略的JMM内存屏障插入策 略。 在每个volatile写操作的前面插入一个StoreStore屏障。 在每个volatile写操作的后面插入一个StoreLoad屏障。 在每个volatile读操作的后面插入一个LoadLoad屏障 在每个volatile读操作的后面插入一个LoadStore屏障 这里举一个来说明 1234567891011int a; volatile int v1 = 1; volatile int v2 = 2; void readAndWrite()&#123; int i = v1; // 第一个volatile读 int j = v2; // 第二个volatile读 a = i+j; // 普通写 v1 = i + 1; // 第一个volatile写 v2 = j * 2; // 第二个volatile写 &#125; 针对readAndWrite方法，编译器在字节码会做如下的优化，见下面的解释就可以会很清楚了。","categories":[{"name":"并发","slug":"并发","permalink":"http://example.com/categories/%E5%B9%B6%E5%8F%91/"}],"tags":[{"name":"并发","slug":"并发","permalink":"http://example.com/tags/%E5%B9%B6%E5%8F%91/"}],"author":"jianghe"},{"title":"操作系统的底层认识","slug":"操作系统的底层认识","date":"2021-04-20T04:31:00.000Z","updated":"2021-07-06T15:00:15.390Z","comments":true,"path":"2021/04/20/操作系统的底层认识/","link":"","permalink":"http://example.com/2021/04/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%BA%95%E5%B1%82%E8%AE%A4%E8%AF%86/","excerpt":"","text":"冯诺依曼计算机模型&nbsp;&nbsp;&nbsp;&nbsp;现在计算机模型都是基于-冯诺依曼计算机模型&nbsp;&nbsp;&nbsp;&nbsp;计算机在运行时，先从内存中取出第一条指令，通过控制器的译码，按指令的要求，从存储器中取出数据进行指定的运算和逻辑操作等加工，然后再按地址把结果送到内存中。接下来，再取出第二条指令，在控制器的指挥下完成规定操作，依次进行下去。直至遇到停止指令。&nbsp;&nbsp;&nbsp;&nbsp;程序与数据一样存储，按程序编排的顺序，一步一步的取出指令，自动完成指令规定的操作是计算机最基本的工作模型。这个就是冯.诺依曼计算机模型。 计算机五大核心组成部分 控制器(control)：是整个计算机的中枢神经，其功能是对程序规定的控制信息进行解释，根据其要求进行控制，调度程序、数据、地址，协调计算机各部分工作及内存与外设的访问等。 运算器(Datapath)：对数据进行各种算数运算和逻辑运算，即对数据进行加工 存储器(Memory)：存储器的功能是存储程序、数据和各种信号、命令等信息，并在需要时提供这些信息。 输入(Input system)：输入设备是计算机的重要组成部分，输入设备与输出设备合你 为外部设备，简称外设，输入设备的作用是将程序、原始数据、文字、字符、控制命令或现 场采集的数据等信息输入到计算机。常见的输入设备有键盘、鼠标器、光电输入机、磁带 机、磁盘机、光盘机等。 输出(Output system)：输出设备与输入设备同样是计算机的重要组成部分，它把外 算机的中间结果或最后结果、机内的各种数据符号及文字或各种控制信号等信息输出出来。 微机常用的输出设备有显示终端CRT、打印机、激光印字机、绘图仪及磁带、光盘机等。 现代计算机模型&nbsp;&nbsp;&nbsp;&nbsp;现在的计算机就是通过冯诺依曼计算机模型来应用出来的，见下图。其中我们最主要是关心CPU和内存。 cpu指令结构cpu内部结构 控制单元 控制单元是整个CPU的指挥控制中心，由指令寄存器IR（Instruction Register）、指 令译码器ID（Instruction Decoder）和 操作控制器OC（Operation Controller） 等组 成，对协调整个电脑有序工作极为重要。它根据用户预先编好的程序，依次从存储器中取出 各条指令，放在指令寄存器IR中，通过指令译码（分析）确定应该进行什么操作，然后通过 操作控制器OC，按确定的时序，向相应的部件发出微操作控制信号。操作控制器OC中主要 包括：节拍脉冲发生器、控制矩阵、时钟脉冲发生器、复位电路和启停电路等控制逻辑。 运算单元 运算单元是运算器的核心。可以执行算术运算（包括加减乘数等基本运算及其附加运 算）和逻辑运算（包括移位、逻辑测试或两个值比较）。相对控制单元而言，运算器接受控 制单元的命令而进行动作，即运算单元所进行的全部操作都是由控制单元发出的控制信号来 指挥的，所以它是执行部件。 数据单元 存储单元包括 CPU 片内缓存Cache和寄存器组，是 CPU 中暂时存放数据的地方，里 面保存着那些等待处理的数据，或已经处理过的数据，CPU 访问寄存器所用的时间要比访 问内存的时间短。 寄存器是CPU内部的元件，寄存器拥有非常高的读写速度，所以在寄存 器之间的数据传送非常快。采用寄存器，可以减少 CPU 访问内存的次数，从而提高了 CPU 的工作速度。寄存器组可分为专用寄存器和通用寄存器。专用寄存器的作用是固定的，分别 寄存相应的数据；而通用寄存器用途广泛并可由程序员规定其用途。 CPU缓存结构现在CPU为了提升执行效率，减少cpu与内存的交互，一般在CPU设置多级缓存 L1 cache，分为指令缓存和数据缓存，逻辑核独占 L2 cache，物理核独占，逻辑核共享 L3 cache，所有物理核共享 物理核：可以看的到的，真实的cpu核逻辑核：在同一个物理核内，逻辑层面的核。超线程：超线程可以在一个逻辑核等待指令执行的间隔(等待从cache或内存中获取下一条指令)，把时间片分配到另一个逻辑核。高速在这两个逻辑核之间切换，让应用程序感知不到这个间隔，误认为自己是独占了一个核。一个CPU有多个物理核，如果开启了超线程，一个物理核可以分成n个逻辑核，n为超线程的数量。其中一台机器可以有多个CPU，但是CPU之前的缓存是不共享的Runtime.getRuntime().availableProcessors()是逻辑核数 存储器的大小：内存&gt;L3&gt;L2&gt;L1&gt;寄存器 存储器速度快慢排序：寄存器&gt;L1&gt;L2&gt;L3&gt;内存 缓存最小的存储单位是-缓存行(cache line)，缓存大小默认64Byte，如果对象大小大于64Byte，可以采用多个缓存行存储 CPU读取存储器数据的过程123451. CPU要取寄存器X的值，直接读取寄存器2. CPU要取L1 cache的某个值，把cacheline锁住，把数据拿来，解锁。没有锁住就慢了3. CPU要取L2 cache的某个值，L2开始加锁，加锁以后把数据复制到L1，执行上面的L1的步骤，再解锁4. CPU要取L3 cache的某个值，L3复制到L2，L2复制到L1，L1复制寄存器5. CPU要取内存中的数据，通知内存控制器占用总线带宽，通知内存加锁，发起内存读请求，等待回应，回应数据保存，复制到L3，然后复制到L2，然后复制到L1，最后复制到寄存器，之后解除总线锁定 CPU为何有一个高速缓存CPU在摩尔定律指导下，每18个月翻一番的速度，而内存和硬盘速度远不及CPU速度。为了解决这个问题，CPU中内置了少量的高速缓存以解决I/o速度和CPU运算速度之间的不匹配问题。在CPU访问存储设备时，无论是存储数据或者指令，都趋于一片连续的区域中，这就叫做局部性原则 123时间局部性：如果一个信息正在被访问，那么近期它很有可能还会被访问。比如循环、递归、方法的反复调用等。空间局部性：如果一个存储器的位置被引用，那么将来它附近的位置也会被引用。比如顺序执行的代码、连续创建的两个对象、数组等。 空间局部性的例子 123456789101112131415161718192021222324252627282930313233343536373839404142# first 比 second方式快一点，是因为再引用数组位置时，它附近的位置也引用了，导致会快一点private static final int RUNS = 100; private final static int rows = 1024 * 1024; private final static int cols = 6; private static Long[][] data = new Long[rows][cols]; public static void main(String[] args) &#123; for (int i = 0; i &lt; rows; i++) &#123; for (int j = 0; j &lt; cols; j++) &#123; data[i][j] = 1L; &#125; &#125; System.out.println(&quot;first&quot;); long first = System.currentTimeMillis(); Long firstNum = 0L; for (int r = 0; r &lt; RUNS; r++) &#123; for (int i = 0; i &lt; rows; i++) &#123; for (int j = 0; j &lt; cols; j++) &#123; firstNum += data[i][j]; &#125; &#125; &#125; System.out.println(&quot;firstNum=&quot;+firstNum); System.out.println(&quot;first =&quot;+(System.currentTimeMillis()-first)); //2700 System.out.println(&quot;second&quot;); long second = System.currentTimeMillis(); Long secondNum = 0L; for (int r = 0; r &lt; RUNS; r++) &#123; for (int i = 0; i &lt; cols; i++) &#123; for (int j = 0; j &lt; rows; j++) &#123; secondNum += data[j][i]; &#125; &#125; &#125; System.out.println(&quot;secondNum=&quot;+secondNum); System.out.println(&quot;second =&quot;+(System.currentTimeMillis()-second)); // 3249 &#125; CPU运行安全等级 ring0 操作系统内部的指令 rong1 没有使用 rong2 没有使用 rong3 用户程序的指令 JVM创建线程，线程阻塞唤醒是重型操作了，因为CPU要切换运行状态 例子：JVM创建线程CPU的过程 CPU从ring3切换到ring0，创建线程，调用p_thread库 线程创建完成后，CPU从ring0切换到ring3 执行java程序 CPU从ring3切换到ring0，销毁 操作系统内存管理执行空间保护操作系统有用户空间与系统空间两个概念，目的也是为了做到程序运行安全隔离与稳定，以32位4G大小内存的空间来说。它的寻址地址为2^32个地址。 &nbsp;&nbsp;&nbsp;&nbsp;Linux为内核代码和数据结构预留了几个页框，这些页永远不会被转出到磁盘上。从0x00000000到0xC0000000（PAGE_OFFSET）的线性地址可由用户代码和内核代码进行引用（用户空间），从0xC0000000（PAGE_OFFSET）到0xFFFFFFFF的线性地址只能由内核代码进行访问（内核空间）。内核空间及其数据结构都必须位于在1GB的地址空间中，但是对于此地址空间而言，更大的消费者是物理地址虚拟映射。而3GB可以用于用户应用程序。&nbsp;&nbsp;&nbsp;&nbsp;进程与线程只能运行在用户模式（user mode）与内核模式(kernel mode)下。用户程序运行在用户模式下，而系统调用运行在内核模式下。这两种使用的堆栈是不一样的。用户方式下用的是 一般的堆栈(用户空间的堆栈)，而内核方式下用的是固定大小的堆栈（内核空间的堆栈，一般为一个内存页的大小），即每个进程与线程其实有两个堆栈，分别运行与用户态与内核态。 用户线程模型(ULT)用户程序实现，不依赖系统内核，应用提供创建、同步、调度和管理线程的函数来创建用户线程。不需要用户态/内核态切换，速度快。内核对ULT无感知，线程阻塞则进程（包括它所有的线程）阻塞。 内核线程模型(KLT)内核保存线程的状态和上下文信息，线程阻塞不会引起进程阻塞。在多处理器系统上，多线程在多处理器上并行运行。线程的创建、调度和管理由内核完成，效率比ULT慢，比进程效率快。 那JVM是什么线程模型呢？其实JVM是采用KLT。 进程和线程进程现代操作系统在运行一个程序时，会为其创造一个进程。进程是OS资源分配的最小单元。像启动一个java程序，计算机就会启动一个进程。 线程线程是OS调度CPU的最小单元。也叫做轻量级进程。在一个进程里可以有多个线程，这些线程都拥有各自的计数器、堆栈和局部变量表等属性。并且能够访问共享的内存变量。CPU在这些线程上高速切换，让使用者感觉到这些线程在同时执行，即并发的概念。 vmstat 1，其中cs就是上下文切换，上下文存放在TSS（Task State Segment） 虚拟机指令集架构虚拟机指令集架构主要分为两种： 栈指令集架构 寄存器指令集架构 栈指令集架构 设计和实现更简单,适用于资源受限的系统; 避开了寄存器的分配难题:使用零地址指令方式分配; 指令流中的指令大部分是零地址指令,其执行过程依赖与操作栈,指令集更小,编译器 容易实现; 不需要硬件支持,可移植性更好,更好实现跨平台。 寄存器指令集架构 典型的应用是x86的二进制指令集:比如传统的PC以及Android的Davlik虚拟机。 指令集架构则完全依赖硬件,可移植性差。 性能优秀和执行更高效。 花费更少的指令去完成一项操作。 在大部分情况下,基于寄存器架构的指令集往往都以一地址指令、二地址指令和三 地址指令为主,而基于栈式架构的指令集却是以零地址指令为主。 jvm是栈指令集架构，可移植性好","categories":[{"name":"并发","slug":"并发","permalink":"http://example.com/categories/%E5%B9%B6%E5%8F%91/"}],"tags":[{"name":"并发","slug":"并发","permalink":"http://example.com/tags/%E5%B9%B6%E5%8F%91/"}],"author":"jianghe"},{"title":"内存分配与垃圾回收","slug":"内存分配与垃圾回收","date":"2021-03-09T11:31:00.000Z","updated":"2021-07-06T15:00:15.393Z","comments":true,"path":"2021/03/09/内存分配与垃圾回收/","link":"","permalink":"http://example.com/2021/03/09/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/","excerpt":"","text":"jvm内存区域之所以会选中jvm的内存区域划分为多个不同的内存区，是因为每一个独立的内存区都拥有各自的用途。其中一部分的内存区域和jvm生命周期保持一致另外一部分的内存区域和线程的生命周期保持一致 线程共享内存区允许被所有线程共享访问的一类内存区，包括堆区、方法区和运行时常量池三个内存区。 堆区堆（heap）,Java堆区在JVM启动的时候被创建，并且它在实际的内存空间中可以是不连续的。堆（heap）区是一块用于存储对象实例的内存区，同时也是GC执行垃圾回收的重点区域，正式因为java堆区是GC重点回收区域，那么GC极有可能在大内存的使用和回收上成为性能瓶颈。 为了解决问题，考虑是否一定需要将对象实例存储到Java堆区中。其中逃逸分析与栈上分配等优化技术同样也是降低GC回收频率与提升GC回收效率的方式。 堆还分为新生代（YoungGen）和老年代（OldGen）,其中新生代也可以分为Eden空间、From Survivor空间和To Survivor空间。 -Xmx表示堆区最大内存-Xms表示堆区起始内存一旦堆中的内存大小大于最大内存，就会抛出OutOfMemoryError异常 方法区 jdk版本 方法区实现 运行时常量池位置 存储信息 &lt;1.6 PermGen space（永久代） PermGen space（永久代） 运行时常量池、变量、字段和方法数据、构造函数和普通方法的字节码内容、类和实例和接口初始化需要用到的特殊方法等数据 1.7 PermGen space（永久代） Heap（堆） Heap（堆） 1.8 Metaspace（元空间） Heap（堆） Heap（堆） 由于主流的jdk版本采用的是1.8版本，这里我们主要介绍jdk1.8版本方法区元空间（Metaspace），是方法区的一种实现，其中元空间是属于本地内存中的，之前的方法区的实现是存储在堆中。然后元空间存储类的元信息，而静态变量和常量池都并入堆中。 Jvm常量池Class文件常量池1234567891011121314class JavaBean&#123; private int value = 1; public String s = &quot;abc&quot;; public final static int f = 0x101; public void setValue(int v)&#123; final int temp = 3; this.value = temp + v; &#125; public int getValue()&#123; return value; &#125;&#125; 编写.java文件编译为.class文件格式的二进制数据存放在磁盘中 非运行时常量池，在编译阶段以及确定 Class文件常量池存放字面量和符号引用 字面量 第一种存储是文本字符串123#9 = Utf8 s#3 = String #31 // abc#31 = Utf8 abc 第二种存储用final修饰的成员变量，包括静态变量、实例变量和局部变量 123#11 = Utf8 f#12 = Utf8 ConstantValue#13 = Integer 257 这里说明下，存在常量池的字面量，指的是数据的值，也就是abc和0x101(257)，通过对常量池的观察可知这两个字面量是确实存在于常量池的。而对于基本数据类型，也就是上面的private int value = 1，常量池只保留他的字段描述符I(1反编译出来的结果)和字段的名称value，他们的字面量不会存在于常量池中 符号引用 类和接口的全限定名，也就是Ljava/lang/String;这样，主要用于在运行时解析得到类的直接引用 字段的名称和描述符，字段也就是类或者接口中声明的变量，包括类级别变量（static）和实例级的变量 方法的名称和修饰符，也就是参数类型+返回值类型 运行时常量池运行时常量池是方法区的一部分，所以也是全局共享的。jvm在执行过程中，需要经过加载、连接(验证、准备、解析)、初始化，在第一步的加载，虚拟机需要做下面3件事 通过一个类的“全限定名”来获取此类的二进制字节流 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构 在内存中生成一个类代表这类的java.lang.Class对象，作为方法区这个类的各种数据访问的入口 这个Class对象和实例对象是不同的，类对象是在类加载的时候生成的，实例对象是调用new之后创建的上面第二条，将class字节流代表的静态存储结构转化为方法区的运行时数据结构，其中就包含class文件常量池进入运行时常量池的过程。不同的类公用一个运行时常量池，同时在进入运行时常量池的过程中，多个class文件中常量池中相同的字符串只会存在一份在运行时常量池中。 运行时常量池的作用是存储class文件常量池中的符号信息。运行时常量池中保存着一些class文件中描述的符号引用，同时在类加载的“解析阶段”还会将这些符号引用所翻译出来的直接引用(直接指向实例对象的指针)存储在运行时常量池中。 运行时常量池相对于class常量池一大特性就是其具有动态性，Java规范并不要求常量只能在运行时才产生，也就是说运行时常量池中的内容并不全部来自class文件常量池，class文件常量池并非运行时常量池的唯一数据输入口；在运行时可以通过代码生成常量并将其放入常量池中，这种特性被用的较多的是String.intern() 全局字符串常量池 不同于基本数据类型，String类型是一个final对象，他的字面量存在于class文件常量池中，但是运行期行为却与普通变量常量不同 jdk1.7中，字符串常量池和类引用被移动到Java堆中(与运行时常量池分离)，因此不同版本的String行为也有差异 12String s0 = &quot;hello&quot;;String s1 = new String(&quot;hello&quot;); 第一种的方式声明的字面量hello是在编译器就确定的，它会直接进入到class文件常量池中，当运行期间在全局字符串常量池中会保存它的一个引用，实际上最终还是要在堆中创建一个yellow对象 第二种方式使用new String()，也就是调用了String类的构造函数，我们知道new指令是创建一个类的实例对象并完成加载初始化，因此这个字符串对象是在运行期确定的，创建的字符串对象是在堆内存上 s0 == s1，返回是false，s0和s1都存在堆上，但是地址肯定不同 12345678910111213String s1 = &quot;Hello&quot;;String s2 = &quot;Hello&quot;;String s3 = &quot;Hel&quot; + &quot;lo&quot;;String s4 = &quot;Hel&quot; + new String(&quot;lo&quot;);String s5 = new String(&quot;Hello&quot;);String s7 = &quot;H&quot;;String s8 = &quot;ello&quot;;String s9 = s7 + s8;System.out.println(s1 == s2); // trueSystem.out.println(s1 == s3); // trueSystem.out.println(s1 == s4); // falseSystem.out.println(s1 == s9); // false s1 == s2 这个就很好理解了，因为字面量Hello在运行期间会进入到全局字符串常量池，同一份字面量只会保留一份，所有引用都指向这一份字符串，自然引用的地址也就相同了 s1 == s3 编译优化，编译器会直接在Class文件常量池存的是Hello，跟第一种是一样的 s1 != s4 new String(&quot;lo&quot;)在堆中创建一个String对象，而Hel字面量是通过另一种操作在堆中创建对象，这两个在堆中不同的地方创建的对象是通过StringBuilder.append方法拼接出来的，并且最终会调用StringBuilder.toString方法输出，最终拼出来的String对象，地址肯定是不一样的 12345@Overridepublic String toString() &#123; // Create a copy, don&#x27;t share the array return new String(value, 0, count);&#125; s1 != s9 字面量会存在Hello、H、ello，运行期间会创建H和ello对象，通过StringBuilder.append方法拼接出来的，最终还是会重新生成String对象，地址肯定是不一样的。 字符串常量池的概率：字符串常量池是Jvm所维护的一个字符串实例的引用表，在Hotspot vm中，他是一个叫做String Table的全局表。在字符串常量池中维护的是字符串实例的引用，底层C++实现就是一个HashTable。这些被维护的引用所指的字符串实例，被称为”被驻留的字符串“或”interned String“或通常所说的”进入了字符串常量池的字符串“。运行时常量池在方法区(Non-heap)，而JDK1.7后，字符串常量池被移到了heap区，因此两者根本就不是一个概念 基本类型包装类对象常量池java中基本类型的包装类的大部分都实现了常量池技术，这些类是Byte、Short、Integer、Long、Character、Boolean，另外两种浮点数没有实现。另外上面这5种整型的包装类也只是在对应值小于等于127时才可使用对象池，也即对象不负责创建和管理大于127的这些类的对象。其中会包含自动拆箱和自动装箱。 线程私有内存区和线程共享内存区不同，线程私有内存区是不允许被所有线程共享访问的。线程私有内存区是只允许被所属的独立线程进行访问的一类内存区，包括PC寄存器、Java栈和本地方法栈。 PC寄存器由于JVM是基于栈的架构，任何的操作都需要入栈和出栈来完成，其中PC寄存器并不是物理寄存器，实际上是PC计数器。以下是特性 PC寄存器用来存储下一条指令的地址 每个线程都会有一个PC寄存器，线程私有的，生命周期和线程的生命周期保持一致。 任何时间一个线程都只有一个方法在执行，如果当前线程所执行的方法是一个Java方法，那么PC寄存器就会存储正在执行的字节码指令地址；如果当前线程所执行的方法是一个native方法，那么pc寄存器的值就是空(undefined)。 它是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError的区域 Java栈Java栈也称Java虚拟机栈，是线程私有的。Java栈存储栈帧(Stack Frame)栈帧 局部变量表 存储各类原始数据类型、对象引用(reference)、returnAddress类型 returnAddress类型被定义为Java虚拟机内部的原始数据类型，该类型用于表示一条字节码指令的操作码(opcode)。 操作数栈 动态链接 方法出口 Java 栈允许被实现成固定大小的内存或者可动态扩展的内存大小如果超过固定大小的内存就会抛出StackOverflowError错误如果超过可动态扩展的内存就会抛出OutOfMemoryError错误 本地方法栈Native Method Stack，用于支持本地方法执行（native方法，比如c/c++代码） 自动内存管理程序内存管理是一个非常敏感的话题，对于c/c++而言，可以再语法层面上随意控制程序中一个对象的生命周期，随意创建一个对象，也能随意杀死一个对象，这种方式称之为手动内存管理。手动内存管理是一把双刃剑，不好的地方会影响内存泄漏和内存溢出 内存泄漏 比较一个常见的场景，就是释放一个链表所引用的所有空间时，却错误地释放链表的第一个元素，尽管剩下的元素不被引用，但是他们却离开了整个程序的控制范围。这样一来，链表中的元素所占用的内存空间永远不会被释放 内存泄漏不会立马引起程序崩溃，慢慢在消耗内存，然后会瓦解 内存溢出 当使用的对象超出内存限制，一直无法释放时，就会产生内存溢出 但是Jvm是使用的自动内存管理机制，这样会降低内存泄漏和内存溢出的风险，但是这样会影响到一旦出现问题后，不太容易定位问题，还是需要了解jvm如何管理内容 内存分配原理Jvm包含三种引用类型，分别是类类型(class type)，数组类型(array type)和接口类型（interface type），这些引用类型的值则是由类实例、数组实例以及实现了某个接口的派生类实例负责动态创建，那么jvm中究竟是如何为这些类型创建对应的对象实例呢？ 语法层面使用new关键字创建一个Java对象 new 指令的参数能否在常量池中定位到一个类的符号引用 检查这个符号引用想对应的类是否已经成功经历过加载、解析和初始化 当类完成装载步骤之后，就已经完全可以确定出创建对象实例所需要的内存大小 jvm就会将其进行内存分配，以存储生成的对象实例 为新对象分配内存是一件非常严谨和复杂的任务，需要考虑下面三个问题 内存如何分配？ 如果内存空间以规整和有序的方式分布，即已有和未用的内存都各自一边，彼此之间维系着一个记录下一次分配起始点的标记指针，当为新对象分配内存时，只需要通过修改指针的偏移量将新对象分配在第一个空闲内存位置上。这种分配叫做指针碰撞（Bump the Pointer），否则只能使用空闲列表（Free List）执行内存分配。 分配到哪里？ Java堆区分为新生代（Young Gen）和老年代（Old Gen），其中新生代分为Eden、From Survivor、To Survivor，由于对象的创建在Jvm中非常频繁，因此在并发情况下从堆区中划分内存空间是非线程安全的，所以务必需要保证数据操作的原子性。基于线程安全的考虑，如果一个类在分配内存之前已经成功完成类装载步骤之后，Jvm优先选在在TLAB（Thread Local Allocation Buffer，本地线程分配缓冲区）中为对象实例分配内存空间。 TLAB在Java堆区中是一块线程私有区域，它包含在Eden空间中，除了可以避免一系列的非线程安全问题外，同时还能够提升内存分配的吞吐量，因此这种内存分配方式为快速分配策略 不是所有的对象实例都在TLAB成功分配，但Jvm确实是将TLAB作为内存分配的首选，在程序中，开发人员可以将-XX:UseTLAB是否开启TLAB空间。 默认情况下，TLAB占Eden中的1%，可以手动调整-XX:TLABWasteTargetPercent设置TLAB站Eden空间的百分比大小。 一旦对象在TLAB空间分配内存失败时，Jvm就会尝试着通过使用加锁机制确保数据操作的原子性，从而直接在Eden空间中分配内存，如果Eden空间中也无法分配内存时，Jvm就会执行Mirror GC，直至最终可以在Eden空间分配内存为止。（如果是大对象直接在老年代中分配） 内存回收？","categories":[{"name":"jvm","slug":"jvm","permalink":"http://example.com/categories/jvm/"}],"tags":[{"name":"jvm","slug":"jvm","permalink":"http://example.com/tags/jvm/"}],"author":"jianghe"},{"title":"jvm初始化启动","slug":"jvm初始化","date":"2021-03-02T03:21:00.000Z","updated":"2021-07-06T15:00:15.403Z","comments":true,"path":"2021/03/02/jvm初始化/","link":"","permalink":"http://example.com/2021/03/02/jvm%E5%88%9D%E5%A7%8B%E5%8C%96/","excerpt":"","text":"Launcher简介Launcher是一种用于启动jvm进程的启动器，关于Launcher的具体使用方式和标准选项配置，输入命令“java -help”，见下。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051Usage: java [-options] class [args...] (to execute a class) or java [-options] -jar jarfile [args...] (to execute a jar file)where options include: -d32 use a 32-bit data model if available -d64 use a 64-bit data model if available -server to select the &quot;server&quot; VM The default VM is server, because you are running on a server-class machine. -cp &lt;class search path of directories and zip/jar files&gt; -classpath &lt;class search path of directories and zip/jar files&gt; A : separated list of directories, JAR archives, and ZIP archives to search for class files. -D&lt;name&gt;=&lt;value&gt; set a system property -verbose:[class|gc|jni] enable verbose output -version print product version and exit -version:&lt;value&gt; Warning: this feature is deprecated and will be removed in a future release. require the specified version to run -showversion print product version and continue -jre-restrict-search | -no-jre-restrict-search Warning: this feature is deprecated and will be removed in a future release. include/exclude user private JREs in the version search -? -help print this help message -X print help on non-standard options -ea[:&lt;packagename&gt;...|:&lt;classname&gt;] -enableassertions[:&lt;packagename&gt;...|:&lt;classname&gt;] enable assertions with specified granularity -da[:&lt;packagename&gt;...|:&lt;classname&gt;] -disableassertions[:&lt;packagename&gt;...|:&lt;classname&gt;] disable assertions with specified granularity -esa | -enablesystemassertions enable system assertions -dsa | -disablesystemassertions disable system assertions -agentlib:&lt;libname&gt;[=&lt;options&gt;] load native agent library &lt;libname&gt;, e.g. -agentlib:hprof see also, -agentlib:jdwp=help and -agentlib:hprof=help -agentpath:&lt;pathname&gt;[=&lt;options&gt;] load native agent library by full pathname -javaagent:&lt;jarpath&gt;[=&lt;options&gt;] load Java programming language agent, see java.lang.instrument -splash:&lt;imagepath&gt; show splash screen with specified image 这里一定要注意，Launcher不是虚拟机实现，从严格意义上讲，Launcher只是一个封装了虚拟机的执行外壳。由它负责装载jre环境和windows平台下的jvm.dll动态链接库（linux平台下则是装载libjvm.so）,它必须调用虚拟机中的函数来完毕运行java程序的功能。所以，你在Hotspot的源码找不到启动程序的main函数。openjdk7是有一个启动器的，在openjdk/hotspot/src/share/tools/layncher/java.c中main函数openjdk8后，启动器在openjdk/jdk/src/share/bin/main.c中 HotSpot源码目录结构123456789101112131415161718192021222324252627282930313233343536373839├─agent Serviceability Agent的客户端实现├─make 用来build出HotSpot的各种配置文件├─src HotSpot VM的源代码│ ├─cpu CPU相关代码（汇编器、模板解释器、ad文件、部分runtime函数在这里实现）│ ├─os 操作系相关代码│ ├─os_cpu 操作系统+CPU的组合相关的代码│ └─share 平台无关的共通代码│ ├─tools 工具│ │ ├─hsdis 反汇编插件│ │ ├─IdealGraphVisualizer 将server编译器的中间代码可视化的工具│ │ ├─launcher openjdk1.7之前存在launcher目录，这里存放启动程序“java”│ │ ├─LogCompilation 将-XX:+LogCompilation输出的日志（hotspot.log）整理成更容易阅读的格式的工具│ │ └─ProjectCreator 生成Visual Studio的project文件的工具│ └─vm HotSpot VM的核心代码│ ├─adlc 平台描述文件（上面的cpu或os_cpu里的*.ad文件）的编译器│ ├─asm 汇编器接口│ ├─c1 client编译器（又称“C1”）│ ├─ci 动态编译器的公共服务/从动态编译器到VM的接口│ ├─classfile 类文件的处理（包括类加载和系统符号表等）│ ├─code 动态生成的代码的管理│ ├─compiler 从VM调用动态编译器的接口│ ├─gc_implementation GC的实现│ │ ├─concurrentMarkSweep Concurrent Mark Sweep GC的实现│ │ ├─g1 Garbage-First GC的实现（不使用老的分代式GC框架）│ │ ├─parallelScavenge ParallelScavenge GC的实现（server VM默认，不使用老的分代式GC框架）│ │ ├─parNew ParNew GC的实现│ │ └─shared GC的共通实现│ ├─gc_interface GC的接口│ ├─interpreter 解释器，包括“模板解释器”（官方版在用）和“C++解释器”（官方版不在用）│ ├─libadt 一些抽象数据结构│ ├─memory 内存管理相关（老的分代式GC框架也在这里）│ ├─oops HotSpot VM的对象系统的实现│ ├─opto server编译器（又称“C2”或“Opto”）│ ├─prims HotSpot VM的对外接口，包括部分标准库的native部分和JVMTI实现│ ├─runtime 运行时支持库（包括线程管理、编译器调度、锁、反射等）│ ├─services 主要是用来支持JMX之类的管理功能的接口│ ├─shark 基于LLVM的JIT编译器（官方版里没有使用）│ └─utilities 一些基本的工具类└─test 单元测试 使用Launcher启动jvm调用栈 12345678910openjdk/jdk/src/share/bin/main.c::WinMain/main openjdk/jdk/src/share/bin/java.c::JLI_Launch openjdk/jdk/src/solaris/bin/java_md_solinux.c::LoadJavaVM # Load JVM Library: libjvm.so openjdk/jdk/src/solaris/bin/java_md_solinux.c::JVMInit # Create JVM openjdk/jdk/src/share/bin/java.c::ContinueInNewThread openjdk/jdk/src/solaris/bin/java_md_solinux.c::ContinueInNewThread0(JavaMain, threadStackSize, (void*)&amp;args); pthread_create(&amp;tid, &amp;attr, (void *(*)(void*))continuation, (void*)args) openjdk/jdk/src/share/bin/java.c::JavaMain openjdk/jdk/src/share/bin/java.c::InitializeJVM openjdk\\hotspot\\src\\share\\vm\\prims\\jni.cpp::JNI_CreateJavaVM 调用过程 main函数启动函数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455int WINAPIWinMain(HINSTANCE inst, HINSTANCE previnst, LPSTR cmdline, int cmdshow)&#123; int margc; char** margv; const jboolean const_javaw = JNI_TRUE; __initenv = _environ;#else /* JAVAW */intmain(int argc, char **argv)&#123; int margc; char** margv; const jboolean const_javaw = JNI_FALSE;#endif /* JAVAW */#ifdef _WIN32 &#123; int i = 0; if (getenv(JLDEBUG_ENV_ENTRY) != NULL) &#123; printf(&quot;Windows original main args:\\n&quot;); for (i = 0 ; i &lt; __argc ; i++) &#123; printf(&quot;wwwd_args[%d] = %s\\n&quot;, i, __argv[i]); &#125; &#125; &#125; JLI_CmdToArgs(GetCommandLine()); margc = JLI_GetStdArgc(); // add one more to mark the end margv = (char **)JLI_MemAlloc((margc + 1) * (sizeof(char *))); &#123; int i = 0; StdArg *stdargs = JLI_GetStdArgs(); for (i = 0 ; i &lt; margc ; i++) &#123; margv[i] = stdargs[i].arg; &#125; margv[i] = NULL; &#125;#else /* *NIXES */ margc = argc; margv = argv;#endif /* WIN32 */ # 调用launcher return JLI_Launch(margc, margv, sizeof(const_jargs) / sizeof(char *), const_jargs, sizeof(const_appclasspath) / sizeof(char *), const_appclasspath, FULL_VERSION, DOT_VERSION, (const_progname != NULL) ? const_progname : *margv, (const_launcher != NULL) ? const_launcher : *margv, (const_jargs != NULL) ? JNI_TRUE : JNI_FALSE, const_cpwildcard, const_javaw, const_ergo_class);&#125; JLI_Launch创建运行环境 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133/* * Entry point. */intJLI_Launch(int argc, char ** argv, /* main argc, argc */ int jargc, const char** jargv, /* java args */ int appclassc, const char** appclassv, /* app classpath */ const char* fullversion, /* full version defined */ const char* dotversion, /* dot version defined */ const char* pname, /* program name */ const char* lname, /* launcher name */ jboolean javaargs, /* JAVA_ARGS */ jboolean cpwildcard, /* classpath wildcard*/ jboolean javaw, /* windows-only javaw */ jint ergo /* ergonomics class policy */)&#123; int mode = LM_UNKNOWN; char *what = NULL; char *cpath = 0; char *main_class = NULL; int ret; InvocationFunctions ifn; jlong start, end; char jvmpath[MAXPATHLEN]; char jrepath[MAXPATHLEN]; char jvmcfg[MAXPATHLEN]; _fVersion = fullversion; _dVersion = dotversion; _launcher_name = lname; _program_name = pname; _is_java_args = javaargs; _wc_enabled = cpwildcard; _ergo_policy = ergo; InitLauncher(javaw); DumpState(); if (JLI_IsTraceLauncher()) &#123; int i; printf(&quot;Command line args:\\n&quot;); for (i = 0; i &lt; argc ; i++) &#123; printf(&quot;argv[%d] = %s\\n&quot;, i, argv[i]); &#125; AddOption(&quot;-Dsun.java.launcher.diag=true&quot;, NULL); &#125; /* * Make sure the specified version of the JRE is running. * * There are three things to note about the SelectVersion() routine: * 1) If the version running isn&#x27;t correct, this routine doesn&#x27;t * return (either the correct version has been exec&#x27;d or an error * was issued). * 2) Argc and Argv in this scope are *not* altered by this routine. * It is the responsibility of subsequent code to ignore the * arguments handled by this routine. * 3) As a side-effect, the variable &quot;main_class&quot; is guaranteed to * be set (if it should ever be set). This isn&#x27;t exactly the * poster child for structured programming, but it is a small * price to pay for not processing a jar file operand twice. * (Note: This side effect has been disabled. See comment on * bugid 5030265 below.) */ SelectVersion(argc, argv, &amp;main_class); CreateExecutionEnvironment(&amp;argc, &amp;argv, jrepath, sizeof(jrepath), jvmpath, sizeof(jvmpath), jvmcfg, sizeof(jvmcfg)); ifn.CreateJavaVM = 0; ifn.GetDefaultJavaVMInitArgs = 0; if (JLI_IsTraceLauncher()) &#123; start = CounterGet(); &#125; # 加载虚拟机动态链接库，并初始化ifn的函数指针 if (!LoadJavaVM(jvmpath, &amp;ifn)) &#123; return(6); &#125; if (JLI_IsTraceLauncher()) &#123; end = CounterGet(); &#125; JLI_TraceLauncher(&quot;%ld micro seconds to LoadJavaVM\\n&quot;, (long)(jint)Counter2Micros(end-start)); ++argv; --argc; if (IsJavaArgs()) &#123; /* Preprocess wrapper arguments */ TranslateApplicationArgs(jargc, jargv, &amp;argc, &amp;argv); if (!AddApplicationOptions(appclassc, appclassv)) &#123; return(1); &#125; &#125; else &#123; /* Set default CLASSPATH */ cpath = getenv(&quot;CLASSPATH&quot;); if (cpath == NULL) &#123; cpath = &quot;.&quot;; &#125; SetClassPath(cpath); &#125; /* Parse command line options; if the return value of * ParseArguments is false, the program should exit. */ if (!ParseArguments(&amp;argc, &amp;argv, &amp;mode, &amp;what, &amp;ret, jrepath)) &#123; return(ret); &#125; /* Override class path if -jar flag was specified */ if (mode == LM_JAR) &#123; SetClassPath(what); /* Override class path */ &#125; /* set the -Dsun.java.command pseudo property */ SetJavaCommandLineProp(what, argc, argv); /* Set the -Dsun.java.launcher pseudo property */ SetJavaLauncherProp(); /* set the -Dsun.java.launcher.* platform properties */ SetJavaLauncherPlatformProps(); return JVMInit(&amp;ifn, threadStackSize, argc, argv, mode, what, ret);&#125; 那对应的LoadJavaVM是什么?见下面代码其中设置ifn函数的属性 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182jbooleanLoadJavaVM(const char *jvmpath, InvocationFunctions *ifn)&#123; void *libjvm; JLI_TraceLauncher(&quot;JVM path is %s\\n&quot;, jvmpath); libjvm = dlopen(jvmpath, RTLD_NOW + RTLD_GLOBAL); if (libjvm == NULL) &#123;#if defined(__solaris__) &amp;&amp; defined(__sparc) &amp;&amp; !defined(_LP64) /* i.e. 32-bit sparc */ FILE * fp; Elf32_Ehdr elf_head; int count; int location; fp = fopen(jvmpath, &quot;r&quot;); if (fp == NULL) &#123; JLI_ReportErrorMessage(DLL_ERROR2, jvmpath, dlerror()); return JNI_FALSE; &#125; /* read in elf header */ count = fread((void*)(&amp;elf_head), sizeof(Elf32_Ehdr), 1, fp); fclose(fp); if (count &lt; 1) &#123; JLI_ReportErrorMessage(DLL_ERROR2, jvmpath, dlerror()); return JNI_FALSE; &#125; /* * Check for running a server vm (compiled with -xarch=v8plus) * on a stock v8 processor. In this case, the machine type in * the elf header would not be included the architecture list * provided by the isalist command, which is turn is gotten from * sysinfo. This case cannot occur on 64-bit hardware and thus * does not have to be checked for in binaries with an LP64 data * model. */ if (elf_head.e_machine == EM_SPARC32PLUS) &#123; char buf[257]; /* recommended buffer size from sysinfo man page */ long length; char* location; length = sysinfo(SI_ISALIST, buf, 257); if (length &gt; 0) &#123; location = JLI_StrStr(buf, &quot;sparcv8plus &quot;); if (location == NULL) &#123; JLI_ReportErrorMessage(JVM_ERROR3); return JNI_FALSE; &#125; &#125; &#125;#endif JLI_ReportErrorMessage(DLL_ERROR1, __LINE__); JLI_ReportErrorMessage(DLL_ERROR2, jvmpath, dlerror()); return JNI_FALSE; &#125;# 设置ifn函数引用 ifn-&gt;CreateJavaVM = (CreateJavaVM_t) dlsym(libjvm, &quot;JNI_CreateJavaVM&quot;); if (ifn-&gt;CreateJavaVM == NULL) &#123; JLI_ReportErrorMessage(DLL_ERROR2, jvmpath, dlerror()); return JNI_FALSE; &#125; ifn-&gt;GetDefaultJavaVMInitArgs = (GetDefaultJavaVMInitArgs_t) dlsym(libjvm, &quot;JNI_GetDefaultJavaVMInitArgs&quot;); if (ifn-&gt;GetDefaultJavaVMInitArgs == NULL) &#123; JLI_ReportErrorMessage(DLL_ERROR2, jvmpath, dlerror()); return JNI_FALSE; &#125; ifn-&gt;GetCreatedJavaVMs = (GetCreatedJavaVMs_t) dlsym(libjvm, &quot;JNI_GetCreatedJavaVMs&quot;); if (ifn-&gt;GetCreatedJavaVMs == NULL) &#123; JLI_ReportErrorMessage(DLL_ERROR2, jvmpath, dlerror()); return JNI_FALSE; &#125; return JNI_TRUE;&#125; 那对应JVMInit是什么？ 12345678intJVMInit(InvocationFunctions* ifn, jlong threadStackSize, int argc, char **argv, int mode, char *what, int ret)&#123; ShowSplashScreen(); return ContinueInNewThread(ifn, threadStackSize, argc, argv, mode, what, ret);&#125; ContinueInNewThread函数 调用ContinueInNewThread0函数 12345678910111213141516171819202122232425262728293031323334353637383940intContinueInNewThread(InvocationFunctions* ifn, jlong threadStackSize, int argc, char **argv, int mode, char *what, int ret)&#123; /* * If user doesn&#x27;t specify stack size, check if VM has a preference. * Note that HotSpot no longer supports JNI_VERSION_1_1 but it will * return its default stack size through the init args structure. */ if (threadStackSize == 0) &#123; struct JDK1_1InitArgs args1_1; memset((void*)&amp;args1_1, 0, sizeof(args1_1)); args1_1.version = JNI_VERSION_1_1; ifn-&gt;GetDefaultJavaVMInitArgs(&amp;args1_1); /* ignore return value */ if (args1_1.javaStackSize &gt; 0) &#123; threadStackSize = args1_1.javaStackSize; &#125; &#125; &#123; /* Create a new thread to create JVM and invoke main method */ JavaMainArgs args; int rslt; args.argc = argc; args.argv = argv; args.mode = mode; args.what = what; args.ifn = *ifn; rslt = ContinueInNewThread0(JavaMain, threadStackSize, (void*)&amp;args); /* If the caller has deemed there is an error we * simply return that, otherwise we return the value of * the callee */ return (ret != 0) ? ret : rslt; &#125;&#125; ContinueInNewThread0函数 创建一个新的线程，然后运行JavaMain函数。启动新的线程，Launcher就会阻塞原有线程，其中int (JNICALL *continuation)(void *)这个参数就是ContinueInNewThread参数中的JavaMain函数 123456789101112131415161718192021222324252627282930313233343536373839404142intContinueInNewThread0(int (JNICALL *continuation)(void *), jlong stack_size, void * args) &#123; int rslt;#ifdef __linux__ pthread_t tid; pthread_attr_t attr; pthread_attr_init(&amp;attr); pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_JOINABLE); if (stack_size &gt; 0) &#123; pthread_attr_setstacksize(&amp;attr, stack_size); &#125; if (pthread_create(&amp;tid, &amp;attr, (void *(*)(void*))continuation, (void*)args) == 0) &#123; void * tmp; pthread_join(tid, &amp;tmp); rslt = (int)tmp; &#125; else &#123; /* * Continue execution in current thread if for some reason (e.g. out of * memory/LWP) a new thread can&#x27;t be created. This will likely fail * later in continuation as JNI_CreateJavaVM needs to create quite a * few new threads, anyway, just give it a try.. */ rslt = continuation(args); &#125; pthread_attr_destroy(&amp;attr);#else /* ! __linux__ */ thread_t tid; long flags = 0; if (thr_create(NULL, stack_size, (void *(*)(void *))continuation, args, flags, &amp;tid) == 0) &#123; void * tmp; thr_join(tid, NULL, &amp;tmp); rslt = (int)tmp; &#125; else &#123; /* See above. Continue in current thread if thr_create() failed */ rslt = continuation(args); &#125;#endif /* __linux__ */ return rslt;&#125; JavaMain函数 InitializeJVM就是初始化java虚拟机，然后LoadMainClass加载主类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134int JNICALLJavaMain(void * _args)&#123; JavaMainArgs *args = (JavaMainArgs *)_args; int argc = args-&gt;argc; char **argv = args-&gt;argv; int mode = args-&gt;mode; char *what = args-&gt;what; InvocationFunctions ifn = args-&gt;ifn; JavaVM *vm = 0; JNIEnv *env = 0; jclass mainClass = NULL; jclass appClass = NULL; // actual application class being launched jmethodID mainID; jobjectArray mainArgs; int ret = 0; jlong start, end; RegisterThread(); /* Initialize the virtual machine */ start = CounterGet(); if (!InitializeJVM(&amp;vm, &amp;env, &amp;ifn)) &#123; JLI_ReportErrorMessage(JVM_ERROR1); exit(1); &#125; if (showSettings != NULL) &#123; ShowSettings(env, showSettings); CHECK_EXCEPTION_LEAVE(1); &#125; if (printVersion || showVersion) &#123; PrintJavaVersion(env, showVersion); CHECK_EXCEPTION_LEAVE(0); if (printVersion) &#123; LEAVE(); &#125; &#125; /* If the user specified neither a class name nor a JAR file */ if (printXUsage || printUsage || what == 0 || mode == LM_UNKNOWN) &#123; PrintUsage(env, printXUsage); CHECK_EXCEPTION_LEAVE(1); LEAVE(); &#125; FreeKnownVMs(); /* after last possible PrintUsage() */ if (JLI_IsTraceLauncher()) &#123; end = CounterGet(); JLI_TraceLauncher(&quot;%ld micro seconds to InitializeJVM\\n&quot;, (long)(jint)Counter2Micros(end-start)); &#125; /* At this stage, argc/argv have the application&#x27;s arguments */ if (JLI_IsTraceLauncher())&#123; int i; printf(&quot;%s is &#x27;%s&#x27;\\n&quot;, launchModeNames[mode], what); printf(&quot;App&#x27;s argc is %d\\n&quot;, argc); for (i=0; i &lt; argc; i++) &#123; printf(&quot; argv[%2d] = &#x27;%s&#x27;\\n&quot;, i, argv[i]); &#125; &#125; ret = 1; /* * Get the application&#x27;s main class. * * See bugid 5030265. The Main-Class name has already been parsed * from the manifest, but not parsed properly for UTF-8 support. * Hence the code here ignores the value previously extracted and * uses the pre-existing code to reextract the value. This is * possibly an end of release cycle expedient. However, it has * also been discovered that passing some character sets through * the environment has &quot;strange&quot; behavior on some variants of * Windows. Hence, maybe the manifest parsing code local to the * launcher should never be enhanced. * * Hence, future work should either: * 1) Correct the local parsing code and verify that the * Main-Class attribute gets properly passed through * all environments, * 2) Remove the vestages of maintaining main_class through * the environment (and remove these comments). * * This method also correctly handles launching existing JavaFX * applications that may or may not have a Main-Class manifest entry. */ mainClass = LoadMainClass(env, mode, what); CHECK_EXCEPTION_NULL_LEAVE(mainClass); /* * In some cases when launching an application that needs a helper, e.g., a * JavaFX application with no main method, the mainClass will not be the * applications own main class but rather a helper class. To keep things * consistent in the UI we need to track and report the application main class. */ appClass = GetApplicationClass(env); NULL_CHECK_RETURN_VALUE(appClass, -1); /* * PostJVMInit uses the class name as the application name for GUI purposes, * for example, on OSX this sets the application name in the menu bar for * both SWT and JavaFX. So we&#x27;ll pass the actual application class here * instead of mainClass as that may be a launcher or helper class instead * of the application class. */ PostJVMInit(env, appClass, vm); /* * The LoadMainClass not only loads the main class, it will also ensure * that the main method&#x27;s signature is correct, therefore further checking * is not required. The main method is invoked here so that extraneous java * stacks are not in the application stack trace. */ mainID = (*env)-&gt;GetStaticMethodID(env, mainClass, &quot;main&quot;, &quot;([Ljava/lang/String;)V&quot;); CHECK_EXCEPTION_NULL_LEAVE(mainID); /* Build platform specific argument array */ mainArgs = CreateApplicationArgs(env, argv, argc); CHECK_EXCEPTION_NULL_LEAVE(mainArgs); /* Invoke main method. */ (*env)-&gt;CallStaticVoidMethod(env, mainClass, mainID, mainArgs); /* * The launcher&#x27;s exit code (in the absence of calls to * System.exit) will be non-zero if main threw an exception. */ ret = (*env)-&gt;ExceptionOccurred(env) == NULL ? 0 : 1; LEAVE();&#125; CHECK_EXCEPTION_NULL_LEAVE() &amp; CHECK_EXCEPTION_LEAVE() &amp; LEAVE()其中这些方法会调用下面代码 逻辑是当java程序执行完，Launcher会调用DetachCurrentThread断开与主程序之间的连接。当成功断开与主程序之间的连接，Launcher就会等待程序中所有的非守护线程（non-daemon）全部执行结束，然后对jvm进行销毁，调用DestroyJavaVM 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/* * Always detach the main thread so that it appears to have ended when * the application&#x27;s main method exits. This will invoke the * uncaught exception handler machinery if main threw an * exception. An uncaught exception handler cannot change the * launcher&#x27;s return code except by calling System.exit. * * Wait for all non-daemon threads to end, then destroy the VM. * This will actually create a trivial new Java waiter thread * named &quot;DestroyJavaVM&quot;, but this will be seen as a different * thread from the one that executed main, even though they are * the same C thread. This allows mainThread.join() and * mainThread.isAlive() to work as expected. */#define LEAVE() \\ do &#123; \\ if ((*vm)-&gt;DetachCurrentThread(vm) != JNI_OK) &#123; \\ JLI_ReportErrorMessage(JVM_ERROR2); \\ ret = 1; \\ &#125; \\ if (JNI_TRUE) &#123; \\ (*vm)-&gt;DestroyJavaVM(vm); \\ return ret; \\ &#125; \\ &#125; while (JNI_FALSE)#define CHECK_EXCEPTION_NULL_LEAVE(CENL_exception) \\ do &#123; \\ if ((*env)-&gt;ExceptionOccurred(env)) &#123; \\ JLI_ReportExceptionDescription(env); \\ LEAVE(); \\ &#125; \\ if ((CENL_exception) == NULL) &#123; \\ JLI_ReportErrorMessage(JNI_ERROR); \\ LEAVE(); \\ &#125; \\ &#125; while (JNI_FALSE)#define CHECK_EXCEPTION_LEAVE(CEL_return_value) \\ do &#123; \\ if ((*env)-&gt;ExceptionOccurred(env)) &#123; \\ JLI_ReportExceptionDescription(env); \\ ret = (CEL_return_value); \\ LEAVE(); \\ &#125; \\ &#125; while (JNI_FALSE) InitializeJVM函数 初始化java虚拟机这里需要看下InvocationFunctions ifn函数的结构，然后就比较好理解了。之前对函数的赋值，然后创建虚拟机时调用。 12345typedef struct &#123; CreateJavaVM_t CreateJavaVM; GetDefaultJavaVMInitArgs_t GetDefaultJavaVMInitArgs; GetCreatedJavaVMs_t GetCreatedJavaVMs;&#125; InvocationFunctions; 见InitializeJVM函数主代码 1234567891011121314151617181920212223242526272829303132/* * Initializes the Java Virtual Machine. Also frees options array when * finished. */static jbooleanInitializeJVM(JavaVM **pvm, JNIEnv **penv, InvocationFunctions *ifn)&#123; JavaVMInitArgs args; jint r; memset(&amp;args, 0, sizeof(args)); args.version = JNI_VERSION_1_2; args.nOptions = numOptions; args.options = options; args.ignoreUnrecognized = JNI_FALSE; if (JLI_IsTraceLauncher()) &#123; int i = 0; printf(&quot;JavaVM args:\\n &quot;); printf(&quot;version 0x%08lx, &quot;, (long)args.version); printf(&quot;ignoreUnrecognized is %s, &quot;, args.ignoreUnrecognized ? &quot;JNI_TRUE&quot; : &quot;JNI_FALSE&quot;); printf(&quot;nOptions is %ld\\n&quot;, (long)args.nOptions); for (i = 0; i &lt; numOptions; i++) printf(&quot; option[%2d] = &#x27;%s&#x27;\\n&quot;, i, args.options[i].optionString); &#125; # 调用InvocationFunctions函数创建java虚拟机 r = ifn-&gt;CreateJavaVM(pvm, (void **)penv, &amp;args); JLI_MemFree(options); return r == JNI_OK;&#125; LoadMainClass函数 获取java程序启动类和方法，然后调用CallStaticObjectMethod方法，该函数会调用到jni_invoke_static方法 1234567891011121314151617181920212223242526272829303132/* * Loads a class and verifies that the main class is present and it is ok to * call it for more details refer to the java implementation. */static jclassLoadMainClass(JNIEnv *env, int mode, char *name)&#123; jmethodID mid; jstring str; jobject result; jlong start, end; jclass cls = GetLauncherHelperClass(env); NULL_CHECK0(cls); if (JLI_IsTraceLauncher()) &#123; start = CounterGet(); &#125; NULL_CHECK0(mid = (*env)-&gt;GetStaticMethodID(env, cls, &quot;checkAndLoadMain&quot;, &quot;(ZILjava/lang/String;)Ljava/lang/Class;&quot;)); str = NewPlatformString(env, name); result = (*env)-&gt;CallStaticObjectMethod(env, cls, mid, USE_STDERR, mode, str); if (JLI_IsTraceLauncher()) &#123; end = CounterGet(); printf(&quot;%ld micro seconds to load main class\\n&quot;, (long)(jint)Counter2Micros(end-start)); printf(&quot;----%s----\\n&quot;, JLDEBUG_ENV_ENTRY); &#125; return (jclass)result;&#125; jni.cpp 这里会调用JavaCalls::call，会调用到java主类。 1234567891011121314151617181920212223242526static void jni_invoke_static(JNIEnv *env, JavaValue* result, jobject receiver, JNICallType call_type, jmethodID method_id, JNI_ArgumentPusher *args, TRAPS) &#123; methodHandle method(THREAD, Method::resolve_jmethod_id(method_id)); // Create object to hold arguments for the JavaCall, and associate it with // the jni parser ResourceMark rm(THREAD); int number_of_parameters = method-&gt;size_of_parameters(); JavaCallArguments java_args(number_of_parameters); args-&gt;set_java_argument_object(&amp;java_args); assert(method-&gt;is_static(), &quot;method should be static&quot;); // Fill out JavaCallArguments object args-&gt;iterate( Fingerprinter(method).fingerprint() ); // Initialize result type result-&gt;set_type(args-&gt;get_ret_type()); // Invoke the method. Result is returned as oop. JavaCalls::call(result, method, &amp;java_args, CHECK); // Convert result if (result-&gt;get_type() == T_OBJECT || result-&gt;get_type() == T_ARRAY) &#123; result-&gt;set_jobject(JNIHandles::make_local(env, (oop) result-&gt;get_jobject())); &#125;&#125; 具体细节不用多扣，掌握流程和算法即可。","categories":[{"name":"jvm","slug":"jvm","permalink":"http://example.com/categories/jvm/"}],"tags":[{"name":"jvm","slug":"jvm","permalink":"http://example.com/tags/jvm/"}],"author":"jianghe"},{"title":"字节码文件","slug":"字节码文件","date":"2021-03-01T08:22:00.000Z","updated":"2021-07-06T15:00:15.398Z","comments":true,"path":"2021/03/01/字节码文件/","link":"","permalink":"http://example.com/2021/03/01/%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6/","excerpt":"","text":"概念每一个字节码文件其实都对应着全局唯一的一个类或者接口的定义信息。结构体中只有两种类型结构，分别是无符号数和表。 无符号数字节码文件中的“基本类型”，u1表示一个字节，无符号类型。u2表示二个字节，无符号类型。u4表示四个字节，无符号类型。u8表示八个字节，无符号类型。 表有多个无符号数或者其他表作为数据项构成的复合数据类型，所有表的后缀都是使用“_info”进行结尾 classFile每个字节码文件都对应一个ClassFile的结构。 123456789101112131415161718ClassFile &#123; u4 magic; u2 minor_version; u2 major_version; u2 constant_pool_count; cp_info constant_pool[constant_pool_count-1]; u2 access_flags; u2 this_class; u2 super_class; u2 interfaces_count; u2 interfaces[interfaces_count]; u2 fields_count; field_info fields[fields_count]; u2 methods_count; method_info methods[methods_count]; u2 attributes_count; attribute_info attributes[attributes_count]; &#125; magic(魔术)一个有效的字节码文件的前4个自己为0xCAFEBABE。魔术就是jvm用于校验所读取的目标文件是一个有效且合法的字节码文件。 minor_version(次版本号)和major_version(主版本号)紧跟在magic之后的4个字节就是编译的此版本号和主版本号，它们共同构成了字节码文件的版本号。比如主板号为M，次版本号m，那版本号为M.m。 如果字节码文件的版本号超出jvm所能够处理的有效范围，那么java虚拟机将不会处理这个字节码文件 constant_pool_count(常量池数量)和constant_pool(常量池)常量池是字节码文件中非常重要的数据结构，同时也是字节码文件中与其他结构关联最多和占用字节码空间最大的数据结构。常量池主要用于存放字面量（Literal）和符号引用（Symbolic References）两大类数据常量，其访问方式是通过索引来访问的。 常量池数量中的计数器并非是从0开始计数的，是从1开始计数的，这么做的目的就是为了满足后续其他数据结构在不引用常量池中的任何常量结构时，默认可以把常量池中的访问索引设置为0来表示 字面量 文字字符串 final常量值 符号引用 类和接口的全限定名 字段的名称和描述符 方法的名称和描述符 在C语言中，如果一个程序需要调用其他库中的函数，那么在链接时，该函数在库中的位置（即相对于库文件开头的偏移量）会被写在程序中，运行时直接去这个地址调用函数即可。但在java虚拟机在运行时，从常量池中获取出对应的符号引用，并经过解析阶段将这些符号引用全部转换为直接引用，java虚拟机才能正常使用。 12345cp_info &#123; u1 tag; u1 info[]; &#125; access_flags(访问标志)访问标志主要就是用于表示某个类或者接口的访问权限 文件时类还是接口 访问的修饰符是哪一种 是否有abstract关键字修饰的抽象类 this_class(类索引)和super_class(超类索引)类索引和超类索引各自会通过索引指向常量池列表中一个类型为CONSTANT_Class_info的常量结构。CONSTANT_Class_info由tag和name_index两部分构成。tag是一个具有CONSTANT_Class_info值的常量，而name_index则是一个指向常量池列表中类型为CONSTANT_Utf8_info常量结构的索引，通过这个索引值即可成功获取到CONSTANT_Utf8_info常量结构中的全限定名字符串。类索引用于确定当前类的全限定名，而超类索引则用于确定当前类的超类全限定名。 由于java.lang.Object是所有类型的超类，那么如果一个类缺省并没有显示地继承任何超类，那么它的直接超类就应该是Object，其父类索引的值就为0 interfaces_count(接口数量)和interfaces(接口表)接口数量：用于表示当前类或者接口的直接超类接口数量 接口表：实际上则是一个数组集合，它包含了当前类或者接口在常量池列表中直接超类接口的索引集合，通过这个索引即可确定当前类或者接口的超类接口的全限定名 字节码文件中，除了常量池计数器中的计数值从1开始，其余的数组集合类型都是从0开始 fields_count(字段数量)和fields(字段表)字段数量：表示一个字节码文件中的field_info表总数，也就是一个类中类变量和实例变量的数量总和字段表：一个数组集合，字段表中的每一个成员都必须是一个field_info数据结构field_info：用于表示一个字段的完整信息 字段标识符 访问修饰符 是类变量还是实例变量(static) 是否是常量(final修饰符) 字段表中所包含的字段信息仅限于当前类或者当前接口的所属字段，并不包含继承超类的字段信息 1234567field_info &#123; u2 access_flags; u2 name_index; u2 descriptor_index; u2 attributes_count; attribute_info attributes[attributes_count]; &#125; methods_count(方法数量)和methods(方法表)方法数量：一个字节码文件中的method_info表总数方法表：是一个数组集合，方法表中的每一个成员都必须是一个method_info数据结构。method_info：表示当前类或者接口中某个方法的完整描述 方法标示符 方法的访问修饰符 方法的返回值类型 方法的参数信息 方法表所包含的方法信息仅限于当前类或者接口中的所属方法，并不包含继承超类的方法信息 1234567method_info &#123; u2 access_flags; u2 name_index; u2 descriptor_index; u2 attributes_count; attribute_info attributes[attributes_count]; &#125; attributes_count(属性数量)和attributes(属性表)属性数量：标示当前字节码文件中的attribute_info表总数属性表：一个数组集合，属性表中的每一个成员都必须是一个attribute_info数据结构。每一个attribute_info表的第一项都是指向常量池列表中CONSTANT_Utf8_info的，该表给出了属性的名称12345attribute_info &#123; u2 attribute_name_index; u4 attribute_length; u1 info[attribute_length]; &#125;","categories":[{"name":"jvm","slug":"jvm","permalink":"http://example.com/categories/jvm/"}],"tags":[{"name":"jvm","slug":"jvm","permalink":"http://example.com/tags/jvm/"}],"author":"jianghe"},{"title":"字节码编译原理","slug":"字节码编译原理","date":"2021-01-29T08:44:00.000Z","updated":"2021-07-06T15:00:15.401Z","comments":true,"path":"2021/01/29/字节码编译原理/","link":"","permalink":"http://example.com/2021/01/29/%E5%AD%97%E8%8A%82%E7%A0%81%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/","excerpt":"","text":"字节码 一次编译，处处运行(write once,run anywhere) 1. 前端编译器 将java源码编译为字节码，前端编译器不会直接涉及编译优化等方面的技术，而是将这些具体的细节移交给Hotspot的Jit编译器负责。 javac 配置在“PATH”环境变量中的javac编译器 全量式编译 ECJ（eclipse compiler for java） eclipse使用的前端编译器是自主研发的 增量式编译，每次保存时编译方案是把未编译部分的源码逐行进行编译，效率高效，编译的质量也和javac相比大致还是一致的 其中tomcat编译jsp也是通过ECJ方式来编译，ECJ编译器也是开源的 2. 编译原理 javac编译器在将java源码编译为一个有效的字节码文件主要的步骤：词法解析-&gt;语法解析-&gt;语义解析-&gt;生成字节码 12345678910111213141516171819202122232425262728293031323334# javac 命令编译文件成字节码Usage: javac &lt;options&gt; &lt;source files&gt;where possible options include: -g Generate all debugging info -g:none Generate no debugging info -g:&#123;lines,vars,source&#125; Generate only some debugging info -nowarn Generate no warnings -verbose Output messages about what the compiler is doing -deprecation Output source locations where deprecated APIs are used -classpath &lt;path&gt; Specify where to find user class files and annotation processors -cp &lt;path&gt; Specify where to find user class files and annotation processors -sourcepath &lt;path&gt; Specify where to find input source files -bootclasspath &lt;path&gt; Override location of bootstrap class files -extdirs &lt;dirs&gt; Override location of installed extensions -endorseddirs &lt;dirs&gt; Override location of endorsed standards path -proc:&#123;none,only&#125; Control whether annotation processing and/or compilation is done. -processor &lt;class1&gt;[,&lt;class2&gt;,&lt;class3&gt;...] Names of the annotation processors to run; bypasses default discovery process -processorpath &lt;path&gt; Specify where to find annotation processors -parameters Generate metadata for reflection on method parameters -d &lt;directory&gt; Specify where to place generated class files -s &lt;directory&gt; Specify where to place generated source files -h &lt;directory&gt; Specify where to place generated native header files -implicit:&#123;none,class&#125; Specify whether or not to generate class files for implicitly referenced files -encoding &lt;encoding&gt; Specify character encoding used by source files -source &lt;release&gt; Provide source compatibility with specified release -target &lt;release&gt; Generate class files for specific VM version -profile &lt;profile&gt; Check that API used is available in the specified profile -version Version information -help Print a synopsis of standard options -Akey[=value] Options to pass to annotation processors -X Print a synopsis of nonstandard options -J&lt;flag&gt; Pass &lt;flag&gt; directly to the runtime system -Werror Terminate compilation if warnings occur @&lt;filename&gt; Read options and filenames from file 2.0 前提javac 代码在langtools/src/share/classes/com/sun/tools/javac目录下,见下图。其中主要的是Main.java。这里解释下，hotspot最核心的还是c++以及混合少量的c和汇编语言编写，“外围”还是采用java语言编写。 12345678910111213141516171819202122232425262728293031323334353637/** Main entry point for the launcher. * Note: This method calls System.exit. * @param args command line arguments */ public static void main(String[] args) throws Exception &#123; System.exit(compile(args)); &#125; /** Programmatic interface to the Java Programming Language * compiler, javac. * * @param args The command line arguments that would normally be * passed to the javac program as described in the man page. * @return an integer equivalent to the exit value from invoking * javac, see the man page for details. */ public static int compile(String[] args) &#123; com.sun.tools.javac.main.Main compiler = new com.sun.tools.javac.main.Main(&quot;javac&quot;); return compiler.compile(args).exitCode; &#125; # 该类是com.sun.tools.javac.main.Main，其中的compile方法 /** Programmatic interface for main function. * @param args The command line parameters. */ public Result compile(String[] args) &#123; Context context = new Context(); JavacFileManager.preRegister(context); // can&#x27;t create it until Log has been set up Result result = compile(args, context); if (fileManager instanceof JavacFileManager) &#123; // A fresh context was created above, so jfm must be a JavacFileManager ((JavacFileManager)fileManager).close(); &#125; return result; &#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/** Parse contents of input stream. * @param filename The name of the file from which input stream comes. * @param content The characters to be parsed. */ protected JCCompilationUnit parse(JavaFileObject filename, CharSequence content) &#123; long msec = now(); JCCompilationUnit tree = make.TopLevel(List.&lt;JCTree.JCAnnotation&gt;nil(), null, List.&lt;JCTree&gt;nil()); if (content != null) &#123; if (verbose) &#123; log.printVerbose(&quot;parsing.started&quot;, filename); &#125; if (!taskListener.isEmpty()) &#123; TaskEvent e = new TaskEvent(TaskEvent.Kind.PARSE, filename); taskListener.started(e); keepComments = true; genEndPos = true; &#125; // 获取JavacParser解析器 Parser parser = parserFactory.newParser(content, keepComments(), genEndPos, lineDebugInfo); // 词法分析&amp;语法分析 tree = parser.parseCompilationUnit(); if (verbose) &#123; log.printVerbose(&quot;parsing.done&quot;, Long.toString(elapsed(msec))); &#125; &#125; tree.sourcefile = filename; if (content != null &amp;&amp; !taskListener.isEmpty()) &#123; TaskEvent e = new TaskEvent(TaskEvent.Kind.PARSE, tree); taskListener.finished(e); &#125; return tree; &#125;/**parserFactory.newParser 方法，其实内部包含了个Lexer接口，实现类为Scanner，而Scanner类主要任务就是按照单个字符的方式读取java源文件中的关键字和标示符，将其转换为符合java语法规范的Token序列 **/public JavacParser newParser(CharSequence input, boolean keepDocComments, boolean keepEndPos, boolean keepLineMap) &#123; Lexer lexer = scannerFactory.newScanner(input, keepDocComments); return new JavacParser(this, lexer, keepDocComments, keepLineMap, keepEndPos); &#125; /** scannerFactory.newScanner方法 **/ public Scanner newScanner(CharSequence input, boolean keepDocComments) &#123; if (input instanceof CharBuffer) &#123; CharBuffer buf = (CharBuffer) input; if (keepDocComments) return new Scanner(this, new JavadocTokenizer(this, buf)); else return new Scanner(this, buf); &#125; else &#123; char[] array = input.toString().toCharArray(); return newScanner(array, array.length, keepDocComments); &#125; &#125; public Scanner newScanner(char[] input, int inputLength, boolean keepDocComments) &#123; if (keepDocComments) return new Scanner(this, new JavadocTokenizer(this, input, inputLength)); else return new Scanner(this, input, inputLength); &#125; 看了上述代码，我们可以发现词法分析主要是在parser.parseCompilationUnit进行的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475/** CompilationUnit = [ &#123; &quot;@&quot; Annotation &#125; PACKAGE Qualident &quot;;&quot;] &#123;ImportDeclaration&#125; &#123;TypeDeclaration&#125; * 词法解析&amp;语法解析 */ public JCTree.JCCompilationUnit parseCompilationUnit() &#123; Token firstToken = token; JCExpression pid = null; JCModifiers mods = null; boolean consumedToplevelDoc = false; boolean seenImport = false; boolean seenPackage = false; List&lt;JCAnnotation&gt; packageAnnotations = List.nil(); if (token.kind == MONKEYS_AT) mods = modifiersOpt(); // package 解析，词法分析token和语法分析 if (token.kind == PACKAGE) &#123; seenPackage = true; if (mods != null) &#123; checkNoMods(mods.flags); packageAnnotations = mods.annotations; mods = null; &#125; // 获取token nextToken(); // 解析package语法节点 pid = qualident(false); accept(SEMI); &#125; ListBuffer&lt;JCTree&gt; defs = new ListBuffer&lt;JCTree&gt;(); boolean checkForImports = true; boolean firstTypeDecl = true; while (token.kind != EOF) &#123; if (token.pos &gt; 0 &amp;&amp; token.pos &lt;= endPosTable.errorEndPos) &#123; // error recovery skip(checkForImports, false, false, false); if (token.kind == EOF) break; &#125; // import 解析，有可能会有多个import，循环 if (checkForImports &amp;&amp; mods == null &amp;&amp; token.kind == IMPORT) &#123; seenImport = true; defs.append(importDeclaration()); &#125; else &#123; // class主体解析 Comment docComment = token.comment(CommentStyle.JAVADOC); if (firstTypeDecl &amp;&amp; !seenImport &amp;&amp; !seenPackage) &#123; docComment = firstToken.comment(CommentStyle.JAVADOC); consumedToplevelDoc = true; &#125; /*解析类主体信息并转化为语法树*/ JCTree def = typeDeclaration(mods, docComment); if (def instanceof JCExpressionStatement) def = ((JCExpressionStatement)def).expr; defs.append(def); if (def instanceof JCClassDecl) checkForImports = false; mods = null; firstTypeDecl = false; &#125; &#125; // 生成抽象语法树，每个语法节点都直接或间接地继承JCTree JCTree.JCCompilationUnit toplevel = F.at(firstToken.pos).TopLevel(packageAnnotations, pid, defs.toList()); if (!consumedToplevelDoc) attach(toplevel, firstToken.comment(CommentStyle.JAVADOC)); if (defs.isEmpty()) storeEnd(toplevel, S.prevToken().endPos); if (keepDocComments) toplevel.docComments = docComments; if (keepLineMap) toplevel.lineMap = S.getLineMap(); this.endPosTable.setParser(null); // remove reference to parser toplevel.endPositions = this.endPosTable; return toplevel; &#125; 那哪里是词法分析具体代码呢？其实是在nextToken()进行 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302# 当前是Scanner类 # S是Lexer接口，其实就是Scanner类 /** Buffer of saved tokens (used during lookahead)* list是顺序的 */ private List&lt;Token&gt; savedTokens = new ArrayList&lt;Token&gt;(); public Token token() &#123; return token(0); &#125; public Token token(int lookahead) &#123; if (lookahead == 0) &#123; return token; &#125; else &#123; ensureLookahead(lookahead); return savedTokens.get(lookahead - 1); &#125; &#125; //where private void ensureLookahead(int lookahead) &#123; for (int i = savedTokens.size() ; i &lt; lookahead ; i ++) &#123; savedTokens.add(tokenizer.readToken()); &#125; &#125;public void nextToken() &#123; S.nextToken(); token = S.token(); &#125; # tokenizer 是 JavaTokenizer类，JavaTokenizer类是在Scanner中属性，创建实例的时候创建的的。 public void nextToken() &#123; prevToken = token; if (!savedTokens.isEmpty()) &#123; token = savedTokens.remove(0); &#125; else &#123; // 获取token token = tokenizer.readToken(); &#125; &#125; # tokenizer.readToken() 方法，实际是在这里生成词法token /** * Read token. */ public Token readToken() &#123; reader.sp = 0; name = null; radix = 0; int pos = 0; int endPos = 0; List&lt;Comment&gt; comments = null; try &#123; loop: while (true) &#123; pos = reader.bp; switch (reader.ch) &#123; case &#x27; &#x27;: // (Spec 3.6) case &#x27;\\t&#x27;: // (Spec 3.6) case FF: // (Spec 3.6) do &#123; reader.scanChar(); &#125; while (reader.ch == &#x27; &#x27; || reader.ch == &#x27;\\t&#x27; || reader.ch == FF); processWhiteSpace(pos, reader.bp); break; case LF: // (Spec 3.4) reader.scanChar(); processLineTerminator(pos, reader.bp); break; case CR: // (Spec 3.4) reader.scanChar(); if (reader.ch == LF) &#123; reader.scanChar(); &#125; processLineTerminator(pos, reader.bp); break; case &#x27;A&#x27;: case &#x27;B&#x27;: case &#x27;C&#x27;: case &#x27;D&#x27;: case &#x27;E&#x27;: case &#x27;F&#x27;: case &#x27;G&#x27;: case &#x27;H&#x27;: case &#x27;I&#x27;: case &#x27;J&#x27;: case &#x27;K&#x27;: case &#x27;L&#x27;: case &#x27;M&#x27;: case &#x27;N&#x27;: case &#x27;O&#x27;: case &#x27;P&#x27;: case &#x27;Q&#x27;: case &#x27;R&#x27;: case &#x27;S&#x27;: case &#x27;T&#x27;: case &#x27;U&#x27;: case &#x27;V&#x27;: case &#x27;W&#x27;: case &#x27;X&#x27;: case &#x27;Y&#x27;: case &#x27;Z&#x27;: case &#x27;a&#x27;: case &#x27;b&#x27;: case &#x27;c&#x27;: case &#x27;d&#x27;: case &#x27;e&#x27;: case &#x27;f&#x27;: case &#x27;g&#x27;: case &#x27;h&#x27;: case &#x27;i&#x27;: case &#x27;j&#x27;: case &#x27;k&#x27;: case &#x27;l&#x27;: case &#x27;m&#x27;: case &#x27;n&#x27;: case &#x27;o&#x27;: case &#x27;p&#x27;: case &#x27;q&#x27;: case &#x27;r&#x27;: case &#x27;s&#x27;: case &#x27;t&#x27;: case &#x27;u&#x27;: case &#x27;v&#x27;: case &#x27;w&#x27;: case &#x27;x&#x27;: case &#x27;y&#x27;: case &#x27;z&#x27;: case &#x27;$&#x27;: case &#x27;_&#x27;: // 设置Name scanIdent(); break loop; case &#x27;0&#x27;: reader.scanChar(); if (reader.ch == &#x27;x&#x27; || reader.ch == &#x27;X&#x27;) &#123; reader.scanChar(); skipIllegalUnderscores(); if (reader.ch == &#x27;.&#x27;) &#123; scanHexFractionAndSuffix(pos, false); &#125; else if (reader.digit(pos, 16) &lt; 0) &#123; lexError(pos, &quot;invalid.hex.number&quot;); &#125; else &#123; scanNumber(pos, 16); &#125; &#125; else if (reader.ch == &#x27;b&#x27; || reader.ch == &#x27;B&#x27;) &#123; if (!allowBinaryLiterals) &#123; lexError(pos, &quot;unsupported.binary.lit&quot;, source.name); allowBinaryLiterals = true; &#125; reader.scanChar(); skipIllegalUnderscores(); if (reader.digit(pos, 2) &lt; 0) &#123; lexError(pos, &quot;invalid.binary.number&quot;); &#125; else &#123; scanNumber(pos, 2); &#125; &#125; else &#123; reader.putChar(&#x27;0&#x27;); if (reader.ch == &#x27;_&#x27;) &#123; int savePos = reader.bp; do &#123; reader.scanChar(); &#125; while (reader.ch == &#x27;_&#x27;); if (reader.digit(pos, 10) &lt; 0) &#123; lexError(savePos, &quot;illegal.underscore&quot;); &#125; &#125; scanNumber(pos, 8); &#125; break loop; case &#x27;1&#x27;: case &#x27;2&#x27;: case &#x27;3&#x27;: case &#x27;4&#x27;: case &#x27;5&#x27;: case &#x27;6&#x27;: case &#x27;7&#x27;: case &#x27;8&#x27;: case &#x27;9&#x27;: scanNumber(pos, 10); break loop; case &#x27;.&#x27;: reader.scanChar(); if (&#x27;0&#x27; &lt;= reader.ch &amp;&amp; reader.ch &lt;= &#x27;9&#x27;) &#123; reader.putChar(&#x27;.&#x27;); scanFractionAndSuffix(pos); &#125; else if (reader.ch == &#x27;.&#x27;) &#123; int savePos = reader.bp; reader.putChar(&#x27;.&#x27;); reader.putChar(&#x27;.&#x27;, true); if (reader.ch == &#x27;.&#x27;) &#123; reader.scanChar(); reader.putChar(&#x27;.&#x27;); tk = TokenKind.ELLIPSIS; &#125; else &#123; lexError(savePos, &quot;illegal.dot&quot;); &#125; &#125; else &#123; tk = TokenKind.DOT; &#125; break loop; case &#x27;,&#x27;: reader.scanChar(); tk = TokenKind.COMMA; break loop; case &#x27;;&#x27;: reader.scanChar(); tk = TokenKind.SEMI; break loop; case &#x27;(&#x27;: reader.scanChar(); tk = TokenKind.LPAREN; break loop; case &#x27;)&#x27;: reader.scanChar(); tk = TokenKind.RPAREN; break loop; case &#x27;[&#x27;: reader.scanChar(); tk = TokenKind.LBRACKET; break loop; case &#x27;]&#x27;: reader.scanChar(); tk = TokenKind.RBRACKET; break loop; case &#x27;&#123;&#x27;: reader.scanChar(); tk = TokenKind.LBRACE; break loop; case &#x27;&#125;&#x27;: reader.scanChar(); tk = TokenKind.RBRACE; break loop; case &#x27;/&#x27;: reader.scanChar(); if (reader.ch == &#x27;/&#x27;) &#123; do &#123; reader.scanCommentChar(); &#125; while (reader.ch != CR &amp;&amp; reader.ch != LF &amp;&amp; reader.bp &lt; reader.buflen); if (reader.bp &lt; reader.buflen) &#123; comments = addComment(comments, processComment(pos, reader.bp, CommentStyle.LINE)); &#125; break; &#125; else if (reader.ch == &#x27;*&#x27;) &#123; boolean isEmpty = false; reader.scanChar(); CommentStyle style; if (reader.ch == &#x27;*&#x27;) &#123; style = CommentStyle.JAVADOC; reader.scanCommentChar(); if (reader.ch == &#x27;/&#x27;) &#123; isEmpty = true; &#125; &#125; else &#123; style = CommentStyle.BLOCK; &#125; while (!isEmpty &amp;&amp; reader.bp &lt; reader.buflen) &#123; if (reader.ch == &#x27;*&#x27;) &#123; reader.scanChar(); if (reader.ch == &#x27;/&#x27;) break; &#125; else &#123; reader.scanCommentChar(); &#125; &#125; if (reader.ch == &#x27;/&#x27;) &#123; reader.scanChar(); comments = addComment(comments, processComment(pos, reader.bp, style)); break; &#125; else &#123; lexError(pos, &quot;unclosed.comment&quot;); break loop; &#125; &#125; else if (reader.ch == &#x27;=&#x27;) &#123; tk = TokenKind.SLASHEQ; reader.scanChar(); &#125; else &#123; tk = TokenKind.SLASH; &#125; break loop; case &#x27;\\&#x27;&#x27;: reader.scanChar(); if (reader.ch == &#x27;\\&#x27;&#x27;) &#123; lexError(pos, &quot;empty.char.lit&quot;); &#125; else &#123; if (reader.ch == CR || reader.ch == LF) lexError(pos, &quot;illegal.line.end.in.char.lit&quot;); scanLitChar(pos); char ch2 = reader.ch; if (reader.ch == &#x27;\\&#x27;&#x27;) &#123; reader.scanChar(); tk = TokenKind.CHARLITERAL; &#125; else &#123; lexError(pos, &quot;unclosed.char.lit&quot;); &#125; &#125; break loop; case &#x27;\\&quot;&#x27;: reader.scanChar(); while (reader.ch != &#x27;\\&quot;&#x27; &amp;&amp; reader.ch != CR &amp;&amp; reader.ch != LF &amp;&amp; reader.bp &lt; reader.buflen) scanLitChar(pos); if (reader.ch == &#x27;\\&quot;&#x27;) &#123; tk = TokenKind.STRINGLITERAL; reader.scanChar(); &#125; else &#123; lexError(pos, &quot;unclosed.str.lit&quot;); &#125; break loop; default: if (isSpecial(reader.ch)) &#123; scanOperator(); &#125; else &#123; boolean isJavaIdentifierStart; if (reader.ch &lt; &#x27;\\u0080&#x27;) &#123; // all ASCII range chars already handled, above isJavaIdentifierStart = false; &#125; else &#123; char high = reader.scanSurrogates(); if (high != 0) &#123; reader.putChar(high); isJavaIdentifierStart = Character.isJavaIdentifierStart( Character.toCodePoint(high, reader.ch)); &#125; else &#123; isJavaIdentifierStart = Character.isJavaIdentifierStart(reader.ch); &#125; &#125; if (isJavaIdentifierStart) &#123; scanIdent(); &#125; else if (reader.bp == reader.buflen || reader.ch == EOI &amp;&amp; reader.bp + 1 == reader.buflen) &#123; // JLS 3.5 tk = TokenKind.EOF; pos = reader.buflen; &#125; else &#123; String arg = (32 &lt; reader.ch &amp;&amp; reader.ch &lt; 127) ? String.format(&quot;%s&quot;, reader.ch) : String.format(&quot;\\\\u%04x&quot;, (int)reader.ch); lexError(pos, &quot;illegal.char&quot;, arg); reader.scanChar(); &#125; &#125; break loop; &#125; &#125; endPos = reader.bp; # hold on... ,这是生成token创建方法，NamedToken、StringToken、NumericToken都是实现Token类，NamedToken信息是在name里 switch (tk.tag) &#123; case DEFAULT: return new Token(tk, pos, endPos, comments); case NAMED: return new NamedToken(tk, pos, endPos, name, comments); case STRING: return new StringToken(tk, pos, endPos, reader.chars(), comments); case NUMERIC: return new NumericToken(tk, pos, endPos, reader.chars(), radix, comments); default: throw new AssertionError(); &#125; &#125; finally &#123; if (scannerDebug) &#123; System.out.println(&quot;nextToken(&quot; + pos + &quot;,&quot; + endPos + &quot;)=|&quot; + new String(reader.getRawCharacters(pos, endPos)) + &quot;|&quot;); &#125; &#125; &#125; 那生成出来的Token是什么呢？其实就是一组对应源码字符集合的单词序列，其中Token会有TokenKind和Name，那TokenKind就是Token表示的类型。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290/** * This is the class representing a javac token. Each token has several fields * that are set by the javac lexer (i.e. start/end position, string value, etc). */ public static class Token &#123; /** tags constants **/ enum Tag &#123; DEFAULT, NAMED, STRING, NUMERIC; &#125; /** The token kind */ public final TokenKind kind; /** The start position of this token */ public final int pos; /** The end position of this token */ public final int endPos; /** Comment reader associated with this token */ public final List&lt;Comment&gt; comments; Token(TokenKind kind, int pos, int endPos, List&lt;Comment&gt; comments) &#123; this.kind = kind; this.pos = pos; this.endPos = endPos; this.comments = comments; checkKind(); &#125; Token[] split(Tokens tokens) &#123; if (kind.name.length() &lt; 2 || kind.tag != Tag.DEFAULT) &#123; throw new AssertionError(&quot;Cant split&quot; + kind); &#125; TokenKind t1 = tokens.lookupKind(kind.name.substring(0, 1)); TokenKind t2 = tokens.lookupKind(kind.name.substring(1)); if (t1 == null || t2 == null) &#123; throw new AssertionError(&quot;Cant split - bad subtokens&quot;); &#125; return new Token[] &#123; new Token(t1, pos, pos + t1.name.length(), comments), new Token(t2, pos + t1.name.length(), endPos, null) &#125;; &#125; protected void checkKind() &#123; if (kind.tag != Tag.DEFAULT) &#123; throw new AssertionError(&quot;Bad token kind - expected &quot; + Tag.STRING); &#125; &#125; public Name name() &#123; throw new UnsupportedOperationException(); &#125; public String stringVal() &#123; throw new UnsupportedOperationException(); &#125; public int radix() &#123; throw new UnsupportedOperationException(); &#125; /** * Preserve classic semantics - if multiple javadocs are found on the token * the last one is returned */ public Comment comment(Comment.CommentStyle style) &#123; List&lt;Comment&gt; comments = getComments(Comment.CommentStyle.JAVADOC); return comments.isEmpty() ? null : comments.head; &#125; /** * Preserve classic semantics - deprecated should be set if at least one * javadoc comment attached to this token contains the &#x27;@deprecated&#x27; string */ public boolean deprecatedFlag() &#123; for (Comment c : getComments(Comment.CommentStyle.JAVADOC)) &#123; if (c.isDeprecated()) &#123; return true; &#125; &#125; return false; &#125; private List&lt;Comment&gt; getComments(Comment.CommentStyle style) &#123; if (comments == null) &#123; return List.nil(); &#125; else &#123; ListBuffer&lt;Comment&gt; buf = new ListBuffer&lt;&gt;(); for (Comment c : comments) &#123; if (c.getStyle() == style) &#123; buf.add(c); &#125; &#125; return buf.toList(); &#125; &#125; &#125; # TokenKind，这个就是表示Token类型，TokenKind类型中Named tag类型，除了IDENTIFIER没有String name字段属性的标识的，其他都有。 /** * This enum defines all tokens used by the javac scanner. A token is * optionally associated with a name. */ public enum TokenKind implements Formattable, Filter&lt;TokenKind&gt; &#123; EOF(), ERROR(), IDENTIFIER(Tag.NAMED), ABSTRACT(&quot;abstract&quot;), ASSERT(&quot;assert&quot;, Tag.NAMED), BOOLEAN(&quot;boolean&quot;, Tag.NAMED), BREAK(&quot;break&quot;), BYTE(&quot;byte&quot;, Tag.NAMED), CASE(&quot;case&quot;), CATCH(&quot;catch&quot;), CHAR(&quot;char&quot;, Tag.NAMED), CLASS(&quot;class&quot;), CONST(&quot;const&quot;), CONTINUE(&quot;continue&quot;), DEFAULT(&quot;default&quot;), DO(&quot;do&quot;), DOUBLE(&quot;double&quot;, Tag.NAMED), ELSE(&quot;else&quot;), ENUM(&quot;enum&quot;, Tag.NAMED), EXTENDS(&quot;extends&quot;), FINAL(&quot;final&quot;), FINALLY(&quot;finally&quot;), FLOAT(&quot;float&quot;, Tag.NAMED), FOR(&quot;for&quot;), GOTO(&quot;goto&quot;), IF(&quot;if&quot;), IMPLEMENTS(&quot;implements&quot;), IMPORT(&quot;import&quot;), INSTANCEOF(&quot;instanceof&quot;), INT(&quot;int&quot;, Tag.NAMED), INTERFACE(&quot;interface&quot;), LONG(&quot;long&quot;, Tag.NAMED), NATIVE(&quot;native&quot;), NEW(&quot;new&quot;), PACKAGE(&quot;package&quot;), PRIVATE(&quot;private&quot;), PROTECTED(&quot;protected&quot;), PUBLIC(&quot;public&quot;), RETURN(&quot;return&quot;), SHORT(&quot;short&quot;, Tag.NAMED), STATIC(&quot;static&quot;), STRICTFP(&quot;strictfp&quot;), SUPER(&quot;super&quot;, Tag.NAMED), SWITCH(&quot;switch&quot;), SYNCHRONIZED(&quot;synchronized&quot;), THIS(&quot;this&quot;, Tag.NAMED), THROW(&quot;throw&quot;), THROWS(&quot;throws&quot;), TRANSIENT(&quot;transient&quot;), TRY(&quot;try&quot;), VOID(&quot;void&quot;, Tag.NAMED), VOLATILE(&quot;volatile&quot;), WHILE(&quot;while&quot;), INTLITERAL(Tag.NUMERIC), LONGLITERAL(Tag.NUMERIC), FLOATLITERAL(Tag.NUMERIC), DOUBLELITERAL(Tag.NUMERIC), CHARLITERAL(Tag.NUMERIC), STRINGLITERAL(Tag.STRING), TRUE(&quot;true&quot;, Tag.NAMED), FALSE(&quot;false&quot;, Tag.NAMED), NULL(&quot;null&quot;, Tag.NAMED), UNDERSCORE(&quot;_&quot;, Tag.NAMED), ARROW(&quot;-&gt;&quot;), COLCOL(&quot;::&quot;), LPAREN(&quot;(&quot;), RPAREN(&quot;)&quot;), LBRACE(&quot;&#123;&quot;), RBRACE(&quot;&#125;&quot;), LBRACKET(&quot;[&quot;), RBRACKET(&quot;]&quot;), SEMI(&quot;;&quot;), COMMA(&quot;,&quot;), DOT(&quot;.&quot;), ELLIPSIS(&quot;...&quot;), EQ(&quot;=&quot;), GT(&quot;&gt;&quot;), LT(&quot;&lt;&quot;), BANG(&quot;!&quot;), TILDE(&quot;~&quot;), QUES(&quot;?&quot;), COLON(&quot;:&quot;), EQEQ(&quot;==&quot;), LTEQ(&quot;&lt;=&quot;), GTEQ(&quot;&gt;=&quot;), BANGEQ(&quot;!=&quot;), AMPAMP(&quot;&amp;&amp;&quot;), BARBAR(&quot;||&quot;), PLUSPLUS(&quot;++&quot;), SUBSUB(&quot;--&quot;), PLUS(&quot;+&quot;), SUB(&quot;-&quot;), STAR(&quot;*&quot;), SLASH(&quot;/&quot;), AMP(&quot;&amp;&quot;), BAR(&quot;|&quot;), CARET(&quot;^&quot;), PERCENT(&quot;%&quot;), LTLT(&quot;&lt;&lt;&quot;), GTGT(&quot;&gt;&gt;&quot;), GTGTGT(&quot;&gt;&gt;&gt;&quot;), PLUSEQ(&quot;+=&quot;), SUBEQ(&quot;-=&quot;), STAREQ(&quot;*=&quot;), SLASHEQ(&quot;/=&quot;), AMPEQ(&quot;&amp;=&quot;), BAREQ(&quot;|=&quot;), CARETEQ(&quot;^=&quot;), PERCENTEQ(&quot;%=&quot;), LTLTEQ(&quot;&lt;&lt;=&quot;), GTGTEQ(&quot;&gt;&gt;=&quot;), GTGTGTEQ(&quot;&gt;&gt;&gt;=&quot;), MONKEYS_AT(&quot;@&quot;), CUSTOM; public final String name; public final Tag tag; TokenKind() &#123; this(null, Tag.DEFAULT); &#125; TokenKind(String name) &#123; this(name, Tag.DEFAULT); &#125; TokenKind(Tag tag) &#123; this(null, tag); &#125; TokenKind(String name, Tag tag) &#123; this.name = name; this.tag = tag; &#125; public String toString() &#123; switch (this) &#123; case IDENTIFIER: return &quot;token.identifier&quot;; case CHARLITERAL: return &quot;token.character&quot;; case STRINGLITERAL: return &quot;token.string&quot;; case INTLITERAL: return &quot;token.integer&quot;; case LONGLITERAL: return &quot;token.long-integer&quot;; case FLOATLITERAL: return &quot;token.float&quot;; case DOUBLELITERAL: return &quot;token.double&quot;; case ERROR: return &quot;token.bad-symbol&quot;; case EOF: return &quot;token.end-of-input&quot;; case DOT: case COMMA: case SEMI: case LPAREN: case RPAREN: case LBRACKET: case RBRACKET: case LBRACE: case RBRACE: return &quot;&#x27;&quot; + name + &quot;&#x27;&quot;; default: return name; &#125; &#125; public String getKind() &#123; return &quot;Token&quot;; &#125; public String toString(Locale locale, Messages messages) &#123; return name != null ? toString() : messages.getLocalizedString(locale, &quot;compiler.misc.&quot; + toString()); &#125; @Override public boolean accepts(TokenKind that) &#123; return this == that; &#125; &#125; 2.1 词法分析javac编译第一步，词法解析器最主要的任务就是将java源码中的关键字和标示符等内容转换为符合java语法规范的token序列，然后按照指定的顺序规则进行匹配校验，以便为后续的语法分析做准备。 那源码字符集合与Token之间的对应关系 源码字符集合如何转换成Token?看一下下面的代码，是Tokens来转换的 词法解析器又是采用什么方式保存源码字符集合与Token之间的对应关系?词法解析器在将源码字符集合转换为Token序列之前，会将每一个字符集合转换为一个对应的name对象。Tokens会将Token中的所有枚举常量全部转换为Name对象，将其存储在对象的内部类Table中，这样一来源码字符集合与Token就有联系了。 123456789101112131415# 该类是Tokens，其中下面就是token和name转换映射/** * Keyword array. Maps name indices to Token. */ private final TokenKind[] key; /**根据Name来获取TokenKind，进而获取token * Create a new token given a name; if the name corresponds to a token name, * a new token of the corresponding kind is returned; otherwise, an * identifier token is returned. */ TokenKind lookupKind(Name name) &#123; return (name.getIndex() &gt; maxKey) ? TokenKind.IDENTIFIER : key[name.getIndex()]; &#125; 举个例子 123456package compile;public class Cifa &#123; int a; int b=a+1;&#125; 2.2 语法分析目的：将进行词法分析后形成的Token流中的一个个Token组成一句句话，检查这一句句话是不是符合Java语言规范，形成抽象语法树。 流程： package import 类（包含class、interface、enum），一下提到的类泛指这三类，并不单单是指class12345678910111213package compile;public class Yufa &#123; int a; private int c = a + 1; //getter public int getC() &#123; return c; &#125; //setter public void setC(int c) &#123; this.c = c; &#125;&#125; 2.3 语义分析由于语法解析出来的抽象语法树并不能直接应用于生成字节码文件，这是因为这颗语法树相对来说还不是很完善，那语义分析就是将语法树扩充的更加完善，后续编译器将会使用语义解析后的语法树来生成字节码将语法树转化为注解语法树 流程： 添加默认的无参构造器（在没有指定任何有参构造器的情况下），把引用其他类的方法或者变量，抑或是继承实现来的变量和方法等输入到类自身的符号表中 处理注解 标注：检查语义合法性、进行逻辑判断 * 检查语法树中的变量类型是否匹配（eg.String s = 1 + 2;//这样&quot;=&quot;两端的类型就不匹配） * 检查变量、方法或者类的访问是否合法（eg.一个类无法访问另一个类的private方法） * 变量在使用前是否已经声明、是否初始化 * 常量折叠（eg.代码中：String s = &quot;hello&quot; + &quot;world&quot;，语义分析后String s = &quot;helloworld&quot;） * 推导泛型方法的参数类型 数据流分析 * 变量的确定性赋值（eg.有返回值的方法必须确定有返回值） * final变量只能赋一次值，在编译的时候再赋值的话会报错 * 所有的检查型异常是否抛出或捕获 * 所有的语句都要被执行到（return后边的语句就不会被执行到，除了finally块儿） 进一步语义分析 * 去掉永假代码（eg.if(false)） * 变量自动转换（eg.int和Integer）自动装箱拆箱 * 去掉语法糖（eg.foreach转化为for循环，assert转化为if，内部类解析成一个与外部类相关联的外部类） 最后，将经过上述处理的语法树转化为最后的注解语法树 2.4 生成字节码目的：将注解语法树转化成字节码，并将字节码写入*.class文件。 流程： 将java的代码块转化为符合JVM语法的命令形式，这就是字节码 按照JVM的文件组织格式将字节码输出到*.class文件中","categories":[{"name":"jvm","slug":"jvm","permalink":"http://example.com/categories/jvm/"}],"tags":[{"name":"jvm","slug":"jvm","permalink":"http://example.com/tags/jvm/"}],"author":"jianghe"},{"title":"java概览","slug":"字节码","date":"2021-01-29T06:38:00.000Z","updated":"2021-07-06T15:00:15.391Z","comments":true,"path":"2021/01/29/字节码/","link":"","permalink":"http://example.com/2021/01/29/%E5%AD%97%E8%8A%82%E7%A0%81/","excerpt":"","text":"java概览1. 重要概念 java编程语言 字节码 Java api java虚拟机 1.1 字节码1.1.1 一次编译，处处运行(write once,run anywhere)java源代码的默认编译结果并非是可执行的代码(本地机器指令)，而是具有平台通用性的字节码。尽管不同平台java虚拟机内部实现机制不尽相同，但是他们共同解释出的字节码是一样的。所以说字节码才是java实现跨平台的关键要素 1.1.2 什么是字节码任何编程语言的编译结果满足并包含java虚拟机的内部指令集、符号表以及一些其他辅助信息，它就是一个有效的字节码文件，就能够被虚拟机所识别并装载运行。 1.2 java虚拟机 Hotspot是最流行的java虚拟机 当虚拟机启动的时候，解释器首先发挥作用，而不必等待编译器全部编译完成再执行，这样减少编译的时间 热点探测功能将一个被频繁调用的方法或者方法体中有效循环次数较多的代码块标记为“热点代码”，通过内嵌的双重JIT(just in time compiler)编译器将字节码直接编译为本地机器指令 即时编译器与解释器并存，通过编译器与解释器的协同工作，既可以保证程序的响应时间，同时还能够提高程序的执行性能，并且对编译器的工作压力也降低了一定程度的负载 - 两个JIT分别是client compiler、server compiler，简称C1编译器和C2编译器。 C1编译器会对字节码进行简单和可靠的优化，已达到更快的编译速度 C2编译器会启动一些编译耗时更长的优化，已获得更好的编译质量 编译策略 完全编译策略 编译器 解释器在编译器无法进行的特殊情况会介入执行 完全解释策略 解释器 默认编译策略 hotspot会根据操作系统和机器性能来自动选择","categories":[{"name":"jvm","slug":"jvm","permalink":"http://example.com/categories/jvm/"}],"tags":[{"name":"jvm","slug":"jvm","permalink":"http://example.com/tags/jvm/"}],"author":"jianghe"},{"title":"JVM类加载原理","slug":"类加载原理","date":"2021-01-27T14:43:00.000Z","updated":"2021-07-06T15:00:15.394Z","comments":true,"path":"2021/01/27/类加载原理/","link":"","permalink":"http://example.com/2021/01/27/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%8E%9F%E7%90%86/","excerpt":"","text":"类加载过程 类加载 1234567891011121314151617181920212223package com.classloader;import com.classloader.model.Student;public class JvmClassLoader &#123; public static final int i = 6; public static Student student = new Student(); public int exec() &#123; int i = 0; int j = 1; return (i + j) * 10; &#125; public static void main(String[] args) &#123; JvmClassLoader jvmClassLoader = new JvmClassLoader(); int exec = jvmClassLoader.exec(); System.out.println(exec); &#125;&#125; 1java -classpath selene-1.0.0.jar com.classloader.JvmClassLoader todo 持续跟进中……","categories":[{"name":"jvm","slug":"jvm","permalink":"http://example.com/categories/jvm/"}],"tags":[{"name":"jvm","slug":"jvm","permalink":"http://example.com/tags/jvm/"}],"author":"jianghe"},{"title":"学习路径","slug":"学习路径","date":"2021-01-15T09:12:00.000Z","updated":"2021-07-06T15:00:15.398Z","comments":true,"path":"2021/01/15/学习路径/","link":"","permalink":"http://example.com/2021/01/15/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E5%BE%84/","excerpt":"","text":"集合 java.util包下的非线程安全集合和java.util.concurrent下的线程安全集合。 ListArrayList与LinkedList的实现和区别 MapHashMap：了解其数据结构、hash冲突如何解决（链表和红黑树）、扩容时机、扩容时避免rehash的优化 LinkedHashMap：了解基本原理、哪两种有序、如何用它实现LRU TreeMap：了解数据结构、了解其key对象为什么必须要实现Compare接口、如何用它实现一致性哈希 setSet基本上都是由对应的map实现，简单看看就好 12345678常见问题1. hashmap如何解决hash冲突，为什么hashmap中的链表需要转成红黑树？2. hashmap什么时候会触发扩容？3. jdk1.8之前并发操作hashmap时为什么会有死循环的问题？4. hashmap扩容时每个entry需要再计算一次hash吗？5. hashmap的数组长度为什么要保证是2的幂？6. 如何用LinkedHashMap实现LRU？7. 如何用TreeMap实现一致性hash？ 线程安全的集合Collections.synchronized 了解其实现原理 CopyOnWriteArrayList了解写时复制机制、了解其适用场景、思考为什么没有ConcurrentArrayList ConcurrentHashMap了解实现原理、扩容时做的优化、与HashTable对比 BlockingQueue了解LinkedBlockingQueue、ArrayBlockingQueue、DelayQueue、SynchronousQueue 12345常见问题1. ConcurrentHashMap是如何在保证并发安全的同时提高性能？2. ConcurrentHashMap是如何让多线程同时参与扩容？3. LinkedBlockingQueue、DelayQueue是如何实现的？4. CopyOnWriteArrayList是如何保证线程安全的？ 并发synchronized了解偏向锁、轻量级锁、重量级锁的概念以及升级机制、以及和ReentrantLock的区别 CAS了解AtomicInteger实现原理、CAS适用场景、如何实现乐观锁 AQS了解AQS内部实现、及依靠AQS的同步类比如ReentrantLock、Semaphore、CountDownLatch、CyclicBarrier等的实现 ThreadLocal了解ThreadLocal使用场景和内部实现 ThreadPoolExecutor了解线程池的工作原理以及几个重要参数的设置 123456789101112常见问题1. synchronized与ReentrantLock的区别？2. 乐观锁和悲观锁的区别？3. 如何实现一个乐观锁？4. AQS是如何唤醒下一个线程的？5. ReentrantLock如何实现公平和非公平锁是如何实现？6. CountDownLatch和CyclicBarrier的区别？各自适用于什么场景？7. 适用ThreadLocal时要注意什么？比如说内存泄漏?8. 说一说往线程池里提交一个任务会发生什么？9. 线程池的几个参数如何设置？10. 线程池的非核心线程什么时候会被释放？11. 如何排查死锁？ IO了解BIO和NIO的区别、了解多路复用机制 12345常见问题1. 同步阻塞、同步非阻塞、异步的区别？2. select、poll、eopll的区别？3. java NIO与BIO的区别？4. reactor线程模型是什么? JVM引用了解Java中的软引用、弱引用、虚引用的适用场景以及释放机制 123常见问题1. 软引用什么时候会被释放2. 弱引用什么时候会被释放 类加载了解双亲委派机制 1234常见问题1. 双亲委派机制的作用？2. Tomcat的classloader结构3. 如何自己实现一个classloader打破双亲委派 GC垃圾回收基本原理、几种常见的垃圾回收器的特性、重点了解CMS（或G1）以及一些重要的参数 内存区域能说清jvm的内存划分 12345678910111213常见问题1. CMS GC回收分为哪几个阶段？分别做了什么事情？2. CMS有哪些重要参数？3. Concurrent Model Failure和ParNew promotion failed什么情况下会发生？4. CMS的优缺点？5. 有做过哪些GC调优？6. 为什么要划分成年轻代和老年代？7. 年轻代为什么被划分成eden、survivor区域？8. 年轻代为什么采用的是复制算法？9. 老年代为什么采用的是标记清除、标记整理算法10. 什么情况下使用堆外内存？要注意些什么？11. 堆外内存如何被回收？12. jvm内存区域划分是怎样的？ 中间件、存储、以及框架Springbean的生命周期、循环依赖问题、spring cloud（如项目中有用过）、AOP的实现、spring事务传播 1234常见问题1. java动态代理和cglib动态代理的区别（经常结合spring一起问所以就放这里了）2. spring中bean的生命周期是怎样的？3. 属性注入和构造器注入哪种会有循环依赖的问题？ Dubbo了解一个常用RPC框架如Dubbo的实现：服务发现、路由、异步调用、限流降级、失败重试 12345常见问题1. Dubbo如何做负载均衡？2. Dubbo如何做限流降级？3. Dubbo如何优雅的下线服务？4. Dubbo如何实现异步调用的？ RocketMq了解一个常用消息中间件如RocketMq的实现：如何保证高可用和高吞吐、消息顺序、重复消费、事务消息、延迟消息、死信队列 12345678910常见问题1. RocketMq如何保证高可用的？2. RocketMq如何保证高吞吐的？3. RocketMq的消息是有序的吗？4. RocketMq的消息局部顺序是如何保证的?5. RocketMq事务消息的实现机制？6. RocketMq会有重复消费的问题吗？如何解决？7. RocketMq支持什么级别的延迟消息？如何实现的？8. RocketMq是推模型还是拉模型？9. Consumer的负载均衡是怎么样的？ Redisredis工作模型、redis持久化、redis过期淘汰机制、redis分布式集群的常见形式、分布式锁、缓存击穿、缓存雪崩、缓存一致性问题 1234567891011常见问题1. redis性能为什么高?2. 单线程的redis如何利用多核cpu机器？3. redis的缓存淘汰策略？4. redis如何持久化数据？5. redis有哪几种数据结构？6. redis集群有哪几种形式？7. 有海量key和value都比较小的数据，在redis中如何存储才更省内存？8. 如何保证redis和DB中的数据一致性？9. 如何解决缓存穿透和缓存雪崩？10. 如何用redis实现分布式锁？ Mysql事务隔离级别、锁、索引的数据结构、聚簇索引和非聚簇索引、最左匹配原则、查询优化（explain等命令） 123456789常见问题1. Mysql(innondb 下同) 有哪几种事务隔离级别？2. 不同事务隔离级别分别会加哪些锁？3. mysql的行锁、表锁、间隙锁、意向锁分别是做什么的？4. 说说什么是最左匹配？5. 如何优化慢查询？6. mysql索引为什么用的是b+ tree而不是b tree、红黑树7. 分库分表如何选择分表键8. 分库分表的情况下，查询时一般是如何做排序的？ Zookeeperzk大致原理（可以了解下原理相近的Raft算法）、zk实现分布式锁、zk做集群master选举 12常见问题1. 如何用zk实现分布式锁，与redis分布式锁有和优缺点 算法算法的话不是所有公司都会问，但最好还是准备下，主要是靠刷题，在leetcode上刷个100-200道easy和medium的题，然后对应公司的面经多看看，问题应该不大。","categories":[{"name":"面试","slug":"面试","permalink":"http://example.com/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[],"author":"jianghe"},{"title":"flink介绍","slug":"flink-init","date":"2021-01-10T11:26:00.000Z","updated":"2021-07-06T15:00:15.406Z","comments":true,"path":"2021/01/10/flink-init/","link":"","permalink":"http://example.com/2021/01/10/flink-init/","excerpt":"","text":"flink是什么？ Apache Flink is a framework and distributed processing engine for stateful computations over unbounded and bounded data streams.apache flink是一个框架和分布式处理引擎，用于对无界与有界数据流进行状态计算 为什么选择flink? 流数据更真实的反应我们的生活方式 源源不断 传统的数据架构是基于有限数据集 非实时 spark streaming 实时不是一堆数据到达某个时间点处理（批处理），类似于实时聊天 目标 低延迟 ms级别 高吞吐 分布式 结果的准确性和良好的容错性 分布式保持准确 数据传输，合并数据正确性 哪些业务需要使用? 数据报表 用户交互密集 实时聊天 … 应用场景对比 事件驱动应用 传统架构 读写远程事务型数据库 优点：实时性好 缺点：能够处理的数据有限，高并发做不好 flink 无须查询远程数据库 本地数据访问使得它具有更高的吞吐和更低的延迟 savepoint例子 数据分析应用 批处理 利用批查询，或将事件记录下来并基于此有限数据集构建应用来完成，为了得到最新数据的分析结果，必须先将它们加入分析数据集并重新执行查询或运行应用，随后将结果写入存储系统或生成报告。 能够处理海量数据 实时性不好 流处理 流式查询或应用会接入实时事件流，并随着事件消费持续产生和更新结果。这些结果数据可能会写入外部数据库系统或以内部状态的形式维护。仪表展示应用可以相应地从外部数据库读取数据或直接查询应用的内部状态。 流式分析省掉了周期性的数据导入和查询过程，因此从事件中获取指标的延迟更低 批处理和流处理 flink既可做批处理和流处理 处理必须处理定期导入和输入有界性导致的人工数据边界，而流式查询则无须考虑该问题 数据管道应用 周期性 ETL 作业 提取-转换-加载（ETL）是一种在存储系统之间进行数据转换和迁移的常用方法。ETL 作业通常会周期性地触发，将数据从事务型数据库拷贝到分析型数据库或数据仓库 实时性不好 持续数据管道 可以明显降低将数据移动到目的端的延迟。此外，由于它能够持续消费和发送数据，因此用途更广，支持用例更多 flink 架构图 state 数据直接存在本地内存 集群 低延迟 高吞吐 checkpoint 持久化 故障容错 Exactly-once 数据正确 flink cdc(change data capture) etl例子https://github.com/ververica/flink-cdc-connectors/wiki/%E4%B8%AD%E6%96%87%E6%95%99%E7%A8%8B","categories":[{"name":"大数据","slug":"大数据","permalink":"http://example.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"}],"tags":[{"name":"flink","slug":"flink","permalink":"http://example.com/tags/flink/"}],"author":"jianghe"}],"categories":[{"name":"并发","slug":"并发","permalink":"http://example.com/categories/%E5%B9%B6%E5%8F%91/"},{"name":"jvm","slug":"jvm","permalink":"http://example.com/categories/jvm/"},{"name":"面试","slug":"面试","permalink":"http://example.com/categories/%E9%9D%A2%E8%AF%95/"},{"name":"大数据","slug":"大数据","permalink":"http://example.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"}],"tags":[{"name":"并发","slug":"并发","permalink":"http://example.com/tags/%E5%B9%B6%E5%8F%91/"},{"name":"jvm","slug":"jvm","permalink":"http://example.com/tags/jvm/"},{"name":"flink","slug":"flink","permalink":"http://example.com/tags/flink/"}]}